<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>四月总结</title>
    <url>/2021/Apr_Summary/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="81a72725b3338c44818675bb711ff2e5706f6ece0afaa74d6e6d3addeacc7005">0562a2c5c7f9acd38697d845002f50ef0b9152c8d23fa52796fc9d0445d2e04112194c41892485021f6cd1cc0634f7c88bc06ff6ad4e5cd0f0db8ea709a5055d3dc404e6780d89fc06544ee64497e13b86af37cea07baa5fac205de48ef6d757d63e9d7e2e710a1620ebc0acfff493d7b428c49ba540f9b5e6d7f0704638b8edb5ae681fcf1fff3ebbf54157c063e32f96a100cf02edc5ff2e4a37f09a1ebd0940603a0e7806cf3b58c956352836ba57c0ca5d42d1f15380b5e48fc1a4a3ae1b8ec5f83b89decb5afd656a7f2b429771c5f3670a7ad3b4206cc6286d9d8e632ed162a65269e3a7ace16b4b8b60bc258126fe8554cc2a11f483a440b2766635aab7e51090a63ed034f88ad2ae0253bde28faa0e5f3afde1d417415060ec9ffdf3aaf6e35375dba83cdf2f8ef153265f7c5b6a803ca1f750b32b52cc4be153c4d532197f63c86da652f2e2eb15ef2ecc78c73776c168a9836a258cbb5a83f3f83f3f347013491e6bc3d975664f83c031e1de7eb76bd72316cdd0afb5b7b59ef97e9ba7963fc20ccee1f364b850cd46b121a890213014c707a4bd98127ebfb637b347e78dd03f052f484a0cb7f97e848b15a2001ee668ed33fb0df7df62b7325998c570c02aef19c1277a6badf0a3584da3e33694ab1aa1fc5a6cb39efa77efee404b5f6dda642f36f854cf0ed37194fe855b870613ff77628c8e6ae75642be916f5d6426ef3e37a80325caad4a19dd8e6a2b7cd61812f3845c4bf4fc2b2a544adfa48178d82a2cb368450c6833fd49ef9224c3a4b2594474d18cea69fd1bb7827d501d2d02fb65674745bb0efa00f3d563b22ca7e06f3f10c7b8ea1adc96d3a8db0d0f1b1ad8172ffa33a5e5a351097d80e7038dcafa6e1f1f9e010c2454b25bc0b6357e4198f2a679a294282cfd22bb4dabd74476681460673df4f7ed2bafb61dd8f2f103f31d8afd880bcc930e6c9f5a15039a285222c3cfd0c03f59b9d043c335656e08c6f14d273b12a627b9d6e0e78577415ed025a45439609d709491d805cacbffc2e981b86cfe686c11da7d0d6d00a6ac05e177bf763a142c0756cac7630cc39dc3b378b9a1589634138dacaf74e1e41c93cfe9829d378b5b789975d5527da4acf16645ff66972025d5b19ce01ab12a414af71ba357dd4043829256f327090b8444cab479b6866ef8ae08b120babf7ba282c8defd6568f0fd55b727aba99a242a181ef204cf011c1602c49652eea9264855b285678ca93c742dd16ed3f8aed6bc413ca4bb704a07ab151662f685b59df5736bbd50f7792b339da8fc26efc78bde371324a4f7dd33e1e3631db170cb0ed04f0c88709337ddfa54fbc05c0209c1bd2c30845cbf7e2b97e4c4be526ffb1e4bfdb7394b89b1ca34eb16948ebae24358e48ddf14e217e169887e656c5697b2ae310e3d3eef872126402a4b4f22f0affbd01650ba0ff913a9784110da7a94c5e46c47a15179b07dba78fb92a833a556dd3deed18c5d242122774bb9447fbc8c15ccd5d9a97395eaba3b20ecf2c27afdfa6ed5fdc2bf13e54b66d2b70629b7da82b563ef9e083df4c0f3041074f63debe5ccac934543d2311e19ea2e33a0de9411a39baa5cf6a41d4acdae6fdadc86f4674091062bb8790199aaa07e01f6b0f87eb7f4e57f3a2b1da0d5b59cbd2b00a69935b2596bae068cd750e208ab53c0114eaa9df8133b3d2911fe1e777e8d0d09076a5cb2a245a9fbe045fd02f85c753c5c919d32f19a3e4b16726556cabc7d6c5b658aedf432ad8a59e0c969c01caa3ae31eee8f992d3808a5dd748aa3f5aee13c5f4da4d395dff297edf1443dd897384e5b1acb2c43a2204b147f82bfd4b2363ee503262677b34696637680f086c42e9d40739e79c32453424e429c9f561dc7843c2c540c72c4dcccc142cc00100790f3937703a7bf02551b254ef9cb5a9133d2f39c989dd639e13efc87ec85c42be57e790bc668fdaf8dfe5518411db4543dd559073188ff4942d4c8ffa19be3a75069fd81bc83d943a0c423414b63314db0490f92e3609b2ec3f84977c78e602f18055f875315193ad9c2044327dc9934e9320637b061621895b803057da9781bd7647946cda8893beb44ee59d89bb8fa59b46afea801c455d0cd84e4f2329df88ba0e137110abf2261943f2290420ef2787715dce1143995d18831b00033cff5af35208cd580e78564bc3e89a37560dd3550aee30987b894239b91d7173fb4a84318cd938e84ef5a8e4738d10f14a0fe0c5b591c341416c72d2838ec21e991cb1b4cbb6ff0e8ceab35febd5fdbdf7a5dbefaaaf3990b93bac8ffb31b0e9d591701de34b9ee63e9fcc1e6fcbc1fc39020390eced6081b589bbdf0b40c313528c7f75fccd6f578f2ffc4a848c1f3868339a9c33f08dc879a9706c7ad313cc9dfc93c476c0eaaf96bdcfced24e7d38df45fce946b7f6d31239f21127e4d78e2c637163f143816c920a2b7919518300b7d6416ebb70bb46d4884d4e6c778b0fd6bf7be249171972e42f7d5b701be0a45a20dba0edcae14a6bfa329e126feb2f5c9bf547d26de71c2c0e23cdb9513e99116ff39686f3fdc814f6526b3f85d6815234b0ce41de9dd46da050ec0f23007474e5318ce86ff740117ab9e253a64f3ccefe720b60bc16e050cf86163030be8e14fcb4cef80a8cfffe4b7d38fa8de5bc4fc5b0ab68dc8de4996007cb5ea14da4aa5c5c99dffff2d06e0bb891fa8aed16618faa45f9e466dea48bc63044ccc8feba044b5b43efcef8071411c19229e3759cf27bcd4e5f6ea16fd86d1d996d89089a918cf3b5e32c8272882d12a1db62275d5897c45a30fd795a2d053249fc63ea1a8e08a976d3af1f3668fdf6f939a2d2c284897910239742d93c284c3438b749ae5fde4743639b799adaa968c289823dc0d50efed4c6fa16afc4bc848eb9512ea29696778f3b9b447da80cc6c675604b049d9424897929fac312a61495fe79a943c73fccd4d1f3683997115a545daa4e78fa42ca074db092b9a118eff674edb9b366e3c9c6c2272e94c484992f516ed0bc4c7d3bb9f54ec2965aab78491f28780877a09ce4f2c2b35c4ecdf2f5355b5e61e822bba9f8308888002d822122121c6ebfa7e31f0d3ec47983aee94be945a28c0202a6486c5fdb0df92be9cdbf0d9c6eac70e5508d7f6593e19247ce175afcb88ffb5457353ae30578e89c6ba5fe10e0df71dbf34aff32a2e84100dc42e6cdc49f6d1f9da6fa1ece83fee1dca502a6d0a44751b4c7f8b8725f84df854ee7ae1725531792606c1620e0bcdfd568f373cc6c84df7203c830b836eb6ceba5e4927b1ac37cea38f4c8c1fcf80ace945676749769ea63ccf8a80c00235620e97997f830fc564cad3d30599c825f9637f436f645d28d8d41a3d32530b68048cbb7d483f470e1745d274a700284a969782ac1d0c8aa8d2ee85f842d9e0ce17e5b6c339aaf12ddaa2dd5ffeb2ce7642f231ceea93b06cf97c0757ec45484dc86d858e249319987f5e3add9675b31a8ac9603ab1d6d063432d53da2df7d4a0e32c620f0a25f83bc58378b5f7cc69dcfcbfe15b2d4624881a91149781798b95354e6517fe6f0acdba4e4752dfedfd1bcdae8f73aa9772c274cff35d84f11d24ea2e8e623c45e0033147fe764636c0eec2c2f5289506842d991f5a024453420ac29806f1e8b0bf839dab988f78c2309a3148ef986e30f5356953bd4f59d2f22b9e6f76d4a75cc4121c595dd966a019fe294128da11ce025cf704f2439673ae1291b01b73347659c52adce3a8d384b1e92f9e9b5562a9357193c222c64da1f69cb38652034df015e12c8687536b5d3678403bc9e5f4ccbe535d74638b2583a8572ed33800b8565afec990835fbc24ecc4b6ca3e9ff486c5cda9e077e35072447e09231dd24a0166879a0c0cfa4693c5dc9832254bfb64a718cdc62b1be2e30d77b49dac65b7963fb204b533ab2b6994502b624e5a8b10a892ef3ba27eb737e876ab1d59fb2011b13044906b2f312598eca51a8a6ec95130ebe39e108bbfd8884b27252cadb209d09f2ee88a77a3648722e54a16b2607fdbe7827ec506e53ff300c9560c8d1b816ab669eaf1fab135bd8e873953403be09d1180a407f34bebf07564641a05906efb3b853b1109a470e75aa8b32590fe7adc6df5863840d4ef35f4ee78b59962aeec893437b92de78ab0f22ace087d6fabd7428fbbe616c1987515da1b4b85be6c8d325cf2f92969bb31a9af87ac1774758820640068aa78b99c6082b9a2812f12b82277ebce6faecd2ec2fe61de25cb5450fc0b64d5491e9d45bce0080fb557edc97953ee4018bb8b72cab32db572c9ab1346749f2258fb24cb7c142c7a49ef4058a748c417202594a9bc184fd8ed295e66a138c6c634265984b45e8763f5580d8c9b7cd8d13d151460289fdb8785d3c8d2c0a1f4ce172250dc17f1e70a3e93c1ac7511fe6e22379b28f64d739a1a2886224c93a8f06bd9a6650001c98bca6e4d109995a3d075b6bae3101f632e9322e37b0e3fe94ae8a5b61b39bbb9cc038374b773a0e54bae918e01d811a2ada8be99b4fa390430c6cdd5098b99076f9a4c2ec6c438cead5a4ca9f92925d497575560feeee3e248e9a1b44756ad4fcc9bb321d31b75b40c465dc1a478565736470a1dc70db5d996e875177fac8c4ced2ae012968a573d12da53873df9ea2bfecbbb548265f8f2c394d04fb419def146c4be033383395311d82b97d3aa35c1cde96cc748284d29e78d07b3ad2903f2d4fa47ddd39b7650463bc9cda2abbfcdae17b18e69e382d5417a5225baf95e7e773e883db12c7e5a66c787e42260b855315ecb6a5e8614d28263efc0c9ad8bb46f77a9feaed8838aaa4698c3764e97788d4a964686a9b3e361d732fec821d4ecd1b703c242e0d4b7610ec1c64834ff03d4474fea8e5dec92755287eb84d42b6ec10412879af2716c72fc708649e02d255531b0b334b83481818128cf825ba91e8a9b4baedb181878968ee41f2a5f41549e4f4a80aebd813ef55c4f51341f634d1af2b94948de0248a778c3f6649a63982c46a3ee233f5c77f222c685a3c68014a2bed8a65a78339a072ea9858d18c27bd568e81cb2871701f0317ec3df384bb256612b019bb854aa9b05730cd9d999905c9cb58dfaf47c7811d033ac4e3a63975a47c69285a8b9de7cadb7ed560555f384b482499a7418202d59687cc2cfe3de6f387bda9c2f0e0de58611fdfd6607fb1981f7dcbfbf6340de835730c8a8d0034cdb8cbdc172eac90e171c512f2a1a2e6002ce6202037337b3280d7ab233454c7705e6cb415cd7f1ff755d6022ab3b985942a492505bd6d1a9a26511ab135df645a67c98317af46657dd112c72aceee6a3e65f39f1de181532f28962ed59f22d62c8baca9f7666f9a21a1a74b08df5f5e8c69d4140c9357210eab6fb19d05f888311d263a9b81fdda6c61160bfe0d4e5b6a98b08160f17b903aad4ce89fe81196ab218c42135a6ad429787c8c53815a4cc584c0d620a122c71393a0ed448c85b2f156dd7908e05daf72a08e402d2fe0289df18aab33cc37785ffb850e4c5d6f6ce3791ffcf9ff80373ed324bb4425e1c7cfe8c329c007ab3721a2d6087d32888ddd7a22dc2aa391b585f482b162df63a8afcdec4a4cc90c4eb2a9dac89f31e3945bbc93b8548c42cb9582190ddbe1033447280472533cee62d566f43748dabc89de0f068646337efc9e1a34c22e854ce5a8045643477a447ab0d90792890f77852fc591122aaea40eee184700386454b7ec71089a52ae0da9d7f483f83f335b2bb25b8d432c7b935c15822740b65261fa5be458482bcf188d52d8d633388e5e965a299d284765be090d11ffe9b8c908f9580024784abde3f5d674ff1db87abbe44ab587482a8a72bf34359ad68453a3c1ccfc381e5a325124cc1b42a91a25207ae00996dd495bd121441b01956cab392466411d2c630473ea818cb88c981d310e0ebc78c9a76d6839097c33011f0e76060e00c0eb252e6f28e5e72f2eb037b5f0fe6c998c7e312f8cb1ed47bfac77c428abbd6d3e26a5c59125b23941fca7ad816b055365c4b1cfad419f49295d1f28a44f74dd296a9a291d2a1be106dc9e46e6dda907b79b5782a492362c5849e1d0e24aecef7ab8a1dd8a3222408283d699f371d1168b193aa30910eca48fb13734ae586efe52151bf7d5a3278180ea69cff5c2fc0def712dc93e8f1dfe5814b5e8df679e474bfce1d2d66fb0702abb526b9c763247c6bc863c060035ec88abf00293c17e57fa5dd4dc40566e8d1f15191505f285946990cfdb2b4ed63847a7292846de15c045d00ef8ecaa8af86aceb05a3e97ad6ee8ec5b02b76717344624b3002accf38e47d1ffb4c4d40dc0ffec4fad1db056ec6a713415cffa7789b9f03e1763f2ab5b95d0f565c08c259a1349c7e5712544f77a4e4a90ea19e8c2401e5b5dba1c2bd5433ee50e9c9ad61d4104db37766fb39c3aeda2ee6b3d6cc581633080da98a08633981c6212cb3d47b7d9bce6770d58c580bc7fda01c772c63fa8229f4035af94c819317bc141ae191723d6def88d0f4cf14debbe711e952b7637f2927421aefc6dc5a1fa48948132d3cf8b9385996307fbb677f8923214905141a530bdf46d69c0deaea9e1e76f7bede9ec5b140ea7070da38322e458a11c3794a172c7ec18112bd43833be6b4a5888910aedd83ac8b3ed778a024cd4740eb6d58a6dd36103bfee29d2d110c1e4a7e6681d08137cec87068ac1ad76ee1a6189755c2aed80718967b0e601b52160d2d1783f624912c7fa594c792b72727b67773879269bd750e662c5b5898059062f83261f611f7bad7a542e4425c94150537ac4865e17467d063057da8c48f313fcb53c656079197b79bba812a9de39e36193f3ee7c3231e704d34b6a76f3faf061a4361d1f6d71513685f5a265c0150136e880bd7738a7153610ac812d5041df1c1a9ec5a552a95ed9bb529cf808f210b9664b5828e17f8607c7d72190021bc9253f05fab6b842050b3b6bfbf963948cbe185a837c33ba12adb09db7d77f64eec38689c27cc81fd60224fda08f64f0facc0db48cc4bdd52c0206a23663bc475637306f3526f159cfd2dfd79103c3abd495cbc9f73039f39c3ed432ece846c2063cb0eb21cd69edbf93e854f5b254b6171e7962c8c3f65d68a4317d528ab493d04a18450226d810e0516432bdbc3452f34fe14910d314762f78b18443dd54001b52c52d56160c968334921cb59e177b21506529c0e721a6f277ee9b18e5f5f0b7353a769710f8d0812ba68c3c4708e33fa281ce1e5acb7fa752f21311d45552a51579d8495c407f8f2dc8613ffb660b7b520095872bce49f2779bdd10b605c7e1384286f4641ed3e7e44d86146e08e81bf596dfdd66eac918db4df9b77c7b46f1e2d2a7ed11a902eb036997be53645de6fca21624ecef14656777ee4fb4915e9f3eaebf0e293752d39b7566af6dfd745acb62bc65f17710d04f5947820aab810d0a120d3fd13d58b47e200fd3384203005007ee729401de6b6441dee97eeaa474db6e44d315002cb35f06f71570579e2a63adb35739bc994e369c912fd2de84e9e1a5bf4acaf1b75ed5b0498c611c9d62278b12f03fed2f05187479ae85581ff029eb7f891c0c97f9978cfc0b36b5237b1cf33c334897848ee576169ad0965b38d670aca58e231cca6329a47c3e292d520658944fd12e0d09cd5bb0f7892af822ef7feddb28a80985ecfc4677995bcca317458caf2087f85eb4f89971941229d03c6c0946e6c349c24789f7e79593d2f7bec89237ff98268ba2a0fd1fb8ca4894dc065dfd5814df3f39b18eefd64a674ac78b31fbfcd28058f9074058e8c98c1ff52badf6fc60a5a4ebd02ea982b27916abe6067a4019f107ac44854632d7cfe1fb6c6ac43d12cd963570fa49e2a0ff189ace09339585f1d6e0b7c4b2384a0d273df7708b3f3a6b75f7f9467e3c9968a7dae1259edb01d16f3e5f9d406bc6ce6880c61418aa6b87ced8bbc1937ac43119ba186dbc9a5e4238a411e130a00d94df98b7bc47f8ec4e951aa2019e178f54e5a96a0016227e580ebcf57c32f1abd90a47ebfff159da90f28c341b722fe511de7f75c175442d97c23e4c7859105b6e47e087d3221f39ddcf710b05e15adb74dc7f76d813c2c3a8d151fce186392bb7357b7e90b29a17469fab2fd701884a789cd5c780a938a5cb328b678bf0be677a699ca69b0ca0363d18fa3e9f32d7fe0a0b2b007db091112d375275e8b66e09e4bd637430985211d9fb4444bc2501fb061474cc736287f7d29dd7997a859489cd34b4df3218b5062538ee293d8f781aa662ca0e31a711899459e5f6d9e52dbced8fa047d43982125c5dd6466a3bd6e19f7f20187ebaae5737295d4d1254d8a30077f3cfe49d885057c6778049945789d53d3fcad66b5cab939d9caecd5dd934a8a8a863b56f9c0a3549a0280e736bce12914131b9438cb54d7d12d38daa3ba95d6bc161989642acbd0bfc8b0b36edf562b5811fba6c9b1a18393ac17640f1a4ecc39e184e796206d03b32a35caadae38b34f37e4554f3eb9988c67889a7860300c1bd6e34764bc4a87054ecf3978f24df89a0697f670a71496afcc560ea1310d7349743ff4762fcc8ba2c525ec2faa7fc72688bf372a99c8ec7acfd94dc0d08e6108fe820061c2f3f7ef5b365089f28920e886c89f099214d9faa6ea6ccf50e0b05b1b3e3859b89714221bb5d74cf00a49441d079f64366c1e686e8cd6e19877384b2923ee43798fba24553eff316c173c17d4a470372ed182d487ca824b2121f4f455dde0324f405c3ba4f83e65a2a99f8ce82cde0ffc8fe11e8b0da3744d7b96a6c21a2b57ba3b4bea50f4bbe6651c2e5a25289b7c0fb3fd5b3f72e78c9bb9322740261122dfa391e0bcacc605b8c89660bf3430fd36bf0bc482e333872baa8229839e230bff3fe05fd1f2d5316b3c2076e122c4cf600ef5a239b01829bcc2beb1c72451dd03a6007ce183e3292482d85b56f849cf563249d8928c42bf753397f40042b344954d628a8941082a91995e44a48ca496cb852bafa5</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ templates 2nd</title>
    <url>/2021/C-templates-2nd/</url>
    <content><![CDATA[<h1 id="第一章-Function-Templates"><a href="#第一章-Function-Templates" class="headerlink" title="第一章 Function Templates "></a><center>第一章 Function Templates </center></h1><ol>
<li>C++ 中equality 和 equivalent 的区别</li>
</ol>
<ul>
<li>Equivalent 要求类满足”LessThanCompare”,即这两个实例可以使用”&lt;”进行比较</li>
<li>Equality 要求满足EqualityCompareable,即可以使用”==”比较</li>
</ul>
<ol start="2">
<li>从语意上来说，<code>class</code>和<code>typename</code>它们是Equivalent。由于class存在一定的误导性，所以推荐使用typename来声明模板参数T</li>
</ol>
<ul>
<li>typename 主要用于依赖于另一个模板参数的嵌套类型时进行声明,如下例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename param_t&gt;</span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">  typedef typename param_t::baz sub_t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>在显式实例化模板时，必须使用class关键字<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template class Foo&lt;int&gt;;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>对于不同类型的实例的实现，都会根据传入的参数来对应实现</li>
<li>模板的二阶段检查(Two-Phase Translation)</li>
</ol>
<ul>
<li>第一阶段检查： 在未生成实例的定义期，检查未使用模板参数的代码正确性<ul>
<li>语法是否有误</li>
<li>是否使用了不发现的变量、函数名</li>
<li>static assertions 检查</li>
</ul>
</li>
<li>第二阶段检查： 在对应生成实例期间，检查依赖于模板参数的代码是否都有效。基本上，所有代码都需要经过第二阶段检查</li>
</ul>
<ol start="5">
<li>当且仅当有一个template type时，传入的值的类型必须与第一个值的类型保持一致。如果需要类型不一致，可通过以下几种方法来处理</li>
</ol>
<ul>
<li>使用staic_cast 来解决<ul>
<li>Eg: max(static_cast<double>(4),7.2); // ok</li>
</ul>
</li>
<li>使用显式声明来避免自动类型推导<ul>
<li>Eg: max<double>(4,7.2); //ok</li>
</ul>
</li>
<li>可以声明多个模板参数</li>
</ul>
<ol start="6">
<li>在C++中，Return Type 是不能从调用者使用该调用的上下文中推断出来的，可以使用如下方法来处理return type</li>
</ol>
<ul>
<li>在实例化时，通过显式指定return type<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T max( T a, T b);</span><br><span class="line">...</span><br><span class="line">::max&lt;double&gt;(4,7.2);</span><br></pre></td></tr></table></figure></li>
<li>当定义多个template parameter时，可以通过指定第一个为return type，实例化时仅需显式指定return type就可以了<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename RT,typename T1,typename T2&gt;</span><br><span class="line">RT max(T1 a,T2 b);</span><br><span class="line">...</span><br><span class="line">::max&lt;double&gt;(4,8.3);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="7">
<li><p>在不自定义return type情况下，可以使用如下方法来决定return type:</p>
</li>
<li><p>使用auto进行类型的自动推导</p>
</li>
<li><p>使用自动推导函数    * C++ 11 版本可以使用decltype()函数，其写法如下<br><code> auto add(T x,U y) -> decltype(x+y);</code>    * C++ 14版本可以直接使用auto类型推导，原因：C++14版本使得普通函数具备返回值推导的能力</p>
</li>
<li><p>可以使用std::common_type函数(std::common_type 推导出一个可以覆盖所有所定义类型的通用类型)    * C++ 11版本使用std::common_type()    * C++ 14版本使用std::common_type_t()</p>
</li>
<li><p>在实例化重载template Function 过程中，会根据参数优先匹配非模板函数，不匹配才会寻找对应的模板函数相应实现</p>
</li>
<li><p>为何使用值传递而不使用引用传递的原因</p>
</li>
<li><p>值传递语法更简单</p>
</li>
<li><p>编译器对应优化更好</p>
</li>
<li><p>move语意使得拷贝更方便</p>
</li>
<li><p>有时根本没有move和copy</p>
</li>
</ol>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a><center>第二章</center></h1><ol>
<li>在class template中，使用类名但不加模板参数代表类和模板参数作为它的实际参数,如下例所示<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">Stack</span> (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">  Stack&amp; <span class="keyword">operator</span>= (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//等价于下面的代码</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;</span>T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  Stack&lt;T&gt; (Stack&lt;T&gt; <span class="keyword">const</span>&amp;);</span><br><span class="line">  Stack&lt;T&gt;&amp; <span class="keyword">operator</span>= (Stack&lt;T&gt; <span class="keyword">const</span>&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>C++ template 定义变量时需要注意”&gt;”的使用</li>
</ol>
<ul>
<li>C++ 11版本之前，两个相邻的”&gt;”中间需要安插一个空格<ul>
<li>Eg: Stack&lt;Stack<int>&gt;</li>
</ul>
</li>
<li>C++ 11版本及之后的版本，都可以直接写入两个”&gt;”而不需要空格<ul>
<li>Eg: Stack&lt;Stack<int>&gt;</li>
</ul>
</li>
</ul>
<ol start="3">
<li>如果想要特化一个class template，那么需要提前声明template&lt;&gt;和一个具有规范类型的类</li>
</ol>
<ul>
<li>类将作为模板参数</li>
<li>类型将被直接指定声明在类名中</li>
</ul>
<ol start="4">
<li>在一些特殊情况下采用偏特化会更好</li>
</ol>
<ul>
<li>与全特化基本类似，但是偏特化可以定义单个/多个参数</li>
<li>模板参数也需要被直接指定在类名的定义中</li>
</ul>
<ol start="5">
<li>默认class template parameters可以定义为一个容器用来管理数据</li>
</ol>
<ul>
<li>也可以在main()，对于想要使用的容器进行显式指定</li>
</ul>
<ol start="6">
<li>通用的类型别名</li>
</ol>
<ul>
<li>使用关键字 typedef,用法如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef Stack&lt;int&gt; IntStack; &#x2F;&#x2F; typedef 关键字</span><br><span class="line">void foo (IntStack const&amp; s); &#x2F;&#x2F; s is stack of ints</span><br><span class="line">IntStack istack[10]; &#x2F;&#x2F; istack is array of 10 stacks of ints</span><br></pre></td></tr></table></figure></li>
<li>自C++ 11版本之后，可以使用关键字<code>using</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using IntStack &#x3D; Stack&lt;int&gt;;  &#x2F;&#x2F;alias declaration</span><br><span class="line">void foo (IntStack const&amp; s); &#x2F;&#x2F;s is stack of ints</span><br><span class="line">IntStack istack[10];  &#x2F;&#x2F;istack is array of 10 stacks of ints</span><br></pre></td></tr></table></figure></li>
<li>IntStack 和 Stack<int> 是两个可互换符号的相同类型</li>
<li>对于已经存在的类型，如果需要定义一个别名。推荐使用typedef,这样会使得代码可读性更好。</li>
<li>C++11之后，我们可以alias templates,用法如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">using DequeStack &#x3D; Stack&lt;T, std::deque&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="7">
<li>class template 参数推导会根据字符串字面来进行推导，如下例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Stack (T const&amp; elem) : elems(&#123;elem&#125;) &#123;&#125; &#x2F;&#x2F; initialize stack with one elemet</span><br><span class="line">  Stack stringStack &#x3D; &quot;bottom&quot;;  &#x2F;&#x2F;Stack&lt;char const[7]&gt; C++17版本推导结果</span><br><span class="line">&#x2F;&#x2F;这种写法会导致在T确定为char const[7]，将无法修改，所以应改写成</span><br><span class="line">  Stack (T elem) : elems(&#123;elem&#125;) &#123;&#125;;</span><br><span class="line">  Stack stringStack &#x3D; &quot;bottom&quot; &#x2F;&#x2F; Stack&lt;char const*&gt; C++ 17自动推导</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Read Notes</category>
      </categories>
      <tags>
        <tag>theory</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-C++ Reading Notes</title>
    <url>/2021/Effective-C-Read-Note/</url>
    <content><![CDATA[<h1 id="第一章-让自己习惯C"><a href="#第一章-让自己习惯C" class="headerlink" title="第一章 让自己习惯C++"></a><center>第一章 让自己习惯C++</center></h1><h2 id="条款一：视C-为一个语言联邦"><a href="#条款一：视C-为一个语言联邦" class="headerlink" title="条款一：视C++为一个语言联邦"></a>条款一：视C++为一个语言联邦</h2><p>&emsp;&emsp;最初，C++仅是C加上了一些面象对象的特性。经历多年的发展，随着大量特性与功能的加入，使得C++成为了一个无可匹敌的工具。但也是这些特性与功能，会让我们困惑于，我们应如何使用它们，该如何理解这样一个复杂的语言呢？<br>&emsp;&emsp;最简单的方法就是将C++视为一个相关语言的组成的一个联邦，对于C++来说，它大致由四个部分组成：</p>
<ul>
<li>C语言<ul>
<li>作为C++的基础。C++中的区块、语句、预处理器、内置数据类型、数组、指针等皆是来自于C。部分特性展示:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> k 45</span></span><br><span class="line"><span class="keyword">double</span> blance[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Object-Oriented C++<ul>
<li>在初始C with Classes,缺乏真正的面向对象思想。因此加入了:class(包括构造与析构)、封装(encapulation)、继承(inheritance)、多态(polymorphism)…等,从而符合面向对象设计的古典守则。部分特性展示:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    ~<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> :</span> <span class="keyword">public</span> test &#123;</span><br><span class="line">  <span class="comment">// 封装</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> k</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Template C++<ul>
<li>这是C++ 泛型编程部分，它们威力强大。它们也带来了新的编程范型，也就是template metaprogramming(模板元编程)。部分特性展示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span> <span class="params">(T a,T b)</span> </span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>&lt;</span>T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>STL<ul>
<li>这是Template 程序库，它由六大组件构成。它们有着严格的要求，与它们工作时，我们也必须遵守它们的条约。六大组件图：<br><img data-src="https://7894651.xyz/effective/pic.png" alt="avatar"><br><font color=red><strong>C++语言的高效编程需要根据使用它的不同部分不断变化的。</strong></font></li>
</ul>
</li>
</ul>
<h2 id="条款二：尽量以const、enum、inline替换-define"><a href="#条款二：尽量以const、enum、inline替换-define" class="headerlink" title="条款二：尽量以const、enum、inline替换#define"></a>条款二：尽量以const、enum、inline替换#define</h2><p>&emsp;&emsp;#define属于一个从C继承而来的特性，那么说明我们对它还是存在一定的需求的。但是对于现代版本的C++来说，它存在了一些我们不得不去替换它的原因。</p>
<ol>
<li>#define会盲目替换目标码</li>
</ol>
<ul>
<li>可以使用一个常量来替换宏定义，这样就会避免出现多个目标码的情况。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 2</span></span><br><span class="line">替换为</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>常量字符串最好使用std::string 替换 char *</li>
</ol>
<ul>
<li>char * 仅是声明了一个char指针指向字符串，C++中提供了专门处理字符串的类型即std::string。非必要则默认使用std::string。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//最好替换为</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> std::string <span class="title">test</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>#define 不提供任何的封装性</li>
</ol>
<ul>
<li>由于#define不重视作用域，可以被随意调用，因此它不具备封装性。我们可以使用static const为class创建专属变量，限制作用域实现封装。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// static 限制作用域</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> demo = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>#define无法阻止reference或pointer指向某个常量</li>
</ol>
<ul>
<li>可以通过enum来实现这个约束。</li>
</ul>
<ol start="5">
<li>形似函数的宏会带来意想不到的错误</li>
</ol>
<ul>
<li>使用inline替换，它遵守作用域与访问规则。</li>
</ul>
<h2 id="条款三：尽可能使用const"><a href="#条款三：尽可能使用const" class="headerlink" title="条款三：尽可能使用const"></a>条款三：尽可能使用const</h2><p>&emsp;&emsp;const是一件奇妙的关键字，它给所有被修饰对象添加了一个约束，即不可被改动。编译器会严格的帮你执行这个约束直至程序结束。<br>&emsp;&emsp;使用const修饰变量，我们常用的两种方法:Top-level const 与 Low-level const;</p>
<ul>
<li>顶层const (Top-level const)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 顶层const</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> b = &amp;a;</span><br></pre></td></tr></table></figure>
<ul>
<li>const所修饰的变量<strong>本身</strong>是一个常量无法修改,指的是指针。</li>
</ul>
</li>
<li>底层const(Low-level const) <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 底层const,它存在两种写法(根据习惯)</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *b = &amp;a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *b = &amp;a;</span><br></pre></td></tr></table></figure>
<ul>
<li>const所修饰的变量<strong>所指向的对象</strong>是一个常量，指的是变量。 </li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;根据const的性质，合理的使用const。有利于我们侦测代码中的错误，避免一些类似于”==”打成”=”的低级错误。<br>&emsp;&emsp;使用好const也是编写高效代码的关键其原因有二：第一，<font color=red>它使得class接口比较容易理解</font>，清晰的知道什么可以改动，什么不可以；第二，<font color=red>使得操作const对象成为可能</font>。</p>
<p>&emsp;&emsp;在const与non-const有着同等的实现时，<font color=red>我们最好使用non-const版本去调用const版本</font>。倘若我们使用const版本调用non-const版本，我们岂不是违背了const的性质。当然有人说，可以使用转型不就可以了。但是转型之中又存在了安全性与破坏类型系统的风险，因此，使用non-const版本去调用const版本就成了优选。这样还成功避免了代码重复。</p>
<h2 id="条款四：-确定对象被使用前已被初始化"><a href="#条款四：-确定对象被使用前已被初始化" class="headerlink" title="条款四： 确定对象被使用前已被初始化"></a>条款四： 确定对象被使用前已被初始化</h2><p>&emsp;&emsp;读取未初始化值将会导致某些意想不到的行为，以及之后一些痛苦的调试过程。对于内置类型我们只能进行手工的初始化，对此之外的初始化操作全都落到了构造函数的身上。<br>&emsp;&emsp;对于构造函数初始化，我们常用的两种方式：赋值初始化、初始化列表。</p>
<ul>
<li>赋值初始化<ul>
<li>一个伪初始化，可能创建临时对象,并调用operator=();<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">  public:</span><br><span class="line">    test(int num);</span><br><span class="line">  private:</span><br><span class="line">    int len;</span><br><span class="line">&#125;;</span><br><span class="line">test::test(int num) &#123;</span><br><span class="line">  len &#x3D; num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>成员列表初始化<ul>
<li>单纯的初始化，编译器会一一操作初始化列表,在任何显式用户代码之前。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">  public:</span><br><span class="line">    test(int num);</span><br><span class="line">  private:</span><br><span class="line">    int len;</span><br><span class="line">&#125;;</span><br><span class="line">test::test():len(2) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;对于成员列表初始化操作，对于成员排列顺序应和它们在class中的声明次序相同。当然，如果忘记了排序，编译器也会对列表进行一个重新排序。</p>
<p>&emsp;&emsp;为了免除”跨编译单元的初始化次序”问题，我们需要使用local static对象替换non-local static对象。其原因是：C++保证函数中local static对象会在”该函数被调用期间”首次遇上该对象的定义式时被初始化。</p>
<h1 id="第二章-构造、析构、赋值运算"><a href="#第二章-构造、析构、赋值运算" class="headerlink" title="第二章 构造、析构、赋值运算"></a><center>第二章 构造、析构、赋值运算</center></h1><h2 id="条款五：了解C-默默编写并调用哪些函数"><a href="#条款五：了解C-默默编写并调用哪些函数" class="headerlink" title="条款五：了解C++ 默默编写并调用哪些函数"></a>条款五：了解C++ 默默编写并调用哪些函数</h2><p>&emsp;&emsp;当我们创建了一个空类时，它真的是空类？当我们在编译运行时，编译器会为我们创建一个copy函数、一个assignment操作符、一个析构函数还有一个默认构造函数。这些类型都是public类型且它们都是内联(inline)里面。当然，仅在它们被需要的时候，都会被创建出来。这样就像如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Empty</span>() &#123;..&#125;	<span class="comment">// default构造函数</span></span><br><span class="line">		<span class="built_in">Empty</span>(<span class="keyword">const</span> Empty&amp; rhs) &#123;...&#125;	<span class="comment">//copy构造函数</span></span><br><span class="line">		~<span class="built_in">Empty</span>() &#123;...&#125;		<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">		Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs) &#123;...&#125; <span class="comment">//copy assignment操作符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这些默认函数都提供了哪些功能呢？接下来我们将对它们进行一一分析<br>&emsp;&emsp;首先对于copy构造与assignment操作符的作用仅是把每一个non-static(class 中的成员)成员变量拷贝到目标对象。<br>&emsp;&emsp;对于析构函数，它们仅仅是将对象释放掉。由于是编译器提供，所以它的默认属性是<font color=red>virtualness</font>，在多重继承中这可会导致内存泄漏之类的麻烦问题<br>&emsp;&emsp;默认的构造函数被构造出来，仅仅是为了让满足编译器需要。它们并不会被直接合成出来，只有被需要时都会被合成。它也不会显式设定class的init值。</p>
<p><img data-src="https://7894651.xyz/effective/pic1.png" alt="avatar"></p>
<h2 id="条款六：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款六：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款六：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款六：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>&emsp;&emsp;在一个系统中，若是每个数据都是独有的。那么对于编译器的copy构造与copy assignment操作符，就应该明确拒绝。<br>&emsp;&emsp;但是如何拒绝编译器提供的版本呢？大师提供了一个思路，那么就是在类的private中将它们声明出来，以此来明确拒绝编译器提供的版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	demo obj1; <span class="comment">// 使用default constructor</span></span><br><span class="line">	<span class="function">demo <span class="title">obj2</span><span class="params">(obj1)</span></span>; <span class="comment">// 企图拷贝obj1 不可以通过编译</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其替换成,避免使用默认版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">demo</span>(<span class="keyword">const</span> demo&amp;); <span class="comment">// 仅声明</span></span><br><span class="line">		demo&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> demo&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是对于class 的member function 与友元函数，依旧可以调用private函数。所以最好的办法，使用继承的办法。将copy构造与copy assignment操作符写入基类，用以防止子类调用它们。*</p>
<h2 id="条款七：-为多态基类声明virtual-析构函数"><a href="#条款七：-为多态基类声明virtual-析构函数" class="headerlink" title="条款七： 为多态基类声明virtual 析构函数"></a>条款七： 为多态基类声明virtual 析构函数</h2><p>&emsp;&emsp;在条款五中，我们提及了virtualness的虚拟函数会导致灾难的。这节我们将深入理解这个背后的原因。<br>&emsp;&emsp;当deirved class经由一个base class指针被删除，而被base class带着一个non-virtual析构函数，其结果未有定义——实际执行时通常发生的是对象的derived成分没被销毁。<br>&emsp;&emsp;如果派生类中含有基类的成员，但是调用析构函数后。诡异的事情发生了，派生类中的基类对象被销毁了，但是对于派生类对象没有被销毁。这就产生了局布销毁的对象，这也是导致资源泄漏、败坏数据结构的源头。给base class 析构加上虚函数，在delete父类指针时，会先调用子类的析构函数，再调用父类析构函数。<br>&emsp;&emsp;当然，对析构使用虚函数仅在多重继承使用。如果是在单继承，随意的使用虚函数会额外的增加编译器的负担。<br><img data-src="https://7894651.xyz/effective/pic2.png" alt="avatar"></p>
<h2 id="条款八：-别让异常逃离析构函数"><a href="#条款八：-别让异常逃离析构函数" class="headerlink" title="条款八： 别让异常逃离析构函数"></a>条款八： 别让异常逃离析构函数</h2><p>&emsp;&emsp;如果我们在析构中捕获异常，如果程序正常结束，一切OK。但是如果调用导致异常，析构将会传播这个异常，将程序带向一个不归路。对于这个问题，我们提供了两个办法来解决。<br>&emsp;&emsp;如果出现异常就通过abort()结束程序。强制结束，也就避免了异常从析构传播出去，提前阻止的不明确行为的发生。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">test::~<span class="built_in">test</span>() &#123;</span><br><span class="line">	std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一般来说，将异常吞掉会是一个馊主意。但是这种行为可比草率结束程序或发生不明确行为带来的风险好。<br>&emsp;&emsp;对于异常处理，我们最好是提供一个普通函数(非在析构函数中)来执行这个操作。</p>
<h2 id="条款九：绝不在构造与析构过程中调用virtual-函数"><a href="#条款九：绝不在构造与析构过程中调用virtual-函数" class="headerlink" title="条款九：绝不在构造与析构过程中调用virtual 函数"></a>条款九：绝不在构造与析构过程中调用virtual 函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transation</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Transation</span>();</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transation::<span class="built_in">Transation</span>() &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">logTransaction</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transation &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTransaction</span>:</span> <span class="keyword">public</span> Transation &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于b来说，作为子类初始化时。一定会对基类成员进行先初始化，但是在基类构造函数最后一行调用了virtual logTransaction,这也是引发错误的点。那么这里就导致b使用了错误版本的logTransaction()。这直接导致的结果是，virtual 将不再是virtual 函数,这也是一条通往不归路的直达列车。<br>&emsp;&emsp;但是如何确保derived class 对象不会调用错误的函数版本？ 确保构造与析构都没有调用virtual 函数，而它们调用的所有函数也都服从这个约束。</p>
<h2 id="条款十：今operator-返回一个reference-to-this"><a href="#条款十：今operator-返回一个reference-to-this" class="headerlink" title="条款十：今operator= 返回一个reference to * this"></a>条款十：今operator= 返回一个reference to * this</h2><p>&emsp;&emsp;为了实现连续赋值，赋值操作符必须返回一个reference指向操作符的左侧实参;其标准的赋值形式，同样也适用于所有的赋值相关的运算，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条款十一：在operator-中处理”自我赋值”"><a href="#条款十一：在operator-中处理”自我赋值”" class="headerlink" title="条款十一：在operator= 中处理”自我赋值”"></a>条款十一：在operator= 中处理”自我赋值”</h2><p>&emsp;&emsp;自我赋值的存在，会在你不注意时引诱你进入一个”在停止使用资源之前意外释放了它”的陷阱。我们以下面代码为例，进行一个理解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		Bitmap *pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">	<span class="keyword">delete</span> pb;</span><br><span class="line">	pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; * this与rhd可能是同一个对象。那么不仅删除了当前对象的bitmap，也删除了rhs的bitmap。那么最后 * this 发现自己指向一个已被删除的对象。<br>&emsp;&emsp;为了阻止这种错误，我们可以在这个最前面添加一个”证同测试”,达到检测的目的。具体如这条语句所示：</code>if (this == &amp;rhs) return * this;</code>。由于证同测试使用次数较低，因此，我们使用<code>copy and swap</code>技术。其实现手法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>; <span class="comment">// 交换*this与rhs数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">	Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">	<span class="built_in">swap</span>(temp);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条款十二：-复制对象时勿忘其每一个成分"><a href="#条款十二：-复制对象时勿忘其每一个成分" class="headerlink" title="条款十二： 复制对象时勿忘其每一个成分"></a>条款十二： 复制对象时勿忘其每一个成分</h2><p>&emsp;&emsp;如果为class添加一个成员变量，你必须同时修改copying函数,同时也需要修改class中的构造函数。<br>&emsp;&emsp;我们在编写一个copying函数，我们就需要确保:1、复制所有local 成员变量，2、调用所有base classes内的适当的copying 函数。由于大量的copying函数几近相似，有人为了避免代码的重复，就会在一个copying 函数中调用另一个copying函数，这样可能还是无法达到你的目标。对于copy assignment操作符调用copying 函数以及它的反调用，都是不合理且没有意义的。这里最好的办法就是，新建一个成员函数供两者调用，这样就可以安全消除代码的重复问题了。</p>
]]></content>
      <categories>
        <category>Read Notes</category>
      </categories>
      <tags>
        <tag>theory</tag>
      </tags>
  </entry>
  <entry>
    <title>Inside the C++ Object Model reading note</title>
    <url>/2021/Inside_of_C++_model/</url>
    <content><![CDATA[<p><font color="blue">蓝色:概念、讨论主题</font><br><u>下划线：值得注意的内容</u><br><font color="fuchsia">紫红色：比较重要的地方</font><br><font color="red">红色：必须理解的地方</font></p>
<h2 id="第一章-关于对象"><a href="#第一章-关于对象" class="headerlink" title="第一章 关于对象"></a><center>第一章 关于对象</center></h2><p>介绍了C++ 如何在背后实现一个对象，内存中的布局以及空间上的关系</p>
<ol>
<li>C++ 中以类对数据进行封装后，布局成本是否会增加？</li>
</ol>
<ul>
<li>一般来说，并不会增加成本。每个data member直接内含在每一个class object中，就像C struct的情况一样。而member funcitons虽然含在class声明中，却不出现在object中。<font color="purple">所以类的封装并不会增加布局成本</font></li>
</ul>
<ol start="2">
<li><font color="red">C++在布局以及存取时间上主要的额外负担是由virtual引起的</font>，包括：</li>
</ol>
<ul>
<li><strong>virtual funcitons机制</strong>:每一个class有一个virtual table内含class之中有作用的virtual funcitons地址，每个object有一个vptr指向virtual table所在</li>
<li><strong>virtual base class</strong>: 用以实现 “多次出现在继承体系中的base class有一个单一而被共享的实例”</li>
</ul>
<ol start="3">
<li><u>C++ 布局成本的主要来源就是virtual机制</u></li>
<li><font color="red">C++对象模型(The C++ Object Model)</font><br><img data-src="https://7894651.xyz/model/pic.png" alt="avatar"></li>
</ol>
<ul>
<li>non-static data members被配置于每一个class object之内</li>
<li>static data members则被存放在所有class object之外</li>
<li>static/non-static funciton members也被放在所有class object之外</li>
</ul>
<ol start="5">
<li><font color="blue">virtual funciton 机制由以下两个步骤来支持</font>：</li>
</ol>
<ul>
<li>每一个class产生出一系列<font color="blue">virtual funciton的指针,放在一个被称为virtual table(vtbl,vtable</font>的表格中;</li>
<li>每一个class object被添加一个<font color="blue">vptr指向相应的vtable</font>,vptr的设置由编译器全权负责，程序员无须关心</li>
</ul>
<ol start="6">
<li><font color="blue">RTTI</font> : 一般来说，每一个class相关联的type_info object通常也保存在vtable的第一个slot中</li>
<li>需要清楚明白的一个概念: <u>一个vtbl对应一个class,一个vptr对应一个class object</u></li>
<li><font color="blue">引入继承后对象模型成本</font>:</li>
</ol>
<ul>
<li>普通继承 : 父对象被直接包含在子对象中,这样对父对象的存取也是直接的,没有额外成本;</li>
<li>虚拟继承 : 父对象会由一个指针指出来，这样对于父对象的存取就多了一层间接性,必须由一个指针来访问，这样就添加了一次间接的额外成本</li>
</ul>
<ol start="9">
<li><font color="blue">C++优先判断一个语句为声明</font> : 当语言无法区分一个语句是声明还是表达式时，就需要用一个超越语言范围的规则——C++优先判断为声明</li>
<li><font color="blue">struct和class关键字的意义</font> :</li>
</ol>
<ul>
<li>它们之间并无本质区别,<u>更多的是概念和编程思想上的区别</u>。</li>
<li>struct 用来表现那些只有数据的集合体POD(Plain OI’ Data)、而class则希望表达的是ADT(abstract data type)的思想;</li>
<li>两个关键字本质是无区别的,所以class并没有必须引入,但是引入它的确非常令人满意，因为这个语言所引入的不止是这个关键字,还有它所支持的封装和继承的哲学;</li>
<li>struct方便C程序员迁移到C++</li>
</ul>
<ol start="11">
<li><font color="fuchsia">C++只保证处于同一个access section 的数据,一定以声明的次序出现在内存布局当中</font>。</li>
<li><font color="blue">与C兼容的内存布局</font> : <u>组合,而非继承,才是把C的C++结合在一起的<strong>唯一可行</strong>的方法</u></li>
</ol>
<ul>
<li>只有使用组合时,才能保证C拥有相同的内存布局,使用继承的内存布局是不受C++ standard 所保证的</li>
</ul>
<ol start="13">
<li><font color="blue">C++ 支持三种形式的编译风格(programming paradigm)</font> : </li>
</ol>
<ul>
<li><font color="blue">面向过程的风格</font> : 就像C一样, 一条语句接一条语句的执行或者函数跳转;</li>
<li><font color="blue"><strong>基于对象</strong>的风格(object-based)</font> (或称ADT) : <u>仅仅使用了class封装</u>,很多人都是在用基于对象的风格却误以为自己在使用面向对象的风格;</li>
<li><font color="blue"><strong>面向对象</strong>的风格(object-oriented)</font> : <u>使用了class的封装和多态</u>的编程思维(多态才是真正的面向对象的特征)。</li>
<li>纯粹以一种paradigm写程序,有助于整体行为的良好稳固。</li>
</ul>
<ol start="14">
<li>C++ 支持多态的方法 : </li>
</ol>
<ul>
<li>经由一组隐式的转化操作,例如把derived class 指针转化为一个指向其public base type 的指针: <code> shape *ps = new circle() </code></li>
<li>经由 virtual function 机制 : ps-&gt;test();</li>
<li>经由 dynamic_cast 和 typeid 运算符 : if (circle *pc = dynamic_cast&lt;circle *&gt; (ps)) ….</li>
</ul>
<ol start="15">
<li>一个reference通常是以一个指针实现的，所以point和reference并没有本质的区别。</li>
<li><font color="blue">一个对象的内存布局大小(通常由3部分组成)</font>　:　</li>
</ol>
<ul>
<li>其nonstatic data member 的总和大小;</li>
<li>任何由于位对齐所需要的填补上云的空间;</li>
<li>加上为了支持virtual 机制而引起的额外负担。</li>
<li>这也印证了前面的一个结论 : C++中的额外成本都是由于virtual 机制所引起的。</li>
</ul>
<ol start="17">
<li>指针的类型 : </li>
</ol>
<ul>
<li>对于内存来说,不同类型的指针并没有什么不同。它们都是占用一个word的大小,包含一个数字,这个数字代表内存中的整体上地址;</li>
<li>感觉上,指针的类型是编译器的概念,对于硬件来,并没有什么指针类型的概念;</li>
<li>转型操作也只是一种编译器的指令,它改变的内是编译器对被内存的解释方式而已！</li>
</ul>
<ol start="18">
<li><font color="blue"> 多态只能由”指针”或”引用”来实现,根本原因在于 </font> : </li>
</ol>
<ul>
<li><u>指针的引用(通常以指针来实现)的大小是固定的(一个word),而对象的大小却是可变的</u>。其类的指针和引用可以指向(或引用)子类,但是基类的对象也只能是基类，没有变化不可能引发多态。</li>
<li>一个point或reference绝不会引发任何”与类型有关的内存委托操作”,<u>在指针类型转换时会受到的改变的只有它们所指向内存的解释方式而已</u>。(例如指针绝不会引发slice,因为它们大小相同)</li>
</ul>
<ol start="19">
<li><u>在初始化、assignment等操作,编译器会保证对象的vptrs得到正确的设置。这是编译器的职责</u>。一般都是通过在各种操作中插入编译器的代码来实现的。</li>
</ol>
<h2 id="第二章-构造函数语意学"><a href="#第二章-构造函数语意学" class="headerlink" title=" 第二章 构造函数语意学 "></a><center> 第二章 构造函数语意学 </center></h2><p>详细的讨论了constructor如何工作,讨论构造一个对象的过程以及构造一个对象给程序带来的影响。</p>
<ol>
<li>C++中对于默认构造函数的解释为: <font color="red">默认的构造函数会在需要的时候被编译器产生出来</font>。</li>
</ol>
<ul>
<li><font color="fuchsia">这里非常重要的一点是: 谁需要? 是<strong>程序的需要</strong>还是<strong>编译器的需要</strong> </font>？<ul>
<li><u>如果是程序的需要,那是程序员的责任;只有在是编译器的需要时,默认构造函数才会被编译器产生出来,而且被产生出来的默认构造函数只会执行编译器所需要的行动，而且这个产生操作只有在默认构造函数真正被调用时才会</u></li>
<li>例如成员变量初始化为0操作，这个操作是程序和需要,而不是编译器的需要。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><font color="blue"> 区分trivial 和 notrivial </font> : </li>
</ol>
<ul>
<li>只有编译器需要的时候,合成操作才是notrivial的, 这样的函数才会被真正的合成出来;</li>
<li><u>如果编译器不需要，而程序员又没有提供,这时的默认构造函数就是trivial的。虽然它在概念上存在，但是编译器实际上根本不会去合成出来</u>,因为他不做任何有意义的事情,所以当然可以忽略它不去合成。trivial的函数只存在于概念上，实际上不存在这个函数。</li>
</ul>
<ol start="3">
<li><font color="red"> 总结变量的初始化 : 只有全局变量和静态变量才会保证初始化</font>,其中静态变量可以视为全局变量的一种,因它静态变量也是保存在优变量的存储空间上的。</li>
</ol>
<ul>
<li>Golbal objects 的内存保证会在程序激活的时候被清0;Local objects 配置于程序的堆栈中, Heap objects 配置于自由空间中,都不一定会被清0,它们的内容将是内存上次被使用后的痕迹</li>
</ul>
<ol start="4">
<li>类声明头文件可以被许多源文件所包含,如何避免合成默认构造函数、拷贝构造函数、析构函数、赋值拷贝操作符(4大成员函数)时不引起函数的重定义?</li>
</ol>
<ul>
<li>解决方法是以inline的方式完成,如果函数太复杂不适合inline,就会合成一个excplicit non-inline static实体(static 函数独立于编译单元)</li>
</ul>
<ol start="5">
<li>如果class A内含一个或以上的member objects，那么A的constructor必须调用每一个member class的默认构造函数。</li>
</ol>
<ul>
<li>具体方法是 : <u>编译器会扩张constructor,在其中安插代码使得在user code被调用之前先调用member objects 的默认构造函数(当然如果需要调用基类的默认构造函数,则放在基类的默认构造函数调用之后:基类构造函数-&gt;成员构造函数-&gt;user code)</u>。</li>
<li>C++ 要求以”member objects 在 class 中的声明次序”来调用各个constructors。这就是<font color="fuchsia">声明的次序决定了初始化次序</font>(构造函数初始化列表一直要求以声明顺序来初始化)的根本原因!</li>
</ul>
<ol start="6">
<li>带有virtual funcitons 的类的默认构造函数毫无疑问是nontrivial的,需要编译器安插额外的成员vptr并在构造函数中正确设置vptr,这是编译器的重要职责之一。</li>
</ol>
<ul>
<li>带有virtual base class 的类的默认构造函数同样也是毫无疑问的nonstatic的,编译器需要正确设置相关的信息以僵持这些virtual base class 的信息能够在执行时准妥当,这些设置取决于实现虚基类的手法。</li>
</ul>
<ol start="7">
<li>编译器有4种情况会使得编译器真正为class生成nontrivial的默认构造函数,这个<u>nontrivial的默认构造函数只满足编译器的需要(调用member objects 或base class 的默认构造函数、初始化virtual funciton 或 virtual base class 机制)</u>。其它情况时,类在概念上拥有默认构造函数,但是实际根本不会被产生出来(前面的区分)</li>
<li><font color="red">C++新手常见的两个误区</font></li>
</ol>
<ul>
<li><u>ERROR : 如果class 没有定义default constructor 就会合成一个</u>;<ul>
<li>首先定义了其它constructor就不会合成默认构造函数,其次即使没有定义任何函数也不一定会合成default constructor,可能仅仅是概念上有, 但实际上不合成出来。</li>
</ul>
</li>
<li><u>ERROR : 编译器合成出来的默认构造函数会明确设定一个data member 的默认值;</u><ul>
<li>明显不会,区分了Golbal objects,stack objects,Heap objects 就非常明白了只有在Golbal 上的objects会被清0,其它的情况不会保证被清0。</li>
</ul>
</li>
</ul>
<ol start="9">
<li>Copy constructor 和默认构造函数来说,只有在必须的时候才会被产生出来,对于大部分的class 来说,拷贝构造函数仅仅需要按位拷贝就可以。<u>满足<font color="blue">bitwise copy semantics</font>的拷贝构造函数是trivial的，就不会真正被合成出来(与默认构造函数,只有nontrivial的拷贝构造函数才会被真正合成出来)</u>。</li>
</ol>
<ul>
<li>对于大多数类按位拷贝就够了,什么时候一个class 不展现bitwise copy semantics呢? 有以下四种情况<ul>
<li>class内含一个member object而后者声明了(或者是由于nontrivial而被合成出来的)一个copy constructor时;</li>
<li>当class 继承自一个base class 而后者存在一个copy constructor时(不论显示定义或是合成而得的)</li>
<li>当class 声明了一个或多个virtual funcitons时; (vf 影响了位语意,进而影响了效率)</li>
<li>当class 派生自一个继承串链,其中一个或多个virtual base classes时。</li>
</ul>
</li>
</ul>
<ol start="10">
<li><font color="blue">NVR优化</font> : 编译器会把返回值作为一个参数传到函数内,比如:</li>
</ol>
<ul>
<li><code>X foo() &#123;...&#125;</code> 会被更改(也可以手动做这个优化)为 : <code>void foo(X & result) &#123;...&#125;</code>;</li>
<li>从使用者角度，用<code>return X(...)</code>代替 <code>X x;return x;</code>能够辅助这个优化操作。</li>
</ul>
<ol start="11">
<li><font color="blue">不要随意提供copy constructor</font>,<u>对于满足bitwise copy constructor的类来说,编译器自动生成的拷贝构造函数自动地使用了位拷贝(这是效率最高的)</u>,如果你自己随意提供copy constructor就会压抑掉编译器的这个行为,这还会影响效率。</li>
<li><font color="blue">成员初始化列表</font> : 在成员初始化列表背后发现的事情是什么?</li>
</ol>
<ul>
<li>编译器会一一操作初始化列表,把其中<font color="red">初始化操作以member声明的次序</font>在constructor内安插初始化,并且在任何excplicit user code 之前。</li>
<li><u>“以member声明的次序来决定初始化次序”和”初始化列表中的排列次序”之间的<font color="red">外观错乱</font></u>,可能会导致一些不明显的Bug</li>
<li>不过GCC已经强制要求使用声明次序来进行初始化以避免这个陷阱。</li>
</ul>
<ol start="13">
<li>理解了初始化列表中的实际执行顺序中”以member声明的次序”来决定的,就可以理解一些很微妙的错误。比如:</li>
</ol>
<ul>
<li><code>A() : i(99),j(66),value(foo()) &#123;...&#125;</code></li>
<li>int i, int j;</li>
<li>这会不会产生错误取决于成员函数foo()是依赖i还是j;</li>
<li>如果foo依赖于i,由于i声明在value之前,所以不会产生错误；</li>
<li>如果foo依赖于j,由于j声明在value之后,就产生了使用未初始化成员的错误。</li>
</ul>
<h2 id="第三章-Data语意学"><a href="#第三章-Data语意学" class="headerlink" title="第三章 Data语意学 "></a><center>第三章 Data语意学 </center></h2><p>C++ 对象模型的细节,讨论data member的处理。</p>
<ol>
<li><u>空类也有1Byte的大小,因为这样才能使得这个class 的2个objects在内存中有独一无二的地址</u>。</li>
<li><font color="blue">一个对象内存布局大小(通常由3外部分组成)</font></li>
</ol>
<ul>
<li>其nonstatic data member的总和大小;</li>
<li>任何由于位对齐所需要的填补上去的大小;</li>
<li>加上为了支持virtual机制而引起的额外负担;</li>
</ul>
<ol start="3">
<li>对member functions本身的分析会直到整个class 的声明都出现才开始。所以class的member funcitons可以引用声明在后面的成员,C语言就做不到。</li>
<li>和第3条对比，需要十分注意的一点是 : <font color="fuchsia">class 中的typedef并不具备这个性质</font>。</li>
</ol>
<ul>
<li><u>因此，类中的typedef影响会受到函数与typedef的先后顺序的影响</u>。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int length;</span><br><span class="line">class Point3d &#123;</span><br><span class="line">  public:</span><br><span class="line">    void f1(length l) &#123;cout &lt;&lt; l &lt;&lt; endl; &#125;</span><br><span class="line">    typedef string length;</span><br><span class="line">    void f2(length l) &#123; cout &lt;&lt; l &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这样f1绑定的length类型是int;而f2绑定的length类型才是string。</li>
<li><font color="fuchsia">所以，对于typedef需要防御性的风格: 始终把nested type声明(即typedef)放在class起始处！</font></li>
</ul>
<ol start="5">
<li>传统上,vptr被安放在所有被明确声明的member的最后,不过也有些编译器把vptr放在最前面(MSVC++ 就是把vptr放在最前面，而GCC是把vptr放在最后面).</li>
<li>在C++中，直观上来说,由一个对象存取一个member会比由一个指针存取一个member更快捷。但是对于经由一个对象来存取和一个指针来存取一个静态的member来说，是完全一样的，都会被编译器所扩展。</li>
<li>经由一个函数调用的结果来存取静态成员，C++标准要求必须对这个函数进行求值，虽然这个求值的结果并无用处,例如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foobar().static_data &#x3D; 10;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>foo()返回一个类型为X的对象，含有一个static_data，foobar()其实可以不用求值而直接访问这个静态成员，但是C++标准保证了foobar()会被求值，可能的代码扩展为:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(void) foobar();</span><br><span class="line">X::static_data &#x3D; 10;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="8">
<li>对一个nonstatic data member 进行存取操作,编译器会进行如下扩展:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origin._y &#x3D; 0.0;</span><br><span class="line"></span><br><span class="line">那么地址&amp;origin._y将等于:</span><br><span class="line"></span><br><span class="line">＆origin + (&amp;X::_y - 1);</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>注意其中的-1的操作，指向data member 的指针，其offset 值总是被加上1，这桩可以2使编译器系统区分”一个指针data member 的指针，用以指向class的第一个member”和”一个指向data member的指针,但是没有指向任何member”两种情况(<i>成员指针也需要有个表示NULL的方式，0相当于用来表示NULL了，其它的就都要加上1了</i>)。</li>
</ul>
<ol start="9">
<li>以下这两种写法有什么区别？<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X x; x.x &#x3D; 0.0;</span><br><span class="line"></span><br><span class="line">*px &#x3D; &amp;x; px-&gt;x &#x3D; 0.0;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>答案是:<u>X是一个派生类，而其继承结构有一个虚基类，且x成员又是蜡烛基类中的成员，这两种写法在编译器眼中就有巨大区别了</u>因为我们不能明确的说pt必然指向哪一个class type,故我们也就不知道编译时期member 真正的offset位置，存取操作只能延时到执行期。对于x来说类型固定，所以member的offset位置也在编译时期就确定了。</li>
</ul>
<ol start="10">
<li>派生类的成员和基类的排序并未在C++ standard中强制指定；理论止编译器可以自由安排，<u>但是对于大部分编译器实现来说，都是把基类成员放在前面，但是virtual base class 除外。(一般而言，任何一条规则一旦碰到virtual base class 就没辙了)</u>。</li>
<li><font color="red">C++ standard中保证： 出现在派生类中的base class subobject有其完整原样性！</font></li>
</ol>
<ul>
<li>子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节也是父类的一部分，也是不可分割的。</li>
</ul>
<ol start="12">
<li><font color="blue">支持多态所带来的4个负担</font>：</li>
</ol>
<ul>
<li>导入virtual table 用来存放每一个virtual funcitons的地址。这个Table 的元素数目一般而言是被声明的virtual funcitons数目再加上一个或两个slots(用心支持RTTI)；</li>
<li>在每一个class object 中安插一个vptr指向相应vtable;</li>
<li>在constructor 中安插代码以正确设置vptr，让它指定class 所对应的virtual table;</li>
<li>在deconstructor 中安插代码以正确设置vptr，使它能够抹消”指向class 之相关virtual table”的vptr；</li>
</ul>
<ol start="13">
<li><font color="blue"><strong>单一继承</strong>并<strong>含有虚拟函数</strong>时的内存布局</font>(考虑把vptr放在尾部的情况)<br><img data-src="https://7894651.xyz/model/pic1.png" alt="avatar"></li>
</ol>
<ul>
<li><u>单一继承时vptr被放在第一个子类的末尾，产生这样的布局的原因在于”<strong>基类的完整性必须在子类中得以保存</strong>“</u>。</li>
<li>对于第一个__vptr__Point2d的vptr可以这样理解，由Point2d而引发的vptr，在Point2d的对象中，这个__vptr__Point2d所指向的是与Point2d所指向的是与Point2d所对应的point2d_vtable,而在Point3d的对象中，这个__vptr__Point2d所指向的却是与Point3d所对应的point3d_vtable.</li>
</ul>
<ol start="14">
<li><font color="blue">多重集成时的布局</font>(多重继承时的主要问题在于派生类与非第一基类之间的转换)：<br><img data-src="https://7894651.xyz/model/pic2.png" alt="avatar"></li>
</ol>
<ul>
<li>在多重继承的派生体系中，将派生类的地址转换为第一基类是成本与单继承是相同的，只需要修改地址的解释方式而已；而对于转换为第一基类的情况，则需要对地址进行一定的offset操作才可以。</li>
<li><u>C++ standard 并未明确base classes 的特定排列次序，但是目前的编译器都是按照声明的次序来安放他们的。</u>(有一个优化:如果第一基类没有vtable而后继基类有，则可能把它们调换位置).</li>
<li>多重继承中，可能会有多个vptr指针，视其继承体系而定:<font color="fuchsia">派生类中的ptr的数目等于所有基类的vptr数目的总和</font>。</li>
</ul>
<ol start="15">
<li><font color="blue">虚拟继承:<u>虚拟继承就是把一个类切割成两个部分：一个不变局域和一个共享局部。</u></font></li>
</ol>
<ul>
<li>这个共享局部必须通过编译器安插的一些指针指向virtual base class object 来间接的存取，这样才能够实现共享。对于这个安插指针来实现共享的技术，有两种主流的做法：<ul>
<li>一种做法就是直接使用一个指针指向虚基类:<br><img data-src="https://7894651.xyz/model/pic3.png" alt="avatar"></li>
<li>另一种做法就是在vtable 中放置virtual base class的offset:<br><img data-src="https://7894651.xyz/model/pic4.png" alt="avatar"><ul>
<li><u>这种使用偏移地址的方式好处在于:vptr是已经存在的成本，而vtable是class的所有objects所共享的成本。对于每一个class object没有引入任何的额外成本，仅仅在vtable多存储了一个slot布局，而前一种方式却对每一个object都引入了两个指针的巨大成本。</u></li>
<li>这两种方式教师把虚基类放在内存模型中的最后面，然后借由一层间接性(指针或offset)来访问。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="16">
<li>一般而言：<u>virtual base class 最有效的一种运用形式就是：一个抽象virtual base class ，没有任何data members</u>。</li>
<li>普通封装不会带来任何执行期的成本，编译器可以轻松优化掉普通封装带来的任何成本。</li>
</ol>
<ul>
<li>但是一旦涉及到虚拟继承，效率就会大幅降低，在有n层的虚拟继承体系中，普通的访问就要经过n次间接，普通访问的成本就变为了n倍。</li>
<li>再次表示，C++中的额外成本基本都是由于virtual 机制引起的。</li>
</ul>
<ol start="18">
<li>指向Data Members 的指针内部实际保存的是这个data member 相对于对象起始地址的偏移地址(offset)(但需要另外加1以区分空指针，前面有讲过了)</li>
<li>使用指向Data Members的指针时也不会损失效率，成本与直接存取相同。就像第17条所说的，普通访问没有额外成本，但是遇到虚拟继承效率就大幅降低。</li>
</ol>
<h2 id="第四章-Function语意学"><a href="#第四章-Function语意学" class="headerlink" title="第四章 Function语意学 "></a><center>第四章 Function语意学 </center></h2><p>C++对象模型的细节，讨论了member funcitons,尤其是virtual funciton。</p>
<ol>
<li>C++的设计准则之一就是：<u>nonstatic member funciton 至少必须一般的nonmember funciton 有相同的效率</u>。</li>
</ol>
<ul>
<li>实际上，nonstatic member funciton 会被编译器进行如下的转换，变成一个普通函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; non-const nonstatic member</span><br><span class="line">Type1 X::foo(Type2 arg1) &#123;....&#125; </span><br></pre></td></tr></table></figure></li>
<li>会被转换为如下普通函数(可能的内部转换结果):<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++伪码</span><br><span class="line">void foo(X* const this,Type1&amp; _result，Type2 arg1) &#123;....&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>如何确定函数是否为non-static?</li>
</ol>
<ul>
<li>它是否可以直接存取nonstatic数据。</li>
<li>看这个函数是否被声明为const。</li>
</ul>
<ol start="3">
<li>实际上，<strong>普通函数，普通成员函数，静态成员函数到最后才会变成与C语言类似的普通函数</strong>，只是编译器在这些不同类型的函数身上做了不同的扩展，并放在不同的scope里面而已。</li>
<li><font color="blue">虚拟成员函数:ptr-&gt;normalize();</font></li>
</ol>
<ul>
<li>会被内部转化为: ( * ptr-&gt;vptr[1]) (ptr);</li>
<li>事实上vptr的名称也会被”mangled”(名称切割重组)，因为对于一个复杂的派生体系，可能会有多个vptr。前面总结过了，一个派生类中的vptr数目等于其基类的总和。</li>
</ul>
<ol start="5">
<li>static member funciton 主要特性：</li>
</ol>
<ul>
<li>不能直接存取其class 中的nonstatic members.</li>
<li>不能被声明为const、volatile或virtual.</li>
<li>不需要经由class object 才被调用，虽然大部分时候都是这样使用的。</li>
</ul>
<ol start="6">
<li>静态成员函数其实就是带有类scope的普通函数，它也没有this指针，所以它的地址类型并还是一个指向成员的指针而仅仅是一个普通的函数指针而已。 </li>
</ol>
<ul>
<li>静态成员函数是作为一个callback的理想对象，要类的scope内，又是普通的函数指针。</li>
</ul>
<ol start="7">
<li>识别一个classs是否支持多态，唯一的适当的方法就是看它是否有任何的virtual funciton。只有class声明有任意一个virtual funciton，那么它就需要额外的执行期信息vtable.</li>
<li>对于单一继承的情况，每个类最多只会有一个vptr指针，并放在第一个拥有virtual function 的类的后面(父类必须保证对象的完整性)。</li>
</ol>
<ul>
<li>在单一继承的内存布局下，virtual function是如何工作的呢？因为在调用一个成员函数ptr-&gt;z()时；<ul>
<li>虽然不能确定ptr直接指向的类型，但是可以经由ptr找到它的vtable，而vtable记录了所指对象的真正类型(一般对象的type_info 放在vtable的第一个slot中)</li>
<li>虽然不能确定应该调用的z函数的真正地址，但是可以知道vtable中被放在哪一个slot，于是就直接去vtalbe中相应的slot中取出真正的函数地址加以调用。<br><img data-src="https://7894651.xyz/model/pic5.png" alt="avatar"></li>
</ul>
</li>
</ul>
<ol start="9">
<li><font color="blue">多重继承下的内存布局</font>:</li>
</ol>
<ul>
<li><u>要多重继承中比单一继承更复杂的地方在于对大是大非第一基类的指针和引用进行操作时，必须进行一些执行期的调整this指针的操作。</u></li>
<li>比如对于简单的delete 操作：delete base2；由于base2可能没有指向对象的起始地址，这样简单的删除操作都会引发巨大灾难，所以需要对base2做执行期的调整才能正确的delete对象。</li>
<li>在多重继承下，一个derived class 可能同时含有多个vptrs指针，这取决于它的所有基类的情况(基类完整性定义)。也可能有对应的多个vtables(如cfront)，但也可能无论如何只有一个vtable(把所有的vtables合成一个，并使得所有的vptrs都指向这一个合成的vtable+offset，如Sum的编译器)，这些都取决于编译器的策略。</li>
<li>有三种情况，非第一基类会影响对虚函数的支持：<ul>
<li>通过一个指向非”第一base class”的指针，调用derived class virtual function。<u>最后为了能够正确执行，ptr必须调整指向derived对象起始处。</u><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Base2 *ptr&#x3D;new Derived;</span><br><span class="line">&#x2F;&#x2F;调用Derived::~Derived()</span><br><span class="line">&#x2F;&#x2F;ptr必须向后调整sizeof(Base1)个byte</span><br><span class="line">&#x2F;&#x2F;因为非第一base class的地址指定操作，需要加上或减去介于中间的base class subobject(s)的大小</span><br><span class="line">delete ptr;</span><br></pre></td></tr></table></figure></li>
<li>这种情况是第一种情况的变形，通过一个”指向derived class“的指针，调用第二个base class中的一个继承而来的virtual function。<u>最终derived class 指针必须再次调整，经指向第二个base subobjec最终derived class 指针必须再次调整，经指向第二个base subobject。</u><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Derived *pder&#x3D;new Derived;</span><br><span class="line">&#x2F;&#x2F;调用Base2::mumble()</span><br><span class="line">&#x2F;&#x2F;pder必须向前调整sizeof(Base1)个byte</span><br><span class="line">pder-&gt;mumble();</span><br></pre></td></tr></table></figure></li>
<li>第三种情况发生在一个语言扩充性质下，允许一个虚函数的返回值类型有所变化，可能是base type,也可能是publicly derived type。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Base2 *pb1&#x3D;new Derived;</span><br><span class="line">&#x2F;&#x2F;调用Derived * Derived::clone()</span><br><span class="line">&#x2F;&#x2F;返回值必须调整。以指向Base2 对象</span><br><span class="line">Base2 *pb2&#x3D;pb1-&gt;clone;</span><br></pre></td></tr></table></figure>
<img data-src="https://7894651.xyz/model/pic6.png" alt="avatar"></li>
</ul>
</li>
</ul>
<ol start="10">
<li>虚拟继承下的内存布局：<br><img data-src="https://7894651.xyz/model/pic7.png" alt="avatar"></li>
</ol>
<ul>
<li><font color="fuchsia">Lippman建议：不要在一个virtual base class中声明nonstatic data members。如果一定要这么做，那么你会距离复杂的深渊愈来愈近，终不可拔。</font></li>
</ul>
<ol start="11">
<li>这里的<u>函数性能测试表明，inline函数的性能如此之高，比其它类型的函数高的不是一个等级。</u>因为inline函数不只能够节省一般函数调用所带来的额外负担，也给编译器提供了程序优化的额外机会。</li>
<li>取一个nonstatic member function 的地址，如果该函数是nontrivial,则得到的结果是它在内存中的真正地址。然而这个值是不完全的，它需要被绑定于某个class object的地址上，才能够通过它调用该函数。</li>
<li><font color="blue">指向virtual member funcitons的指针</font>：</li>
</ol>
<ul>
<li><u>对于一个virtual member function取其地址，所能获得的只是一个vtable的索引值</u></li>
</ul>
<ol start="14">
<li>inline函数扩展时的实际参数取代形式参数的过程，会聪明地引入临时变量来避免重复求值。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设函数：</span><br><span class="line">  inline int min(int i,int j) </span><br><span class="line">  &#123;</span><br><span class="line">    return i &lt; j ? i : j;</span><br><span class="line">  &#125;</span><br><span class="line">三种调用方式：</span><br><span class="line">  int minval;</span><br><span class="line">  int val1 &#x3D; 1024;</span><br><span class="line">  int val2 &#x3D; 2048;</span><br><span class="line"></span><br><span class="line">  minval &#x3D; min(val1,val2); &#x2F;&#x2F;方式一</span><br><span class="line">  minval &#x3D; min(1024,2048); &#x2F;&#x2F;方式二</span><br><span class="line">  minval &#x3D; min(foo(),bar()+1) &#x2F;&#x2F;方式三</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>方式一，由于是参数，所以可以直接代换</li>
<li>方式二，由于是常数，所以可能直接拥抱常量</li>
<li>方式三，会引发参数副作用，所以需要引入一个临时变量，用以避免重复求值。</li>
</ul>
<ol start="15">
<li>inline 中再调用inline函数，可能使得表面上一个看起来很平凡的inline却因连锁的复杂性而没有办法扩展开来。</li>
</ol>
<ul>
<li>对于既要安全又要效率的程序，inline函数提供了一个强而有力的工具，然后与non-inline函数比起来，它们需要更加小心处理。</li>
</ul>
<h2 id="第五章-构造、解构、拷贝语意学"><a href="#第五章-构造、解构、拷贝语意学" class="headerlink" title="第五章 构造、解构、拷贝语意学 "></a><center>第五章 构造、解构、拷贝语意学 </center></h2><p>C++对象模型的细节，讨论了class 的整个模型，一个对象的完整生命周期</p>
<ol>
<li><font color="blue">纯虚函数志可以被调用</font>，方式如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    virtual ~A() &#123;&#125;</span><br><span class="line">    virtual void f() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;纯虚函数必须定义在类声明之外</span><br><span class="line">void A::f() &#123;std::cout &lt;&lt; &quot;pure virtual&quot; &lt;&lt; std::endl;&#125; </span><br><span class="line"></span><br><span class="line">class D : public A</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    &#x2F;&#x2F;纯虚函数必须经由派生类显式的要求调用</span><br><span class="line">    virtual void f() &#123;A::f(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  D d;</span><br><span class="line">  d.f();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>输出结果为”pure virtual”,这里需要注意几点：</li>
<li>纯虚函数不能在类的声明中提供实现，只能在类声明的外部来提供默认的实现；</li>
<li>基类的纯函数的默认实现必须由派生类显式的要求调用；</li>
<li>派生类不会自动继承这个纯虚函数的定义，如果派生类D未定义f()，那么A依然是一个抽象类型；</li>
<li>这种pure virtual function 实现的方案比较好的应用场景为：基类提供了一个默认的实现，但是不希望自动的继承给派生类作用，除非派生类明确的要求。</li>
<li>仍需要注意这个纯函数为析构函数的情况。C++语言保证继承体系中的每一个class object 的 deconstructor 都会被调用。所以编译器一定会扩展派生类的析构函数去显式地调用基类的原构函数。</li>
<li><u>另外一个重要的应用场景：有些情况下会把析构函数声明为纯虚。这时，必须为纯虚析构函数提供一个默认的实现。</u>否则，派生类的析构函数由于编译器的扩展而显式的调用基类的原构函数时会找不到定义。同时编译器也无法为已经声明为纯虚的析构函数生成一个默认的实现。</li>
</ul>
<ol start="2">
<li>虚函数中的const 哲学： 一个虚函数该不该被定义为const呢？</li>
</ol>
<ul>
<li>一个虚函数在基类中不需要修改data member 并不意味着派生类改写它时一定不会修改data member.</li>
<li><font color="fuchsia">所以除非有十足的把握，一般就不声明为const</font>。</li>
</ul>
<ol start="3">
<li>Lippman 认为把所有的函数都声明为virtual function,然后再靠编译器的优化操作把大是大非必须的virtual invocation 去除，并还是好的设计观念。不过，Java和.NET很可能都是这么干的。</li>
<li>对象能从三个地方产生出来：Global内存、Local内存、Heap内存。</li>
<li><font color="blue">观念上，编译器会为每一个类产生4个函数</font></li>
</ol>
<ul>
<li>trivial default constructor,trivial deconstructor,trivial copy constructor,trivial copy assignment operator</li>
<li>但是这仅仅是观念上的，trivial的函数不会被真正的产生出来。</li>
</ul>
<ol start="6">
<li>C和C++的又一个不同点，就是<font color="blue">C语言的临时性定义</font></li>
</ol>
<ul>
<li>就像书上的Point global;这样的定义：</li>
<li>在C中会被视为一个”临时性定义”，可以在程序中出现多次，这些实例最后会被链接器折叠起来，最终留下一个实体</li>
<li>在C++中会被视为一个”完全定义”,所以只能出现一次，要想实现C一样的临时性语意，C++中必须把它声明为extern，即:exern Point global;</li>
</ul>
<ol start="7">
<li>写法差异:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A *pa1 &#x3D; new A;</span><br><span class="line">A *pa2 &#x3D; new A();</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>这两种写法是存在一定差异</li>
<li>对于内置类型：加括号会初始化，不加括号不初始化</li>
<li>对于自定义类型：都会调用默认构造函数，所以加不加括号没什么区别。</li>
</ul>
<ol start="8">
<li>对于<font color="blue">可以视为POD的class</font>(没有声明构造函数、没有virtual等等)，就可以使用<font color="blue">POD结构特有的initialization list进行初始化</font>。</li>
</ol>
<ul>
<li>Point p={2,3} ，在C++11中的initialization list 被大量使用。</li>
</ul>
<ol start="9">
<li>引入<font color="blue">virtual function 会给对象的构造、拷贝和析构等过程带来的负担</font>如下：</li>
</ol>
<ul>
<li>constructor 必须被安插一些代码以便将vptr正确的初始化，这些代码需要被安插在任何base class constructor的调用之后，但必须在任何user code 的代码之前；</li>
<li>合成copy constructor 和copy assignment operator ,因为它们不再是trivial的了，它们必须安插代码以正确的设置vptr；</li>
</ul>
<ol start="10">
<li>C++ standard 要求尽量延迟nontrivial members 的实际合成操作，直到真正遇到其使用场合为止。</li>
<li><font color="blue">constructor 会被编译器安插大量的代码，一般而言编译器所做的扩充操作大约如下： </font></li>
</ol>
<ul>
<li>初始化成员：使用member initialization list 或者调用默认构造函数；</li>
<li>在那之前，如果class object 有vptr，它们必须被正确的设置；</li>
<li>在那之前，所有的上一层的base class constructors 必须被调用，以base classes声明的顺序。使用member initialization list 晓雾调用默认构造函数，同时如果base class是多重继承下的大是大非第1基类，还需要调整this指针；</li>
<li>在那之前，所有的virtual base class constructor 必须被调用，从左到右，从深到浅。并同时设置好virtual base class 所需要使用的各种机制；</li>
<li>处理顺序为：<font color="fuchsia">virtual base classes -&gt; base class -&gt; vptr -&gt; member </font>。</li>
</ul>
<ol start="12">
<li>赋值运算符中切记要记得进行自我检查。</li>
<li><font color="red">虚拟继承时，共享基类必须由最底层的class 负责初始化操作</font> ： </li>
</ol>
<ul>
<li>这是虚拟继承时非常重要的一点，共享基类的初始化操作必须由最底层的类来负责，中间层次的类调用这个共享类初始化的操作会被编译器所压抑掉。</li>
<li>考虑对于如下继承体系的类：编译器如何压抑非底层对共享基类的初始化操作呢？ 是通过对Point3d和Vertex的构造安插一个安插一个额外的参数( _most_derived )来解决的。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Point3d* Point3d::Point3d (Point3d *this, bool _most_derived,float x,</span><br><span class="line">                                                      float y,float z)</span><br><span class="line">&#123;</span><br><span class="line">  if (_most_derived !&#x3D; false)</span><br><span class="line">    this-&gt;Point::Point(x,y);</span><br><span class="line">  this-&gt;_vptr_Point3d &#x3D; _vtbl_Point3d;</span><br><span class="line">  this-&gt;_vptr_Point3d_Point &#x3D; _vtbl_Point3d_Point;</span><br><span class="line">  this-&gt;_z &#x3D; rhs._z;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vertex3d* Vertex3d::Vertex3d(Vertex3d *this,bool _most_derived, float x,</span><br><span class="line">                                                        float y,float z)</span><br><span class="line">&#123;</span><br><span class="line">  if (_most_derived !&#x3D; false)</span><br><span class="line">    this-&gt;Point::Point(x,y);</span><br><span class="line">  this-&gt;Point3d::Point3d(false,x,y,z);</span><br><span class="line">  this-&gt;Vertex::Vertex(false,x,y);</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当Point3d是作为最底层来构造时，_most_derived参数针被设置为true，于是Point的构造函数就会被调用；当Point3d的构造函数是被Vertex3d间接调用时，_most_derived参数会被设置为flase，于是调用Point构造函数的操作就被压抑掉了。</li>
<li>这种由最底层类来负责初始脂共享基类的手法貌似有一点不优雅，但是这却是共享基类唯一可能正确的确定初始化的地方。</li>
</ul>
<ol start="14">
<li>在构造函数中调用virtual function 是没有多态性的，因为在构造函数中，对象还不完整，派生类的部分还没有开始构造，当然不能调用它们的成员函数，否则在它们的成员函数中可能会访问还不存在的成员变量。</li>
</ol>
<ul>
<li>由于在构造函数中没有多态性，所以侧重了一种在构造函数中清0，再提供一个init()进香真正的初始化的保护性手法。</li>
</ul>
<ol start="15">
<li>要保证在构造函数中没有多态性，虚拟机制就必须知道一个调用操作是否来源于构造函数之中，变量如何实现的呢？</li>
</ol>
<ul>
<li>编译器在构造函数中安插代码时会保证:<u>行调用所有基类的构造函数，再设置vptr,然后再调用member initializaiton操作。</u>变量构造函数中没有多态性的根本原因。</li>
<li>在任何User code 和 member initializaiton被调用之前，vptr被正确的设置为了当前类的类型，于是在调用virtual function时从vtable 中取出来的函数地址就是正确的当前类的成员方法地址。</li>
</ul>
<ol start="16">
<li>一个热爱容易犯的错误：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct A : public Base &#123;</span><br><span class="line">  A() : Base(foo()) , valueA(10) &#123;&#125;</span><br><span class="line">  int foo() &#123;return valueA;&#125;</span><br><span class="line">  int valueA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>使用派生类的成员方法去初始化基类，注意在这个时候派生类还没有开始构造，调用它的成员方法的行为当然是未定义的！</li>
</ul>
<ol start="17">
<li>一个class 的默认copy assignment operator ,以下情况不会表现出bitwise copy 语意：</li>
</ol>
<ul>
<li>当含有一个或以上的成员有copy assignment operator 时；</li>
<li>当基类有copy assignment operator时；</li>
<li>当class 中有virtual function 时(需要正确设置vptr);</li>
<li>当class 的继承体系中有virtual base class 时。</li>
</ul>
<ol start="18">
<li><font color="blue">C++语言中的虚拟继承时copy assignment operator弱点</font>：</li>
</ol>
<ul>
<li>C++ 标准没有规定在虚继承时copy assignment operator 中是否会多次调用共享基类的copy assignment operator 。这样就有可能造成共享基类被赋值多次，造成一些错误，所以程序员应该在使用了virtual base class 时小心检验copy assignment operator 里的代码(经确保这样的多次赋值没有问题或者查看编译器是否已经提供了解决方案)。</li>
<li>因此，飞翔可能不要允许一个virtual base class 的拷贝操作，甚至根本就不要在任何virtual base class 中声明数据。</li>
</ul>
<ol start="19">
<li><font color="blue">C++隐式生成的4大成员函数，在不是真正需要的情况下都不要自己去声明。</font></li>
</ol>
<ul>
<li>因为如果是trivial的，这些函数不会被真正的合成出来(只存在于概念上)，当然也就没有调用的成本了，去提供一个trivial的成员反而是不符合效率的。</li>
</ul>
<ol start="20">
<li><font color="blue">析构函数的执行顺序</font></li>
</ol>
<ul>
<li>如果object 内带有vptr，那么首先重设相关的vtable；</li>
<li>deconstructor 函数本身现在会被执行，<u>也就是说vptr会在程序员的代码执行之前被重设；</u></li>
<li>以声明顺序的相反顺序调用members的析构函数；</li>
<li>如果有任何直接的(上一层)nontrivial base classed 拥有deconstructor，那么会以其声明顺序的相反顺序被调用；</li>
<li>如果有任何virtual base classes 拥有 deconstructor ，而当前讨论的这个class是最尾端，那么它们会以原来的构造顺序的相反顺序被调用。</li>
</ul>
<ol start="21">
<li><u>由于析构函数中的重设vptr会在任何代码之前被执行</u>这样就保证了<font color="fuchsia">要析构函数中也不具有多态性</font>，从而不会调用子类的函数。因为此时子类已经不完整了，子类的成员已经不存在了，而子类的函数有可能需要使用这些成员。</li>
<li><font color="red">构造函数和析构函数中都不具有多态性：这并不是语言的弱点，布是正确的语意所要求的</font>(因为那个时候的对象不完整)。</li>
</ol>
<h2 id="第六章-执行期语意学"><a href="#第六章-执行期语意学" class="headerlink" title="第六章 执行期语意学 "></a><center>第六章 执行期语意学 </center></h2><p>讨论执行期的对象模型的行为，包括临时对象的生命周期和new、delete运算符的行为。</p>
<ol>
<li>C++中过多的隐式变换有时候不太容易从程序代码中看出来表达式的复杂度。</li>
<li><font color="fuchsia">C++保证：全局变量会在第一次用到之前构造好，在main()结束之前原构掉。</font></li>
<li>C++程序中所有的Global object 都旋转在程序的data segment 中并清０，但是它的constructor要程序激活时才会被调用。</li>
<li><u>Lippman建议不要使用那些需要使用静态初始化的global object (Google C++编程规范也是如此建议的) 。</u></li>
<li>现在的C++ standard 已经强制要求局部静态在第一次使用时才被构造出来。</li>
</ol>
<ul>
<li>这也是Effiective C++中Singleton 手法所利用的。而且在程序结束时会被以构造的相反次序被摧毁。</li>
</ul>
<ol start="6">
<li><font color="blue">对象的数组是通过编译器安插一个函数调用的代码来实现的</font>：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void* vec_new(void *array,  &#x2F;&#x2F;address of start of array</span><br><span class="line">        size_t elem_size,   &#x2F;&#x2F;size of each class object</span><br><span class="line">        int elem_count,     &#x2F;&#x2F;number of elements in array</span><br><span class="line">        void (*constructor) (void*),  &#x2F;&#x2F;构造函数的指针</span><br><span class="line">        void (*destructor) (void* , char)   &#x2F;&#x2F;析构函数的指针</span><br><span class="line">        )</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">void * vec_delete (void *array    &#x2F;&#x2F; address of start of array</span><br><span class="line">        size_t elem_size,         &#x2F;&#x2F;size of each class object</span><br><span class="line">        int elem_count,           &#x2F;&#x2F;number of elements in array</span><br><span class="line">        void (*destructor) (void* , char)</span><br><span class="line">        )</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>由于把数组的声明转换为vec_new的函数调用，产生的问题是构造函数是通过指针调用的，因此无法使用任何参数，默认参数也不行。</li>
<li>对于那些声明了默认参数从而实际上拥有无参构造函数的类，编译器会产生整体上绝对无参的构造函数，再从这个构造函数里调用这个默认参数的构造函数。(这样，编译器实际上违反了语言的函数，拥有了２个没有参数的构造函数，但是这样的特例只能由编译器自己来违反)</li>
<li>这里之所以传入了析构函数的指针，是为了在构造函数抛出异常时，把已经构造好的对象给原构掉，这是vec_new义不容辞的任务。</li>
</ul>
<ol start="7">
<li><font color="blue">new 的两步曲</font></li>
</ol>
<ul>
<li>分配内存；</li>
<li>调用构造函数；</li>
</ul>
<ol start="8">
<li><font color="blue">delete 的两步曲</font></li>
</ol>
<ul>
<li>调用析构函数</li>
<li>释放内存</li>
</ul>
<ol start="9">
<li>一般的library 对new　运算符的实现：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern void* operator new (size_t size) &#123;</span><br><span class="line">  if (size &#x3D;&#x3D; 0)</span><br><span class="line">    size &#x3D; 1;</span><br><span class="line">  void *last_alloc;</span><br><span class="line">    while (!(last_alloc &#x3D; malloc(size))) &#123;</span><br><span class="line">      if (_new_handler)</span><br><span class="line">        (*_new_handler) ();</span><br><span class="line">      else </span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return last_alloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>有2个精巧之处。第一：new 操作符至少会返回１个字节的内存；第二：_new_handler会给予内存分配不足时以补救的机会。</li>
</ul>
<ol start="10">
<li>虽然C++ standard并没有规定，但是实际上的new运算符都是以C malloc()完成；同样delete 运算符也都是以C free()完成的。</li>
<li><font color="blue">trivial的vec_new()</font>:</li>
</ol>
<ul>
<li>如果要分配的数组的类型并没有默认构造函数，那么这个vec_new()的调用就是trivial的,完全可以仅仅分配内存就可以了，new操作符(注意区分new操作符和new运算符)足以胜任这个任务。只有在定义了默认构造函数时，vec_new才需要被调用起来。</li>
</ul>
<ol start="12">
<li>delete 和delete[]</li>
</ol>
<ul>
<li><u>寻找数组维度给delete运算符带来了效率上的影响，所以出现了这个妥协。只有在”[]”出现时，编译器才会寻找数组的维度，否则它就假设只有一个object需要被删除</u>。<ul>
<li>delete 数组时，只有第１个元素会被删除；</li>
<li>delete[] 单个对象时，１个元素都不会被删除，没有任何析梦函数被调用。</li>
</ul>
</li>
</ul>
<ol start="13">
<li><u>数组的大小会被编译器记录在某个地方</u>，所以编译器能够直接查询出来某个数组的大小。</li>
<li><font color="red">数组和多态行为和天生不兼容性</font>：</li>
</ol>
<ul>
<li>永远不要把数组和多态扯到一起，他们天生是不兼容。<u>当你对一个指向派生类的基类指针进行delete[] pabse ; 操作时，它是不会有正确的语意的</u>。</li>
<li>这是由于delete[]实际上会使用vec_delete()类似的函数调用代替，而在vec_delete()的参数中已经传递了元素的大小，在vec_delete()中的迭代删除时，会在删除一个指针之后将指针向后移动item_size个位置，如果DerivedClass 的size比BaseClass要大的话(通常都是如此)，指针就已经指向一个未知区域国(如果Derived与Base大小相同，那碰巧不会发生错误，delete[]可以正确的执行)。</li>
</ul>
<ol start="15">
<li><font color="blue">placement operator new 应该与 placement operator delete 搭配使用</font>，也可以在placement operator new出来的对象上显式的调用它的析构函数使得原来的内存又可以被再次使用。</li>
</ol>
<ul>
<li>一般而言，placement operator new并不支持多态，因为Derived Class往往比Base class 要大，已经存在的类型为内存并不一定能够容纳Derived类型的对象。</li>
</ul>
<ol start="16">
<li><font color="blue">一段比较晦涩隐暗的代码</font>：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">  public:</span><br><span class="line">    virtual ~Base() &#123;&#125;</span><br><span class="line">    virtual void f() &#123;cout &lt;&lt; &quot;f in Base&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    int value;</span><br><span class="line">&#125;;</span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">  public:</span><br><span class="line">    virtual void f() &#123;cout &lt;&lt; &quot;f in Derived&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Base b;</span><br><span class="line">  b.f();    &#x2F;&#x2F;这个调用很明显</span><br><span class="line">  b.~Base();</span><br><span class="line">  new (&amp;b) Derived;</span><br><span class="line">  b.f();    &#x2F;&#x2F;这个调用就不太明显</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>大部分人认为这里应该输出”f in Derived”，但实际上GCC输出的是”f in Base “。如果理解了前面的编译器如何扩展函数调用，就会明白”f in Base”才是正确的。因为b是一个对象而还是指针或者引用不具有多态性，所以编译器会：<strong>把b.f()直接扩展为Base::f(&amp;b);</strong></li>
<li>因此，可以想象，如果把b换成是Base * 类型，则由于指针会引发多态，所以才调用Derived的f()函数：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Base b &#x3D; new Base();</span><br><span class="line">  b-&gt;f();</span><br><span class="line">  b-&gt;~Base();</span><br><span class="line">  new (b) Derived;</span><br><span class="line">  b-&gt;f();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这次，GCC输出了” in Derived”.</li>
</ul>
<ol start="17">
<li><font color="fuchsia">C++ standard允许编译器对临时性对象的产生胡完全的自由度。</font></li>
<li><font color="blue">临时对象的摧毁时机</font>：</li>
</ol>
<ul>
<li><u>摧毁临时对象应该在产生它的完整的表达式的最后一个步骤</u>。切记是完整的表达式，比如一连串的逗号或一堆的括号，只有在完整的表达式最后才能保证这个临时对象在后面不会再被引用到。</li>
</ul>
<ol start="19">
<li>如果一个临时性对象被绑定于一个reference,对象将残留，直到被初始化之reference 的生命结束，或者直到临时对象的生命范畴(scope)结束——视哪一种情况先到达而定。</li>
<li>总结：临时性对象的确在一些场合、一定程度上影响了C++的效率。但是这些影响完全可以通过良好的编码和编译器的积极优化而解决掉临时性对象带来的问题(至少在很大的程度上)，所以对临时性对象的影响不能大意但也不必太放在心上。</li>
</ol>
<h2 id="第七章-站在对象模型的尖端"><a href="#第七章-站在对象模型的尖端" class="headerlink" title="第七章 站在对象模型的尖端 "></a><center>第七章 站在对象模型的尖端 </center></h2><p>讨论了C++的三个著名扩展:template,exception handing,RTTI。</p>
<ol>
<li>编译器在看到一个模板的声明时会做出什么反映呢？</li>
</ol>
<ul>
<li>实际上编译器没有任何反映！编译器的反映只有在真正具现化时才会发生。</li>
<li>明白了这个，就明白了为什么在模板内部有明显的语法错误，编译器也不会报错，除非你要具现化出这个模板的——实体时编译器才会发出抱怨。</li>
<li>在这点上，似乎GCC做的比MSCV++要好的多。GCC好像会做完的解析，但是除了类型的检验；而MSVC++似乎就是放任不管，只有在具现化的时候才去检查。</li>
<li>在学习了C++ template 就明白了，编译器实际上会做<font color="blue">二阶段查找</font>而且这种延迟到实例化时的具体行为是：<u>延迟定义，而不是声明</u>。</li>
</ul>
<ol start="2">
<li><u>声明一个模板类型的指针是不会引起模板的具现化操作的，因为仅仅声明指针不需要知道class的实际内存布局</u>。</li>
<li>只有在某个member function 真正被使用时，它才会被真正的具现化出来，这样的延迟具现化至少有２个好处：</li>
</ol>
<ul>
<li>空间和时间上的效率；</li>
<li>如果使用的类型并不完全支持所有的函数，但是只需要不去用那些不支持函数，这样的部分具现化就能得以通过编译。</li>
</ul>
<ol start="4">
<li>int 和 long 的一致性：int 和 long 在大多数的机器上都是相同的，但是如果编译器看到如下声明：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Point&lt;int&gt; p1;</span><br><span class="line">Point&lt;long&gt; p2;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>目前的所有编译器都会具现化２个实体。</li>
<li>可以想象，编译器用一些mangling的手法把具现出来的２个实体分别叫做：_Point_int,_Point_Long之类的东西。</li>
</ul>
<ol start="5">
<li>涉及Template时的错误检查太弱了，template中那些与语法无关的错误，程序员可能认为十分明显，编译器却放它通过了，只有特定的实体具现化时，编译器才发出抱怨，这是目前实现技术上的一个大问题(二阶段查找的必然结果)。</li>
<li><font color="blue">Template中的名称决议方式:scope of the template definition(定义模板的地方)和scope of the tempalate instantiation (具现出模板实体的地方)</font>。示例如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;scope of the template definition</span><br><span class="line">extern double foo (double);</span><br><span class="line">template &lt;class type&gt;</span><br><span class="line"></span><br><span class="line">class ScopeRules</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    void invariant() &#123;    &#x2F;&#x2F;情况１</span><br><span class="line">      _member &#x3D; foo(_val);</span><br><span class="line">    &#125;</span><br><span class="line">    type type_dependent() &#123;   &#x2F;&#x2F;情况２</span><br><span class="line">      return foo (_member);</span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    int _val;</span><br><span class="line">    type _member;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;scope of the template instantiation</span><br><span class="line">extern int foo(int);</span><br><span class="line">ScopeRules&lt;int&gt; sr0;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>Template中，对于一个<font color="fuchsia">nonmember name</font>的决议结果是根据这个name的使用是否”用以具现出该template的参数类型”有关而决定的。</li>
<li>当时觉得这样的规则很诡异，然后在学习了C++ Template 之后就很清晰的明白了。这是因为前面一个是非依赖名称；而后面的使用是依赖名称，所以会在不同的时机进行查找(<font color= "blue">二阶段查找</font>)。<ol>
<li>情况１：如果其使用互不相关，那就以scope of template declaration 来决议name；</li>
<li>情况２：如果其使用互有关系，那就以scope of tmeplate declaration 来决议name；</li>
<li>这个看似很诡异的规则，实际上是非常必要的！这给予了一个调用者可以进行自定义的机会。模板的使用者往往可以在使用时，根据具体的调用类型来提供一个更好的函数给模板(就像示例中，提供一个完全符合int类型的函数，可以视为一个更好的函数)。</li>
<li>与参数无关的调用，就是站在模板设计者的角度来看，所以然就使用scope of Template declaration;而与参数相关的调用，就是站在模板使用者的角度来看，当然也就使用scope of the template instantiation.</li>
<li>还需语意一点的就是：<u>这里依据是否与类型相关而决定使用哪一个scope，然后其中搜寻适当的name</u>.示例中的代码，在调用sr0.type_dependent();时，由于使用了scope of the Template instantiation，使得２个foo()函数同时成为备选函数，但是由于foo(int)更加的符合，所以最后才决议使用foo(int)这个版本。如果sr0是ScopeRules<double>类型的话，最后调用的依然是foo(double)那个版本。</li>
</ol>
</li>
</ul>
<ol start="6">
<li>编译器维持了２个scope contexts:</li>
<li>scope of Template declaration : 用以专注一般的template class;</li>
<li>socpe of template instantiation : 用以专注于特定的实体；</li>
</ol>
<ul>
<li>这种关联性不能简单的作用一个宏扩展来重现，是一种很新奇的关联。</li>
</ul>
<ol start="7">
<li><font color="blue">一种具现化的策略</font>：先不具现任何的member function ，链接器会登记缺少哪些函数的定义，然后再重新调用编译器把编译器把登记重写编译出来，最后在把这些缺乏的定义重写编译出来，最后在把这些缺乏的定义和以前的链接结果链接起来堪最后的可执行文件或者库。</li>
<li><font color="blue">如果vtalbe被具现出来，那么每一个virtual function 也都必须被具现。</font></li>
</ol>
<ul>
<li>这就是为什么C++ standard 中有如下的描述：”如果一个虚函数被具现出来，其具现点紧跟在其class 的具现点之后”。(也就是说，virtual function是一口气被具现出来的)</li>
</ul>
<ol start="9">
<li>一般而言，exception handing 机制需要与编译器所产生的数据结构以及执行期的一个excplicit library紧密合作而实现。</li>
<li><u>编译器为了支持异常的机制，又需要把程序员的代码进行大量的扩展才能保证异常机制的正确执行。</u>但是处理这些问题是编译器的责任，不过程序员应该明白这里把做的事情以及有可能付出的代价。</li>
<li><font color="red">以值类型抛出，以引用类型进行捕获</font>：</li>
</ol>
<ul>
<li><u>被抛出的异常类型，一定会被先复制一份，真正被抛弃的实际上是这份复制器</u>；</li>
<li>即使是以值类型来进行捕获异常也可以捕获该值类型和其派生类的异常，但是在catch语句中会引发切割。</li>
</ul>
<ol start="12">
<li>对于每一个被丢出的exception,编译器必须产生一个类型描述器，对exception类型进行编码。如果那是一个derived type,则编码内容还必须包括所有base class 类型信息。</li>
<li>当一个exception被丢出时，<u>exception object 会被产生出来并通常旋转在相同形式的exception数据堆栈中。从throw 端传染给catch子句的是exception object 的地址、类型描述器(或是一个函数指针，该函数会返回该exception type 有关的类型描述器对象)，以及有可能还有的exception object 的析构函数的地址(如果有的话)</u></li>
<li>只有在一个catch子句评估完毕并且知道它不会丢出exception之后，真正的exception object 才会被摧毁。</li>
<li>支持异常机制的代价：<font color="fuchsia">与其它语言特征相比较，C++编译器支持ＥＨ机制所付出的代价最大。</font></li>
</ol>
<ul>
<li><u>C++对异常机制所付出的代价大概为：空间10%、时间5%</u>。不算小，但也不是不可以接受吧。有一个问题：如果编译器开启了异常支持，但是在某一段未使用异常的代码中，也会为编译器开启了异常支持而付出代价吗？</li>
</ul>
<ol start="16">
<li>在C++中，一个具备多态性质的class，就是指賖virtual functions 的类(直接声明或者继承而来的)。</li>
<li>由于具备多态性质的class都已经含有一个vptr指向vtable了，C++把类型信息放在vtable 的第１个slot中(一个type_info的指针指向一个表示当前类型的type_info对象)，从而几乎没有付出代价的支持RTTI(1byte per class,not 1byte per class object)(中文书有误)</li>
</ol>
<ul>
<li><u>由于RTTI所需要的信息放在vtable中，自然的：</u><font color="fuchsia">只有含有vptr的类才支持RTTI</font>.</li>
</ul>
<ol start="18">
<li>有了RTTI机制的支持，就可以实施保证安全的动态转型操作dynamic_cast&lt;&gt;();</li>
<li><font color="blue">在dynamic_cast中使用指针和引用的区别在于当转型失败时：</font></li>
</ol>
<ul>
<li>指针版本会返回0,使用者需要进行检查；</li>
<li>引用的版本会抛出一个bad_exception(因为没有空引用啊)；</li>
<li>这两个机制各有用处吧，视需而用。</li>
</ul>
<ol start="20">
<li>type_info类型copy构造函数和operator=操作符都被声明为私有，禁止了赋值和拷贝操作。而且只提供了一个受保护的带有一个const char * 参数的构造函数，因为不能直接得到<u>type_info 对象，只能通过typeid()运算符来得到这类对象</u>。</li>
<li>RTTI只适用于多态类型(RTTI信息在于vtable的原因)，事实上type_info object 也适用于非多态类型。typeid()作用于多态类型时的差异在于，这时候type_info object 是静态取得的(编译器直接给扩展了)，而非像多态类型一样在执行期通过vtable 动态取得。可以通过这个例子来理解：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct A&#123;&#125;</span><br><span class="line">struct B : public A&#123;&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  A *pa &#x3D; new B;</span><br><span class="line">  cout &lt;&lt; typeid(pa).name() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; typeid(*pa).name() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">将输出：</span><br><span class="line">  struct A *</span><br><span class="line">  struct A</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>这没有检测出pa所指的真正类型，原因就在于<u>typeid运算符用在非多态类型上时，会被编译器在编译器静态的扩展了</u>。也许是类似的扩展：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; typeid(pa).name() &lt;&lt; endl;   &#x3D;&gt; typeid(A*).name()</span><br><span class="line">cout &lt;&lt; typeid(*pa).name() &lt;&lt; endl;  &#x3D;&gt; typeid(A).name()</span><br></pre></td></tr></table></figure></li>
<li>如果给struct A添加一个虚拟函数，从而<u>使得类型Ａ和Ｂ都变成多态类型，于是typeid运算符就会在运行期间动态的去获取它们的真正类型了</u><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">  virtual ~A() &#123;&#125;   &#x2F;&#x2F;A包含了一个虚函数，从而把A变成了多态类型</span><br><span class="line">&#125;;</span><br><span class="line">struct B : public A&#123;&#125;;    &#x2F;&#x2F;B从A继承一个虚函数，所以也是多态类型</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">  A *pa &#x3D; new B;</span><br><span class="line">  cout &lt;&lt; typeid(pa).name() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; typeid(*pa).name() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">将输出：</span><br><span class="line">  struct A*</span><br><span class="line">  struct A</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="22">
<li>效率和弹性始终是矛盾体！</li>
</ol>
]]></content>
      <categories>
        <category>Read Notes</category>
      </categories>
      <tags>
        <tag>theory</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析iterator</title>
    <url>/2021/Iterator/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在日常开发学习中，熟练的使用设计模式可以极大的提高我们的工作效率。诚然，对于那么多的设计模式,我们往往仅会去深入了解日常被使用最多的设计模式。<br>当然，也有一些设计模式，随着高级语言的不断扩展，逐渐走向了没落。一如今天所要讨论的迭代器模式，由于容器的大量使用，使得iterator这一设计模式使用度就降低了许多。那我们就具体聊聊关于迭代器的那些事吧！</p>
<h1 id="什么是迭代器模式"><a href="#什么是迭代器模式" class="headerlink" title="什么是迭代器模式"></a>什么是迭代器模式</h1><p>设计模式中对迭代器的定义是: Iterator是用来解决对聚合对象的遍历问题，将聚合的遍历封装到一个类中进行，这样就避免了暴露这个聚合对象的内部表示的可能<br>很官方，但是也是相对的晦涩一点，让我们先看看它的经典UML图，再来开始讨论它:<br><img data-src="https://7894651.xyz/iterator/2021-08-13_16-01.png" alt="avatar"></p>
<p>如前面所述,迭代器主要是去用来遍历一个聚合元素，这个聚合元素就是以某种顺序方式存储了数据。它可以是一个整数数组，以顺序存储的方式保存数据,抑或是其它的简单数据结构。<br>我们可以通过简单的指针操作得到这个迭代的结果的，但是对于一些复杂数据结构迭代处理起来就会比较麻烦。依定义所说，这会导致对象内部数据表示的暴露。我想读到这里大家一定有如下一些共性问题:<br>    1. 如何我隐藏内部数据表示？<br>    2. 我们是否不管在任何情况下，都需要实现一个迭代器来辅助我们去遍历吗？<br>    3. 如果不是，那又何时才是实现它的好时机呢？<br>让我们一个一个的来处理这些问题。</p>
<p>首先，我们可以思考如下的一个例子: 程序中有一个对象数组需要被遍历，通常情况下,我想大家都会使用如下的方法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;...&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个数组来说使用如上的方法来说，可以是十分的简单。但若是一个较为复杂的数据结构如: 链表、树、图等，对于它们的迭代遍历，我们可远非如同遍历数组一样的容易了。每次的迭代程序，可能都需要一定的测试保证其正确性后才会投入使用。但若是使用迭代器来说就相对的轻松许多，你无需关心它是如何实现的，在使用上所有的迭代器都是一致的。</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>我们可以使用迭代器完成如下vector容器的遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::iterator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; res = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator myiterator = res.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; myiterator != res.<span class="built_in">end</span>(); ++myiterator) &#123;</span><br><span class="line">		cout &lt;&lt; *myiterator &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，十分的容易。除此之外，你还可以将vevtor替换为set、map等数据结构，同样的操作依旧是完全适用的。<br>这样的表示，将迭代操作交由外部类处理，无需内部提供一个迭代的操作，降低了暴露内部实现的细节。</p>
<h2 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h2><p>并非所有的情况下，都需要使用迭代器的。毕竟这会增加系统的一个复杂度，因此它的应用场景大致如下所示:</p>
<ul>
<li>访问一个聚合对象的内容，不需要暴露它的内部表示</li>
<li>支持聚合对象的多种遍历</li>
<li>迭代器模式与集合同时存在</li>
</ul>
<p>既然已经了解它的设计原理，那就动手实践一下吧!</p>
<h1 id="设计一个迭代器"><a href="#设计一个迭代器" class="headerlink" title="设计一个迭代器"></a>设计一个迭代器</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器的主要功能</span></span><br><span class="line"><span class="comment"> *  1. 支持++, 遍历元素</span></span><br><span class="line"><span class="comment"> *  2. 支持* , 取元素</span></span><br><span class="line"><span class="comment"> *  3. 支持-&gt;, 指针操作</span></span><br><span class="line"><span class="comment"> *  4. 支持==与!=， 判断是否到达迭代器尾部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">using</span> value_type = T;</span><br><span class="line">            <span class="keyword">using</span> reference = T&amp; ;</span><br><span class="line">            <span class="keyword">using</span> const_reference = <span class="keyword">const</span> T&amp;;</span><br><span class="line">            <span class="keyword">using</span> pointer = T*;</span><br><span class="line">            <span class="keyword">using</span> const_pointer = <span class="keyword">const</span> T*;</span><br><span class="line">            <span class="keyword">using</span> size_type = <span class="keyword">size_t</span>;</span><br><span class="line">            <span class="keyword">using</span> difference_type = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">iterator</span>(pointer p = <span class="literal">nullptr</span>) : <span class="built_in">arr</span>(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Array&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> arr == rhs.arr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span>!= (<span class="keyword">const</span> Array&amp; rhs) <span class="keyword">const</span>  &#123;</span><br><span class="line">                <span class="keyword">return</span> arr != rhs.arr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Array&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">                arr = arr-&gt;<span class="built_in">next</span>();</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Array&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">                value_type tmp = *<span class="keyword">this</span>;</span><br><span class="line">                ++&amp;*<span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            reference <span class="keyword">operator</span>*() &#123;</span><br><span class="line">                <span class="keyword">return</span> *arr;</span><br><span class="line">            &#125;</span><br><span class="line">            reference <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">                <span class="keyword">return</span> arr;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            pointer arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>迭代器就是对于指针的某些功能的封装，在一般的开发过程中，基本不会需要去实现这样一个迭代器。但是这其中的原理，我们需要去理解，将这些设计的想法应用到我们日常的开发之中。</p>
]]></content>
      <categories>
        <category>Read Notes</category>
      </categories>
      <tags>
        <tag>theory</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解簿</title>
    <url>/2020/Leetcode_archive/</url>
    <content><![CDATA[<p>&emsp;&emsp;随着每日的Leetcode练习，我的Blog数量开始有了明显的提升。每天的记录是很好，但若要快速找到我想需要的材料，又是需要一些功夫。因此，今天准备对我的刷题笔记进行一次整理。</p>
<p>&emsp;&emsp;对于刷题来说，我大概还是一个新手。我想在此，以此帖记录我的刷题生活。每日精进一点，水滴石穿。</p>
<table>
<thead>
<tr>
<th align="center">题号</th>
<th align="center">题目</th>
<th align="center">方法分类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><a href="/2020/Leetcode-1/index.html">两数之和</a></td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><a href="/2021/Leetcode-23/index.html">无重复字符的最长子串</a></td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><a href="/2021/Leetcode-24/index.html">寻找两个正序数组的中位数</a></td>
<td align="center">二分法</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><a href="/2021/Leetcode-25/index.html">最长回文子串</a></td>
<td align="center">滑动窗口</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><a href="/2020/Leetcode-2/index.html">整数反转</a></td>
<td align="center">数学</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><a href="/2020/Leetcode-3/index.html">回文数</a></td>
<td align="center">数学</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><a href="/2021/Leetcode-26/index.html">盛最多水的容器</a></td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><a href="/2020/Leetcode-4/index.html">罗马数字转整数</a></td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center"><a href="/2020/Leetcode-5/index.html">最长公共前缀</a></td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><a href="/2021/Leetcode-27/index.html">三数之和</a></td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center"><a href="/2021/Leetcode-28/index.html">电话号码与数字组合</a></td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center"><a href="/2021/Leetcode-29/index.html">删除链表倒数第N个结点</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center"><a href="/2020/Leetcode-6/index.html">有效的括号</a></td>
<td align="center">栈</td>
</tr>
<tr>
<td align="center">21</td>
<td align="center"><a href="/2020/Leetcode-7/index.html">合并两个有序链表</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center"><a href="/2021/Leetcode-30/index.html">括号生成</a></td>
<td align="center">回溯</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center"><a href="/2021/Leetcode-31/index.html">合并k个升序链表</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">25</td>
<td align="center"><a href="/2021/Leetcode-33/index.html">K个一组翻转链表</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">26</td>
<td align="center"><a href="/2020/Leetcode-8/index.html">删除有序数组中的重复项</a></td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="center">27</td>
<td align="center"><a href="/2020/Leetcode-9/index.html">移除元素</a></td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center"><a href="/2020/Leetcode-10/index.html">实现strStr()</a></td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">35</td>
<td align="center"><a href="/2020/Leetcode-11/index.html">搜索插入位置</a></td>
<td align="center">二分法</td>
</tr>
<tr>
<td align="center">38</td>
<td align="center"><a href="/2020/Leetcode-12/index.html">外观数列</a></td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="center">53</td>
<td align="center"><a href="/2021/Leetcode-32/index.html">最大子序和</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">88</td>
<td align="center"><a href="/2021/Leetcode-18/index.html">合并两个有序数组</a></td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="center">94</td>
<td align="center"><a href="/2021/Leetcode-45/index.html">二叉树的中序遍历</a></td>
<td align="center">树的遍历</td>
</tr>
<tr>
<td align="center">102</td>
<td align="center"><a href="/2021/Leetcode-46/index.html">层序遍历</a></td>
<td align="center">树的遍历</td>
</tr>
<tr>
<td align="center">105</td>
<td align="center"><a href="/2021/Leetcode-36/index.html">从前序遍历与中序遍历构造二叉树</a></td>
<td align="center">深度优先搜索</td>
</tr>
<tr>
<td align="center">106</td>
<td align="center"><a href="/2021/Leetcode-37/index.html">从中序遍历与后序构造二叉树</a></td>
<td align="center">深度优先搜索</td>
</tr>
<tr>
<td align="center">107</td>
<td align="center"><a href="/2021/Leetcode-47/index.html">二叉树的层序遍历II</a></td>
<td align="center">树的遍历</td>
</tr>
<tr>
<td align="center">114</td>
<td align="center"><a href="/2021/Leetcode-21/index.html">二叉树展开为链表</a></td>
<td align="center">深度优先搜索</td>
</tr>
<tr>
<td align="center">116</td>
<td align="center"><a href="/2021/Leetcode-22/index.html">填充每个节点的下一个右侧节点指针</a></td>
<td align="center">深度优先搜索</td>
</tr>
<tr>
<td align="center">135</td>
<td align="center"><a href="/2021/Leetcode-14/index.html">分发糖果</a></td>
<td align="center">贪心算法</td>
</tr>
<tr>
<td align="center">144</td>
<td align="center"><a href="/2021/Leetcode-43/index.html">二叉树的前序遍历</a></td>
<td align="center">树的遍历</td>
</tr>
<tr>
<td align="center">145</td>
<td align="center"><a href="/2021/Leetcode-44/index.html">二叉树的后序遍历</a></td>
<td align="center">树的遍历</td>
</tr>
<tr>
<td align="center">167</td>
<td align="center"><a href="/2021/Leetcode-17/index.html">两数之和II - 输入有序数组</a></td>
<td align="center">双指针</td>
</tr>
<tr>
<td align="center">226</td>
<td align="center"><a href="/2021/Leetcode-20/index.html">翻转二叉树</a></td>
<td align="center">树的遍历</td>
</tr>
<tr>
<td align="center">230</td>
<td align="center"><a href="/2021/Leetcode-39/index.html">二叉搜索树中第K小的元素</a></td>
<td align="center">树的遍历</td>
</tr>
<tr>
<td align="center">234</td>
<td align="center"><a href="/2021/Leetcode-34/index.html">回文链表</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">435</td>
<td align="center"><a href="/2021/Leetcode-15/index.html">无重叠区间</a></td>
<td align="center">贪心算法</td>
</tr>
<tr>
<td align="center">450</td>
<td align="center"><a href="/2021/Leetcode-41/index.html">删除二叉搜索树中的节点</a></td>
<td align="center">二叉搜索树</td>
</tr>
<tr>
<td align="center">452</td>
<td align="center"><a href="/2021/Leetcode-19/index.html">用最少数量箭引爆气球</a></td>
<td align="center">贪心算法</td>
</tr>
<tr>
<td align="center">455</td>
<td align="center"><a href="/2021/Leetcode-13/index.html">分发饼干</a></td>
<td align="center">贪心算法</td>
</tr>
<tr>
<td align="center">538</td>
<td align="center"><a href="/2021/Leetcode-40/index.html">把二叉树搜索树转换为累加树</a></td>
<td align="center">二叉探索树</td>
</tr>
<tr>
<td align="center">605</td>
<td align="center"><a href="/2021/Leetcode-16/index.html">种花问题</a></td>
<td align="center">贪心算法</td>
</tr>
<tr>
<td align="center">652</td>
<td align="center"><a href="/2021/Leetcode-38/index.html">寻找重复子树</a></td>
<td align="center">树的遍历</td>
</tr>
<tr>
<td align="center">654</td>
<td align="center"><a href="/2021/Leetcode-35/index.html">最大子树</a></td>
<td align="center">树的遍历</td>
</tr>
<tr>
<td align="center">701</td>
<td align="center"><a href="/2021/Leetcode-42/index.html">二叉搜索树中的插入操作</a></td>
<td align="center">二叉搜索树</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql中基本操作注意点</title>
    <url>/2021/Mysql_Notice/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><img data-src="https://7894651.xyz/Mysql_Notice/demo.png" alt="avatar"><br>最近在学习数据库相关内容的知识，在GitHub上找到一个百万数据量的数据库。通常，由于数据量少的原因，查询全表数据也是十分的快。但是在引入这个数据量极大的数据库后，这一切似乎都发生了些许了改变。原本的0.00sec就可以完成的全表查询，现在可能需要1.3S左右才可能完成查询。对于数据量很是庞大时，优化也就成了一门必修课了。<br>接下来，我将从数据库的表创建、插入数据、删除数据、检索数据以及更新数据这四个方面。来简单聊聊关于它们的使用时需要注意的事项与简单的优化。</p>
<h1 id="创表规范"><a href="#创表规范" class="headerlink" title="创表规范"></a>创表规范</h1><p>在数据库中，表的创建才是一切的开端。那么，一个经过精良设计的表会在后续的数据库的使用中，将会是对数据库性能与安全的一个极大的保证。我想参照如下的几条建议，可能会更加方便快速的设计出一个性能与安全不错的表。</p>
<ol>
<li>选用正确的数据类型<br>大部分情况下，我们需要根据这个数据的本身特性来决定其类型。若是使用了不相关的数据类型，则可能导致了更多的内存空间的浪费，甚至是错误的发生。<br>举例来说，我们都曾可能有过这样的一个经历: 使用<code>char</code>类型或<code>varchar</code>来存储一个日期时间。显然这也并不是错误，但这可能会导致错误的发生。即我们无法保证输入的数据一定是符合日期时间类型的，而这可能会导致数据库中存储了一些无效甚至是错误的数据。对于这种时间类型的特性，我们可以使用<code>Mysql</code>中提供的DATATIME来定义它。</li>
<li>使用 CHAR(1) 替代 VARCHAR(1)<br>若是存储单个字符，推荐使用CHAR(1),而非使用VARCHAR(1)。因为VARCHAR会占用额外的字节来存储信息。<br>其实这两个类型很相似，但是从存储大小与格式来看，它们则是完全不同的。<code>CHAR</code>最多可以存储255个字符，而VARCHAR最高可达65535个字符。对于CHAR类型来说，存入多少就是多少。相对而言，当字节数小于255时，会使用一个额外字节来存储这个字节长度;若是字节数超过255时，则会使用到两个字节来存储这个字符的长度。</li>
<li>使用CAHR类型存储合适大小的数据<br>举例来说:若是字符串长度小于1000，但却使用CHAR(1000)来替代VARCHAR(1000)类型，这就会导致过多的空间被闲置与浪费</li>
<li>时间格式类型的选用<br>通常来说，我们会使用DATETIME或是DATE类型将时间格式固定为:YYYY-MM-DD或是ISO标准的模式，用以适配我们的引擎。但若是使用其它格式的时间，在数据库中就难以对其进行排序操作。若是需要存储时间(精确到秒)，建议使用TIMESTAMP类型，因为TIMESTAMP使用4字节，而DATETIME使用8个字节</li>
<li>字段的定义<br>定义字段时，最好将其定义为NOT NULL。创表时确定字符集为utf8mb4,并指定所使用的引擎。</li>
</ol>
<h1 id="插入规范"><a href="#插入规范" class="headerlink" title="插入规范"></a>插入规范</h1><p>在日常的工作中，我们常常会遇到批量将数据插入到数据库中的情况，这个时候我们就需要根据不同的情况选择不再的策略。Mysql中提供了两个方式，让我们可以向table中插入数据:<code>insert</code>、<code>replace</code>。接下来，我们就对这两种插入方式，分享一下我们认为所需要注意的规范。我们的之后将会操作如下的一个表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;自增主键&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> gender <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;年级&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> addr <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;家庭住址&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> status <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span> comment <span class="string">&#x27;0:未注册入学;1:已注册入学&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">primary</span> key (id)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) engine<span class="operator">=</span>InnoDB <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>
<ol>
<li>插入一条数据<br>在最初学习数据库时，我们就知道insert可以实现数据的插入，如下操作所示:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> demo (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id, name, gender, addr, status</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) <span class="keyword">values</span> (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>, <span class="string">&#x27;Rabbet&#x27;</span>, <span class="string">&#x27;三年级二班&#x27;</span>,<span class="string">&#x27;Jack Road&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----------------+-----------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> gender          <span class="operator">|</span> addr      <span class="operator">|</span> status <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----------------+-----------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> Rabbet <span class="operator">|</span> 三年级二班      <span class="operator">|</span> Jack Road <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----------------+-----------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
对于数据量较少时，这样做确实是没有什么问题。但是，我们思考一下数据库操作方式。<br>通过连接器连接到数据库中，这样一个TCP连接就建立完成了。那么对应的每一条命令的，都会通过网络发送到Mysql Server解析运行。如果有成千上万的插入命令需要执行时，那么我们难道还需要进行这上千万次的传输操作？即使是存在连接池，这其中的传输的时间也是不可被忽略的。<br>显然，在庞大的数据量面前，insert单条插入就不能算是一个优选。</li>
<li>一次插入多条数据<br>回顾之前，单条插入所存在的缺陷:需要为其建立多条连接，然后传输N连接，由于连接池的存在，可以忽略连接的影响，但是庞大的传输量也是无法被忽视的。因此，我们可以从这个方面下手进行优化的考虑。<br>若是一个养猪人，它养了1000头猪。若是它准备将这些猪全部卖出,它可以有如下两种策略:<ol>
<li>一个车装载一头猪，送到集市卖掉</li>
<li>一个车装载100头猪，送到集市去卖掉<br>比较这两种策略，我想大家都倾向于选择第二和方案。因为，这样的效率高且时间成本相较于第一种低得多。<br>应用这样的策略，我们也可以使用insert进行批量的插入数据:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> demo</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (id, name, gender, addr, status)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">values</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;三年级二班&#x27;</span>, <span class="string">&#x27;Jack Road&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;三年级二班&#x27;</span>, <span class="string">&#x27;Jack Road&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;三年级二班&#x27;</span>, <span class="string">&#x27;Jack Road&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
预处理,显然是一个更好的选择。预编译仅会解析一次查询，若多次执行这个语句，这个开销将不再。</li>
</ol>
</li>
<li>小结<br>需要根据情况设置一次传输的数据量。毕竟数据量越大，在网络中的通信传输时间就越久，发生问题的可能性就越大。<br>除了网络的限制，机器的配置同样也会存在瓶颈。就算sql语句写的再不错，也不会有太高的效率。</li>
</ol>
<h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><ol>
<li>数据清空<br>如果需要清空一个表中所存储的所有数据，并保存表的结构。最好的办法就是使用<code>truncate</code>,而非使用delete。这是由于truncate不走事务，不会锁表，也不会产生大量日志写入日志文件中。具体的写法如下所示:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> table_name</span><br></pre></td></tr></table></figure>
执行这条语句后，将会立即释放磁盘空间，并重置auto_increment的值。但是对于Delete删除来说，它是不释放磁盘空间的，后续insert的数据会覆盖到原先删除的数据上。</li>
<li>delete+limit巨能打<br>delete limit 语法如下所示:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> [LOW_PRIORITY] [QUICK] [IGNORE] <span class="keyword">FROM</span> tbl_name [[<span class="keyword">AS</span>] tbl_alias]</span><br><span class="line"> [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line"> [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</span><br><span class="line"> [LIMIT row_count]</span><br></pre></td></tr></table></figure>
这里需要注意的一个问题:当需要使用order by 排序时，必须使用order by + limit联用，否则<code>order by</code>将会被优化器所优化掉。<br>加了limit到底有什么好处呢？如下条SQL语句为例:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from demo where gender&#x3D;&#39;三年级二班&#39;;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>避免语句的错误，导致全表删除的风险。降低错删的代价，以更少的时间使用binlog日志进行恢复</li>
<li>避免长事务，delete执行MySQL将会涉及行加写锁与Gap锁，所有DML语句相关行会被锁住。若是删除量巨大，则会某些业务直接无法使用</li>
<li>delete 数据量大时，不加limit很容易将CPU打满，导致执行的效率越来越慢。</li>
</ul>
<p>通常加锁都是索引的情况，若是gender这一行没有索引，则有可能引发锁表的情况的发生，即使<code>gender='三年级二班'</code>仅有一条数据。</p>
<h1 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h1><ol>
<li>开启慢日志<br>可以通过开启慢日志，找到查询执行时间长的SQL语句。并对其进行优化,慢查询时间阈值可以在mysql进行设置。</li>
<li>不做列运算<br>举例来说:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">where</span> id<span class="operator">+</span><span class="number">1</span><span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
任何对列的操作都将导致全表扫描，它包括数据库中所提供的函数、计算表达式等等</li>
<li>SQL语句简单化<br>一条SQL语句只能在一个CPU上运算。拆分简化SQL语句可以减少锁的时间，从而避免了一个大的SQL执行语句堵塞了数据库的情况。</li>
<li>避免使用select *查询<br>避免使用它，是因为它会返回一些无用字段。其低效率的原因大致如下所示:</li>
</ol>
<ul>
<li>不需要的列会增加传输时间与网络开销</li>
<li>对于无用的大字段，如:varchar、blob、text,会增加IO操作</li>
<li>失去MySQL优化器”覆盖索引”策略优化的可能</li>
</ul>
<ol start="5">
<li>少用JOIN<br>首先JOIN本身的效率就是一个硬伤，一旦数据过大这个效率就难以保证了。<br>如果是JOIN的话，它是走嵌套查询的。小表驱动大表，且通过索引字段进行关联。如果表记录比较少的话，还是OK的。大的话业务逻辑中可以控制处理。</li>
</ol>
<h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><p>执行UPDATE前，一定记得先写好WHERE条件，或者先准备好完整的SQL再执行，或者开启sql_safe_updates，或者执行前都先加上BEGIN（误操作了还能回滚事务）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里，我们仅是讲了一些笔者所认为的规范。当然，可能还会存在比这更加严苛的规范存在。不过，在遵循以上条件的情况下。我想这大概可以写出一个基本符合规范的SQL语句了。<br>其中，关于一些内容如:少用JOIN、避免使用select * 查询，并没有展开讨论。之后，我们在后续的文章中补上的。最后，祝大家中秋快乐！</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>theory</tag>
      </tags>
  </entry>
  <entry>
    <title>NRV优化</title>
    <url>/2021/NRV_Opt/</url>
    <content><![CDATA[<h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>&emsp;&emsp;之前在阅读候捷老师的《深入探索C++对象模型》一书时，对于NRV优化操作这个编译器优化并还是特别的清楚。所以今天准备通过实际测试来深入了解一下这个NRV的编译器优化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Edge&#123;</span><br><span class="line"> public:</span><br><span class="line">  Edge() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Edge construct!&quot; &lt;&lt; std::endl;</span><br><span class="line">    Point &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Edge() &#123; std::cout &lt;&lt; &quot;Edge destruct！&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">  Edge(const Edge&amp;_result) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Copy Construct!&quot; &lt;&lt; std::endl;</span><br><span class="line">    Point &#x3D; _result.Point;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  int Point;</span><br><span class="line">&#125;;</span><br><span class="line">Edge get() &#123;</span><br><span class="line">  Edge point;</span><br><span class="line">  return point;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123; Edge point &#x3D; get(); &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来我们将通过这个例子来深入了解NRV优化</p>
<h1 id="不用NVR优化"><a href="#不用NVR优化" class="headerlink" title="不用NVR优化"></a>不用NVR优化</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; g++ -o demo test.cpp -fno-elide-constructors</span><br><span class="line">&#x2F;&#x2F; -fno-elide-constructors 表示输出未优化的结果</span><br><span class="line">Edge construct!</span><br><span class="line">Copy Construct!</span><br><span class="line">Edge destruct！</span><br><span class="line">Copy Construct!</span><br><span class="line">Edge destruct！</span><br><span class="line">Edge destruct！</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述代码中，在成员函数get()函数中定义了一个Edge对象，然后将其作为返回值返回。如果按照调用copy construct,编译器会对代码进行一个扩张操作</p>
<ul>
<li>首先加上一个额外参数，类型是类对象的一个引用，这个参数用来放置由copy construct 而得到的返回值。</li>
<li>在return命令之前安插一个copy construct调用操作，以便将欲传回的对象的内容当作上述新增参数的初值。</li>
</ul>
<p>具体过程可以通过下面的伪代码来了解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Edge get(Edge &amp;_result) &#123;</span><br><span class="line">  &#x2F;&#x2F; 增加一个额外参数作为引用传入函数</span><br><span class="line">  Edge point;</span><br><span class="line">  &#x2F;&#x2F;这里会调用Edge的空构造函数</span><br><span class="line">  point.Edge::Edge();</span><br><span class="line">  &#x2F;&#x2F;调用拷贝构造函数将Edge将point的值赋给返回值</span><br><span class="line">  _result.Edge(point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上述代码中，编译器的扩张操作，构造出了point。但是这个没用空构造的point根本就没有起到什么作用。对于编译器来说，这就会导致资源的浪费，拖慢运行速度。所以NRV优化操作就显的很有必要了。</p>
<h1 id="使用NRV优化"><a href="#使用NRV优化" class="headerlink" title="使用NRV优化"></a>使用NRV优化</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; g++ -o demo test.cpp</span><br><span class="line">&#x2F;&#x2F; g++ -o 会对程序做部分优化 </span><br><span class="line">Edge construct!</span><br><span class="line">Edge destruct！</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编译器为了避免这个无意义的临时变量，编译器选择使用传入的参数(_ result)。对其直接进行构造，这样就避免了无意义的临时变量。具体操作参考如下伪代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Edge get(Edge &amp;_result) &#123; &#x2F;&#x2F;额外参数作为引用参数介入函数</span><br><span class="line">  &#x2F;&#x2F;使用NRV优化后，不再生成point临时变量，而是对_result直接进行构造</span><br><span class="line">  _result.Edge::edge();</span><br><span class="line">  return; &#x2F;&#x2F; 返回已有的返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>&emsp;&emsp;只有在显式定义copy construct 的时候，编译器才会激活NRV优化操作。对于普通的程序，是看不出NRV优化的好处，只有在庞大数据量时，NRV优化操作的优点才会显现出来。</p>
]]></content>
      <categories>
        <category>Read Notes</category>
      </categories>
      <tags>
        <tag>theory</tag>
      </tags>
  </entry>
  <entry>
    <title>九月总结</title>
    <url>/2021/Sep_Summary/</url>
    <content><![CDATA[<p>&emsp;&emsp;九月，暑气渐消，金秋悄然而至。这一个月过去的很快，由于没有明确的目标制定，我的九月总是处于一种混乱的状态。为了更好的摆脱这种状态，因此有了这篇总结。在此我将从学习、出行及家庭这三个方面，来详细总结我这混乱九月。</p>
<p><img data-src="https://7894651.xyz/Sep_Summary/%E4%B9%9D%E6%9C%88%E6%80%BB%E7%BB%93.png" alt="avatar"></p>
<p>&emsp;&emsp;若是想要长期的进步，那么学习仍是悬在头上一把达摩克里斯之剑。相较于从前的学习方法，即被动接受的知识传输，显然这已无法适应这高速发展的时代了。主动去学习、在实践中应用、在结束时进行总结，我想这样才有助于知识的全面掌握。由于我现在的身份特殊性，一个未毕业的实习生。我将从自我学习、工作学习、学校学习这三个方面对学习生活进行反思与总结。</p>
<p>&emsp;&emsp;首先，自我学习这本是一项能力，需要足够的自律与目标明确性，才能保证自己学习的稳步前进。在九月中，我仅是阅读了一本《InnoDB技术内幕》，并做了简单的笔记。自身不断重复的懒惰与拖延，直接的导致我的阅读进度的拖累。当然，我的阅读方法也存在一些问题:过于注重细节，不能很好的把握全局。现在看来，可以通过这个解决方法来处理:需要先粗读一遍，辅以简单笔记标识重点，再以细读重点部分，并深入其中切中肯綮。在阅读之余，同样也不可忘记写作这个新时代的软技能的要求。在九月中，我完成了两篇博文。但大多都是借鉴东拼西凑出来的东西，自己的真正的产出太少了，这样的文章，真的是味如嚼蜡。在阅读别人文章，总是会不禁慨叹他的理解为何如此的深入。我想这大概是由于，我的阅读量太少，没有一定的项目与知识的积累所导致的吧。我应当加强阅读的能力，并将作好笔记，以便日后查阅。</p>
<p>&emsp;&emsp;只能不断的增强自我学习的能力，才能在工作中有更多的收获。整个九月也几乎是在实习中所渡过的，同时这也是我逐步将所学理论应用于实践之中的一个过程。在工作时，所需要阅读的内容就不再是那些经典的书籍。它们往往是一些开发文档，开发手册等。刚开始阅读时，这些内容其实也并不是太难以理解。但是将这些内容置于代码之中形成一个整体时，就会变得十分难以理解。我的导师推荐我所使用的方法是:将程序运行起来，搞清楚程序的运行流程，理解重要的变量命令的含义。从上到下，逐步推进。这样的方法，应用于实际中确实对于程序的主体脉络掌握清晰了许多。但是，对于深入其中的一些细节，仍是需要沉下心来进行深入的理解。由于开发环境的特殊并且没有工具辅助的情况下，这样的阅读进度比较缓慢。当然，由于没有良好的总结习惯，导致我一直处于低效率的工作状态，且没有进行及时的纠正。因此，我查阅了大量的网络建议与一些书籍推荐。通过一定的归纳总结后，我认为这种方法对于阅读源码会有一定的效率提升:1、让程序跑起来，让我们了解其是如何运行的;2、找到main函数或是入口点开始分析;3、运行程序并作适当的断点调试;4、为源码创建一个脑图，说明其代码中的各部分联系。在之后的学习工作中，我会践行这样的规范。改变学习的低效，在相对时间内实现更多的产出。</p>
<p>&emsp;&emsp;当然工作不仅是学习，它也是一种不同的生活。由于工作的原因，我出差来到了山西太原。在这千里之外的北方，我第一次有了离乡之感。那里的风景远不同于我所生活的南方，它更多的是一种山中小城的恬静。山西作为晋商的发源地，颇具老城韵味，在出差休息时，我也有幸游览了榆次老城。若是说大部分景点都是路途遥远的话，那么榆次老城一定是一个特例。它位于闹市之中，往来之人络绎不绝，为这都城源源不断的注入新活力。在这老城中，最令我震撼的那一定是榆次县衙了。素有”晉藩首輔”的称号，这是一个六进州制的衙门。内部的庭院错落有致，且各个部门的办公也均设立在此，不可以不谓之宏伟。漫步在这青石古板的街道中，更觉这千年老城的古朴与庄重。山西不仅有着独具魅力的人文风景，同时也有着享誉天下的名醋——山西老陈醋。虽同是醋，但是山西陈醋却与镇江的香醋有着极为不同的味觉体验。如果细细描绘出来的话，香醋就像入口就像烈酒呛喉一般浓烈，山西的陈醋则如久酿一般敦厚而悠久。当然，山西还有平遥的牛肉、平梁的碗托等等。聊到美食，就不得不说一不南北口味的差异。这里主食皆以面食为主，而这些面食真的是花样繁多。单单是简单想想就可以罗列出许多的面食，如常见的:铁尖、荞麦素面、手揪面、刀削面、清汤面等等。就是这样一个城市，没有太多的喧闹，人们在这小城中过着属于自己的平静生活。</p>
<p><img data-src="https://7894651.xyz/Sep_Summary/demo3.jpg" alt="avatar"><br><img data-src="https://7894651.xyz/Sep_Summary/demo4.jpg" alt="avatar"><br><img data-src="https://7894651.xyz/Sep_Summary/demo1.jpg" alt="avatar"></p>
<p>&emsp;&emsp;实习是拓展了我的眼界，但是作为一个学生的本务，学校的学习仍是不可懈怠。不觉光阴，三年大学生活已然匆匆逝去。不久之后，我也会走出这象牙塔中，经历社会的毒打。我的导师在闲暇之余也与我聊过关于时间这个令人困惑的话题。他说:”对于他而言，时间不再是以月来计时，而是以年为单位的流逝，可能未曾发觉一年又已然过去”。越是长大，越感时间流逝之快。学校也在大四这一年安排了相对较少的课程，不过不允许外出实习却是铁律。学校的课程一如往常的读PPT式教学，当然这是老师的”职责”。这样的课程，让学生们花费着大量的时间，学习着落后的技术。如同，孔已己问众人茴香豆的茴有几种写法一般，可悲又可笑。当然，大学大学，大不了自己学。这个大四，我准备规划在完成自己课业的情况下，抓紧时间进行实习，阅读经典书籍充实自己，撰写Blog打造个人平台，提升未来自己的核心竞争力。</p>
<p>&emsp;&emsp;在实习中，我交通出行方式也不再与以往相同。而是变得多样化。在九月之中，我乘坐了高铁、动车、绿皮火车的软卧。常用的公交出行，变成了打车出行。这一系列的变化，较大的影响我的日常交通的选择方式。诚然，公交出行会更加的省钱。但是，这也相对的会更加的费时。在上班时，为了给睡眠留下更多的时间，打车确实是一个不二的选择。在绿皮火车的卧辅，更是一种不同的经历。我坐过三次卧辅，每一次都是新体验。第一次，我与同事一同从太原乘坐火车赶回南京。在车上，我们体验了火车上的餐食。虽然，价格有点贵但是这都是现做的，也确实是值了。然后和他长聊了很久，我们聊理想、聊故乡、追忆童年。那一夜很平静，在绿皮火车的颠簸中我们也都各自进入了梦乡。第二次去太原时，遇到一个去参加朋友婚礼的山西大哥。他很开心的讲着山西的美食，似是在讲述着一个作为山西人的骄傲。最后一次，回到南京时，遇到了同行人换辅的请求。我自己一人，也没有太多要求，也就同意了一个大叔的换床请求。我的这个车厢中，有两个去南京求学的山西小伙。他们为了可以买到一个卧辅车厢中，竟是加价一直买到了上海的车票。他们并没有为这些钱而懊恼，他们一路则是谈论着即将到来的学校的一切。看着他们，不禁让我想起我初入大学时对未来美好的展望。或是太累，没多久就睡着了，再醒来时已是天明。收拾收拾了行囊，就下了火车，之后又踏上下一班高铁，向着回家的方向驶去。</p>
<p><img data-src="https://7894651.xyz/Sep_Summary/demo.jpg" alt="avatar"><br><img data-src="https://7894651.xyz/Sep_Summary/demo5.jpg" alt="avatar"></p>
<p>&emsp;&emsp;旅程的终点，始终是那有父母守候的谓之家的地方。在家中，我会制作一些简单的饭菜来提高我这粗陋的厨艺。当然，匆匆几天的居家，我并没有太多的掌厨机会。大概是，妈妈认为负责我和爸爸的饮食是她的责任吧，亦或许这就是母爱的具现化吧。在日常的交流过程中，我与父母的沟通变得越来越因难。我想大概是由于我还没有作出成绩，不想告诉它们我在外的能力并非那么的出色。我想我需要寻找一个更好的方式与父母进行对话，我现在似是陷入一个困境，不过这些都是我的内因所导致。我应及时找到内因，解决它才能让父母对我安心，简单的说一句:”你放心，这一切我都会处理好”，只会让父母想要了解更多，徒增他们的担忧。当然，减少与父母的冲突。管理好自己的情绪，与父母心平气和的沟通，才是最好的方法。如《礼记·大学》中所描述的一样:”欲齐其家者，先修其身”，若是不能及时的明晰自己的错误、修正自己的过失。如果一个人都无法很好的管理自身，那又如何才能解决家庭中的困境呢？需要学习的东西，还有很多，但是只有逐步的修身，都会有齐家的结果。</p>
<p>&emsp;&emsp;九月，混沌的一个月，迷茫的一个月。十月伊始，学习仍在路上。希望可以在下一月的总结中，可以改正错误，朝着正确的方向发展，塑造一个更好的自己。</p>
]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>The Annotated STL Sources-2</title>
    <url>/2021/The-Annotated-STL-Sources-2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>The Annotated STL Sources-4</title>
    <url>/2021/The-Annotated-STL-Sources-4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>标准的STL关联式容器set(集合)和map(映射表)两大类，在观念上它们类似于数据库(实际则还要简单):每笔数据(每个元素)都有一个键值(key)和一个实值(value)。当元素插入到关联式容器时，就会以某种特定规则将这个元素放在适当的位置。因此关联式容器没有所谓的头尾的说法，所以就没有一些push_back()、push_font()等等这样的操作。<br>关联式容器所包含的容器<br><img data-src="https://7894651.xyz/RBTree/pic.png" alt="avatar"></p>
<p>一般而论，关联式容器的内部结构都是一个balanced binary tree(平衡二叉树)，用以寻求最高的搜索效率。当然，对于平衡二叉树来说，它也是存在许多的分支。但是其中广泛运用于STL关联式容器的底层结构的主要是RB-Tree，作为关联式容器的核心，我们很是有必要来深入探索一下它。</p>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>在了解红黑树之前，大概还需要一些基本的知识准备。树作为一种十分基础的数据结构，几乎所有的操作系统都将文件存放在树状结构。树这种数据结构也具有许多的分支，如文件压缩所采用的哈夫曼树，数据库中使用的B-Tree等。对于RB-Tree来说，它就是属于二叉搜索树中的一种。<br>所谓二叉树搜索树,是指一颗空树或是具有以下性质的二叉树：<br>&emsp;&emsp;1. 若任意节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值<br>&emsp;&emsp;2. 若任意节点的右子树不为空，则右子树上所有节点的值均大于它的根节点的值<br>&emsp;&emsp;3. 任意节点的左、右子树也分别是二叉搜索树<br>对于二叉树，还可以细分为平衡二叉树(Balanced binary search tree)与自平衡二叉搜索树(AVL tree)。它们都很相似，却又是十分的不同。</p>
<h2 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h2><p>它是一种结构平衡的二叉树,其每个节点的左右两个高度差不超过一个二叉树。可以在O(logn)时间内完成插入、删除操作。<br>其结构如下图所示：<br><img data-src="https://7894651.xyz/RBTree/pic1.png" alt="avatar"></p>
<h2 id="自平衡二叉搜索树"><a href="#自平衡二叉搜索树" class="headerlink" title="自平衡二叉搜索树"></a>自平衡二叉搜索树</h2><p>AVL树是最早发明的自平衡二叉搜索树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。<br>AVL树插入节点时，存在四种平衡破坏的情况，这里假设最深节点为X，那么对应的情况就是：<br>&emsp;&emsp;1. 插入点位于X的左子节点的左子树——左左<br>&emsp;&emsp;2. 插入点位于X的左子节点的右子树——左右<br>&emsp;&emsp;3. 插入点位于X的右子节点的左子树——右左<br>&emsp;&emsp;4. 插入点位于X的右子树的左子树——右右</p>
<p>那么对应这四种情况，我们也提供了两种解决方法来修复这些插入而导致的不平衡。<br>首先是单旋转，它主要用于对左左与右右这两种情况的处理。<br><img data-src="https://7894651.xyz/RBTree/pic2.png" alt="avatar"><br>其次就是双旋转，它也就是利用两次单旋转来实现的，它主要用于对左右与右左这两种情况进行处理。<br><img data-src="https://7894651.xyz/RBTree/pic3.png" alt="avatar"></p>
<p>RB-Tree是另一个被广泛使用的平衡二叉搜索树,它的平衡条件虽然不同于AVL-Tree,但是也同样使用了单旋转与双旋转修正操作，这些在RB-Tree的解析中也详细解析。</p>
<h1 id="RB-Tree"><a href="#RB-Tree" class="headerlink" title="RB-Tree"></a>RB-Tree</h1><p>RB-Tree不仅是一个二叉搜索树，它还必须满足以下的规则：<br>&emsp;&emsp;1. 每个节点的颜色非黑即红<br>&emsp;&emsp;2. 根节点颜色必须是黑色<br>&emsp;&emsp;3. 每个叶子节点(NULL)是黑色<br>&emsp;&emsp;4. 如果一个节点是红色，则它的子节点必须是黑色<br>&emsp;&emsp;5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点数</p>
<p>如下就是一个标准的红黑树：<br><img data-src="https://7894651.xyz/RBTree/pic4.png" alt="avatar"></p>
<h2 id="节点设计"><a href="#节点设计" class="headerlink" title="节点设计"></a>节点设计</h2><p>RB-Tree有红黑两种颜色，并且具有左右子节点，我们可以很容易的设计出其结构风貌。具体STL中源码中如下：<br><font color=red><strong>__rb_tree_node_base</strong></font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;	</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;	</span><br><span class="line"></span><br><span class="line">  color_type color; 	<span class="comment">// 定义节点颜色</span></span><br><span class="line">  base_ptr parent;		<span class="comment">// 定义父节点,由于许多操作皆需要父节点才可以完成</span></span><br><span class="line">  base_ptr left;		<span class="comment">// 定义左孩子</span></span><br><span class="line">  base_ptr right;		<span class="comment">// 定义右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最大节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><font color=red><strong>__rb_tree_node</strong></font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node</span> :</span> <span class="keyword">public</span> __rb_tree_node_base	<span class="comment">// 继承__rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  Value value_field;	<span class="comment">// 定义节点数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>红黑树的节点设计很是巧妙，将节点与数据分开定义。这种手法与list结构很是类似，__rb_tree_node_base定义了指针，__rb_tree_node定义了继承了前者，并增加了数据，这样就形成了一个完整的节点。<br>节点样式如下：<br><img data-src="https://7894651.xyz/RBTree/pic5.png" alt="avatar"></p>
<h2 id="迭代器设计"><a href="#迭代器设计" class="headerlink" title="迭代器设计"></a>迭代器设计</h2><p>迭代器中<code>increment</code>与<code>decrement</code>函数主要实现的就是++与–，即迭代器中的前进与后退操作。<br><font color=red><strong>__rb_tree_base_iterator</strong></font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_base_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;	<span class="comment">// bidirectional_iterator_tag类型的迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  base_ptr node;	<span class="comment">// 指针节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++核心函数</span></span><br><span class="line">    <span class="comment">// 节点是从node节点出发, 一直寻找右节点的左孩子, 每次找到比上次大的元素</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 有右节点, 就往右节点走</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right != <span class="number">0</span>) &#123;</span><br><span class="line">      node = node-&gt;right;</span><br><span class="line">        <span class="comment">// 一直往左节点走, 直到走到头</span></span><br><span class="line">      <span class="keyword">while</span> (node-&gt;left != <span class="number">0</span>)</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 没有右节点, 就寻找父节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      base_ptr y = node-&gt;parent;</span><br><span class="line">        <span class="comment">// 如果该节点是父节点的右孩子就继续往上找, 直到y节点不是父节点的右孩子</span></span><br><span class="line">      <span class="keyword">while</span> (node == y-&gt;right) &#123;</span><br><span class="line">        node = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;right != y)</span><br><span class="line">        node = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --核心代码</span></span><br><span class="line">    <span class="comment">// 节点是从node节点出发, 一直寻找左节点的右孩子, 每次找到比上次小的元素</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 只有根节点, 每次--都是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;color == __rb_tree_red &amp;&amp; node-&gt;parent-&gt;parent == node)</span><br><span class="line">      node = node-&gt;right;</span><br><span class="line">      <span class="comment">// 有左节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;left != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 往左节点走</span></span><br><span class="line">      base_ptr y = node-&gt;left;</span><br><span class="line">        <span class="comment">// 只要有右节点就一直往右节点走</span></span><br><span class="line">      <span class="keyword">while</span> (y-&gt;right != <span class="number">0</span>)</span><br><span class="line">        y = y-&gt;right;</span><br><span class="line">      node = y;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 没有左节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找父节点</span></span><br><span class="line">      base_ptr y = node-&gt;parent;</span><br><span class="line">        <span class="comment">// 如果当前节点是父节点的左孩子就继续寻找父节点直到不再是左孩子</span></span><br><span class="line">      <span class="keyword">while</span> (node == y-&gt;left) &#123;</span><br><span class="line">        node = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line">      node = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>红黑树的迭代器，通过继承 __rb_tree_base_iterator重载++与–操作(通过调用 increment()与decrement())</p>
<h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><p>在深入到构造之前，还需要先了解一下基本类型定义。对于红黑树来说，它也有自己的空间配置器，其中也囊括了各种类型定义，维护整棵红黑树的三笔数据node_count 记录树的大小、header这是头节点，非根节点，但是头节点指向根节点以及key_compare这个仿函数。其类型定义源码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;	<span class="comment">// 定义节点指针</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;	<span class="comment">// 定义节点</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;	<span class="comment">// 定义空间配置器</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 满足traits编程</span></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  size_type node_count; <span class="comment">// keeps track of size of tree</span></span><br><span class="line">  link_type header;  	<span class="comment">// 头节点, 不是根节点, 头节点是指向根节点</span></span><br><span class="line">  Compare key_compare;	<span class="comment">// 伪函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 定义迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, reference, pointer&gt; iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, const_reference, const_pointer&gt;</span><br><span class="line">          const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;iterator, value_type, reference,</span><br><span class="line">                                         difference_type&gt;</span><br><span class="line">          reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;const_iterator, value_type,</span><br><span class="line">                                         const_reference, difference_type&gt;</span><br><span class="line">          const_reverse_iterator;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于红黑树来说，它的构造存在两种方式：一种是以现有的RB-Tree复制一个新的RB-Tree，另一个就是产生一棵空树，如下图所示：<br><img data-src="https://7894651.xyz/RBTree/pic6.png" alt="avatar"></p>
<h2 id="元素插入与删除"><a href="#元素插入与删除" class="headerlink" title="元素插入与删除"></a>元素插入与删除</h2><p>在红黑树中，元素的插入与删除就要涉及到红黑树的调整了。不过对于红黑树而言，调整也就不过两种方式：左旋、右旋。那么为什么需要这些操作呢？这是由于在元素的插入与删除过程中，可能会违背红黑树的性质，因而需要它们来修复平衡。其实，如果理解左旋，右旋也就没有什么问题了，毕竟左右树是对称的。</p>
<h3 id="左旋操作"><a href="#左旋操作" class="headerlink" title="左旋操作"></a>左旋操作</h3><p>对于左旋操作大致需要六个步骤，这里需要设有一个前提：这里假设x的右孩子为y，这样就可以开始了：<br>&emsp;&emsp;Step1: 将”y的左孩子”设为”x的右孩子”,即B为x的右孩子<br>&emsp;&emsp;Step2: 将”x”设为“左孩子的父亲”,即将B的父亲设为x<br>&emsp;&emsp;Step3: 将 “x的父亲” 设为 “y的父亲”<br>&emsp;&emsp;Step4: 这里需要讨论父节点的三种情况：<br>&emsp;&emsp;&emsp;&emsp;Case1: 如果”x的父亲”为空节点，则将y设为根节点<br>&emsp;&emsp;&emsp;&emsp;Case2: 如果x是它的父节点的左孩子，则将y设为父节点的左孩子<br>&emsp;&emsp;&emsp;&emsp;Case3: 如果x是父节点的右孩子，则将y设为”x的父节点的右孩子”<br>&emsp;&emsp;Step5: 将x设为y的左孩子<br>&emsp;&emsp;Step6: 将x的父节点设为y<br>如下图所示：<br><img data-src="https://7894651.xyz/RBTree/pic7.png" alt="avatar"></p>
<h3 id="右旋操作"><a href="#右旋操作" class="headerlink" title="右旋操作"></a>右旋操作</h3><p>对于右旋操作大致操作也是一样的，这里也需要设有一个前提:这里假设y的左孩子为x这样就可以开始了：<br>&emsp;&emsp;Step1: 将 “x的右孩子” 设为 “y的左孩子”，即 将B设为y的左孩子<br>&emsp;&emsp;Step2: 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y<br>&emsp;&emsp;Step3: 将 “y的父亲” 设为 “x的父亲”<br>&emsp;&emsp;Step4: 这里需要讨论父节点的三种情况：<br>&emsp;&emsp;&emsp;&emsp;Case1: 如果”x的父亲”为空节点，则将y设为根节点<br>&emsp;&emsp;&emsp;&emsp;Case2: 如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”<br>&emsp;&emsp;&emsp;&emsp;Case3: (y是它父节点的左孩子) 将x设为“y的父节点的左孩子”<br>&emsp;&emsp;Step5: 将 “y” 设为 “x的右孩子”<br>&emsp;&emsp;Step6: 将 “y的父节点” 设为 “x”<br>如下图所示：<br><img data-src="https://7894651.xyz/RBTree/pic8.png" alt="avatar"></p>
<h3 id="元素插入"><a href="#元素插入" class="headerlink" title="元素插入"></a>元素插入</h3><p>一般而言，RB-Tree可以分为三个步骤：<br>&emsp;&emsp;Step1: 将红黑树当作二叉查找树，将节点插入<br>&emsp;&emsp;Step2: 将插入节点着色为红色<br>&emsp;&emsp;Step3: 通过一系列的旋转或着色操作，将其变成一棵红黑树</p>
<p>但是，正如之前所说，插入会导致红黑树的性质被破坏。所以对应的我们除了使用左旋或右旋外，我们还应对不符合性质的节点进行染色。<br>插入一个新的节点，颜色默认都是红色，这样就不会破坏性质5。当插入的新节点非红黑树的根节点，且其父节点颜色为红色，这样就会破坏性质4。这是一个基本前提，之后就是需要通过旋转与染色来修正平衡。其实这里主要就是对节点x的父节点为x祖父节点的左右子树进行一个讨论。由于树是对称的，在这里我只对当x的父节点为x祖父节点的左子树进行一个展开讨论。</p>
<p>&emsp;&emsp;前提：节点x的父节点x-&gt;parent是其祖父节点x-&gt;parent-&gt;parent的左孩子<br>&emsp;&emsp;情况1：若其叔叔节点y存在,且为红色<br>&emsp;&emsp;&emsp;&emsp;将其父节点x-&gt;parent改变成黑色<br>&emsp;&emsp;&emsp;&emsp;将其叔叔节点y改变成黑色<br>&emsp;&emsp;&emsp;&emsp;将其祖父节点变成红色<br>&emsp;&emsp;&emsp;&emsp;把祖父节点作为当前节点,一直上溯,继续判断是否破坏RB-Tree性质.<br>&emsp;&emsp;情况2：x的叔叔节点y是黑色且x是一个右孩子<br>&emsp;&emsp;&emsp;&emsp;则以其父节点作为旋转节点,进行一次左旋<br>&emsp;&emsp;&emsp;&emsp;旋转之后,节点x变成其父节点的左孩子<br>&emsp;&emsp;情况3：x的叔叔节点y是黑色且x是一个左孩子<br>&emsp;&emsp;&emsp;&emsp;情况2，通过变换也进入了情况3<br>&emsp;&emsp;&emsp;&emsp;改变其父节点x-&gt;parent颜色<br>&emsp;&emsp;&emsp;&emsp;改变其祖父节点x-&gt;parent-&gt;parent颜色<br>&emsp;&emsp;&emsp;&emsp;对其祖父节点进行一次右旋转<br>具体操作，可以见如下动图：<br><img data-src="https://7894651.xyz/RBTree/pic3.gif" alt="avatar"></p>
<h2 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h2><p>在这里，仅对元素的插入与搜索进行一个深入讨论。</p>
<h3 id="基本元素操作"><a href="#基本元素操作" class="headerlink" title="基本元素操作"></a>基本元素操作</h3><p>红黑树中，它所需的基本元素有很多。其中就包括：左节点、右节点、父节点、实值、键值、颜色等，具体到源码，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;parent; &#125;		<span class="comment">// 获取根节点</span></span><br><span class="line">  <span class="function">link_type&amp; <span class="title">leftmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;left; &#125;		<span class="comment">// 最小节点</span></span><br><span class="line">  <span class="function">link_type&amp; <span class="title">rightmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;right; &#125;	<span class="comment">// 最大节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前节点的左节点</span></span><br><span class="line">	<span class="comment">// 当前节点的右节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> x-&gt;value_field; &#125;	<span class="comment">// 当前节点的数据</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(x-&gt;color); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> ((link_type)x)-&gt;value_field; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(<span class="built_in">link_type</span>(x)));&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(<span class="built_in">link_type</span>(x)-&gt;color); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最小节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (link_type)  __rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  	<span class="comment">// 最大节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">                                <span class="comment">// accessors:</span></span><br><span class="line">  <span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> key_compare; &#125;</span><br><span class="line">  <span class="comment">// begin() 获取的是最小节点</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leftmost</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leftmost</span>(); &#125;</span><br><span class="line">  <span class="comment">// end() 头节点</span></span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">begin</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node_count == <span class="number">0</span>; &#125;		<span class="comment">// 树为空</span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node_count; &#125;			<span class="comment">// 节点计数</span></span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="元素插入-1"><a href="#元素插入-1" class="headerlink" title="元素插入"></a>元素插入</h3><p>红黑树提供了两种插入方式：insert_unique() 与 insert_equal()。前者表示被插入的键值在整棵树中必须唯一，后者则表示被插入节点的键值可以在整棵树中可以重复。具体源码解析如下：<br>具体源码解析</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::</span><br><span class="line">__insert(base_ptr x_, base_ptr y_, <span class="keyword">const</span> Value&amp; v) &#123;</span><br><span class="line">	<span class="comment">//参数x_为新值插入点，参数y_为插入点之父节点，参数v 为新值</span></span><br><span class="line">  link_type x = (link_type) x_;</span><br><span class="line">  link_type y = (link_type) y_;</span><br><span class="line">  link_type z;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (y == header || x != <span class="number">0</span> || <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(y))) &#123;</span><br><span class="line">    z = <span class="built_in">create_node</span>(v);	<span class="comment">//创建值为v的节点z</span></span><br><span class="line">    <span class="built_in">left</span>(y) = z;                <span class="comment">// also makes leftmost() = z when y == header</span></span><br><span class="line">    <span class="keyword">if</span> (y == header) &#123;</span><br><span class="line">      <span class="built_in">root</span>() = z;</span><br><span class="line">      <span class="built_in">rightmost</span>() = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="built_in">leftmost</span>())<span class="comment">//若y为最左节点</span></span><br><span class="line">      <span class="built_in">leftmost</span>() = z;           <span class="comment">// maintain leftmost() pointing to min node</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    z = <span class="built_in">create_node</span>(v);</span><br><span class="line">    <span class="built_in">right</span>(y) = z;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="built_in">rightmost</span>())</span><br><span class="line">      <span class="built_in">rightmost</span>() = z;          <span class="comment">// maintain rightmost() pointing to max node</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">parent</span>(z) = y;<span class="comment">//设定新节点的父节点</span></span><br><span class="line">  <span class="built_in">left</span>(z) = <span class="number">0</span>;<span class="comment">//设定新节点的左孩子</span></span><br><span class="line">  <span class="built_in">right</span>(z) = <span class="number">0</span>;<span class="comment">//设定新节点的右孩子</span></span><br><span class="line">  __rb_tree_rebalance(z, header-&gt;parent);<span class="comment">//调整RB-Tree使其满足性质</span></span><br><span class="line">  ++node_count;<span class="comment">//节点数增加1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">iterator</span>(z);<span class="comment">//返回新节点迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_equal</span>(<span class="keyword">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  link_type y = header;</span><br><span class="line">  link_type x = <span class="built_in">root</span>();<span class="comment">//从根节点开始</span></span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;<span class="comment">//从根节点开始,往下寻找合适插入点</span></span><br><span class="line">    y = x;</span><br><span class="line">	<span class="comment">//判断新插入节点值与当前节点x值的大小,以便判断往x的左边走还是往右边走</span></span><br><span class="line">    x = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)) ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __insert(x, y, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安插新值；节点键值不允许重复，若重复则安插无效。</span></span><br><span class="line"><span class="comment">// 注意，传回值是个pair，第一元素是个 RB-tree 迭代器，指向新增节点，</span></span><br><span class="line"><span class="comment">// 第二元素表示安插成功与否。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line">pair&lt;<span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator, <span class="keyword">bool</span>&gt;</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_unique</span>(<span class="keyword">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  link_type y = header;</span><br><span class="line">  link_type x = <span class="built_in">root</span>();<span class="comment">//从根节点开始</span></span><br><span class="line">  <span class="keyword">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;<span class="comment">//从根节点开始,往下寻找合适插入点</span></span><br><span class="line">    y = x;</span><br><span class="line">	<span class="comment">//判断新插入节点值与当前节点x值的大小,以便判断往x的左边走还是往右边走</span></span><br><span class="line">    comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x));</span><br><span class="line">    x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//离开while循环之后，y所指即为安插点的父节点，x必为叶子节点</span></span><br><span class="line">  iterator j = <span class="built_in">iterator</span>(y);   <span class="comment">//令迭代器j指向插入节点之父节点y</span></span><br><span class="line">  <span class="keyword">if</span> (comp)</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="built_in">begin</span>()) <span class="comment">//若插入点之父节点为最左节点</span></span><br><span class="line">      <span class="keyword">return</span> pair&lt;iterator,<span class="keyword">bool</span>&gt;(__insert(x, y, v), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//否则(插入点之父节点不在最左节点)</span></span><br><span class="line">      --j;<span class="comment">//调整j</span></span><br><span class="line"> <span class="comment">// 小于新值（表示遇「小」，将安插于右侧）</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node), <span class="built_in">KeyOfValue</span>()(v)))</span><br><span class="line">    <span class="keyword">return</span> pair&lt;iterator,<span class="keyword">bool</span>&gt;(__insert(x, y, v), <span class="literal">true</span>);</span><br><span class="line"> <span class="comment">//若运行到这里，表示键值有重复，不应该插入</span></span><br><span class="line">  <span class="keyword">return</span> pair&lt;iterator,<span class="keyword">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元素搜索"><a href="#元素搜索" class="headerlink" title="元素搜索"></a>元素搜索</h3><p>作为二叉搜索树的红黑树，元素的搜索可是它的拿手好戏。以下是它的源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找RB树中是否有键值为k的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Value</span>, <span class="keyword">class</span> _<span class="title">KeyOfValue</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">Compare</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::const_iterator</span><br><span class="line">_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::<span class="built_in">find</span>(<span class="keyword">const</span> _Key&amp; __k) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  _Link_type __y = _M_header; <span class="comment">/* Last node which is not less than __k. */</span></span><br><span class="line">  _Link_type __x = _M_root(); <span class="comment">/* Current node. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__x != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_M_key_compare(_S_key(__x), __k))<span class="comment">//若k比当前节点x键值小</span></span><br><span class="line">      __y = __x, __x = _S_left(__x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __x = _S_right(__x);</span><br><span class="line">  &#125;</span><br><span class="line">  const_iterator __j = <span class="built_in">const_iterator</span>(__y);</span><br><span class="line">  <span class="keyword">return</span> (__j == <span class="built_in">end</span>() || _M_key_compare(__k, _S_key(__j._M_node))) ?</span><br><span class="line">    <span class="built_in">end</span>() : __j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算RB树中键值为k的节点的个数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Value</span>, <span class="keyword">class</span> _<span class="title">KeyOfValue</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">Compare</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::size_type</span><br><span class="line">_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;</span><br><span class="line">  ::<span class="built_in">count</span>(<span class="keyword">const</span> _Key&amp; __k) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  pair&lt;const_iterator, const_iterator&gt; __p = <span class="built_in">equal_range</span>(__k);</span><br><span class="line">  size_type __n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(__p.first, __p.second, __n);</span><br><span class="line">  <span class="keyword">return</span> __n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="红黑树总结"><a href="#红黑树总结" class="headerlink" title="红黑树总结"></a>红黑树总结</h2><p>优点：<br>&emsp;&emsp;1. 红黑树是效率相对较高的当我们插入和删除数据相对频繁的时候<br>&emsp;&emsp;2. 红黑树是自我平衡的所有操作的复杂度最多是O(logn)<br>&emsp;&emsp;3. 不管怎么变化，只有红黑两个常数</p>
<p>缺点：<br>&emsp;&emsp;由于红黑树并不追求高度平衡，因此搜索效率并没有AVL高</p>
<p>总结：实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
]]></content>
      <categories>
        <category>Read Notes</category>
      </categories>
      <tags>
        <tag>theory</tag>
      </tags>
  </entry>
  <entry>
    <title>The Annotated STL Sources-3</title>
    <url>/2021/The-Annotated-STL-sources-3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常的开发生活中，经常会使用一些STL容器。譬如最常使用的<code>vector</code>容器，在使用时可能仅仅是去调用它拥有的元素操作函数。对于它们背后的数据的扩展、数据的遍历的底层实现操作几乎很少有关心。了解它们底层实现，可以有效的帮助你提升代码的执行效率与编译速度。<br>在STL中，容器被分为两个部分：序列式容器、关联式窗口。序列式容器也是相对来说可能是最常使用的几个STL容器了，它包含的内容见下图：<br><img data-src="https://7894651.xyz/STL4/vector/pic6.png" alt="avatar"></p>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>vector的数据安排以及操作方式与array都十分相似，它们的主要区别就在于空间运用的灵活性。array是静态空间，一旦配置后就无法改变了。vecotr是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新的元素。vector的实现技术，关键在于对空间大小控制与重新配置时数据的移动效率。</p>
<h2 id="vector-基本数据结构"><a href="#vector-基本数据结构" class="headerlink" title="vector 基本数据结构"></a>vector 基本数据结构</h2><p>基本上，STL里的所有容器源码都至少包含了三部分：</p>
<ul>
<li>迭代器：遍历窗口的元素，控制容器空间的边界与元素的移动</li>
<li>构造函数： 满足容器的各种初始化；</li>
<li>属性的获取：比如begin(),end()等；</li>
</ul>
<p>这些内容也可从vector的源码中探寻到:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// vecotr嵌套类型定义</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// vecotr 迭代器定义</span></span><br><span class="line">	<span class="comment">// vector 的迭代器是普通指针</span></span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// simple_alloc是SGI STL的空间配置器</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">	iterator start;	<span class="comment">// 表示目前使用空间的头</span></span><br><span class="line">	iterator finish; <span class="comment">// 表示目前使用空间的尾</span></span><br><span class="line">	iterator end_of_storage; <span class="comment">// 表示目前可用空间的尾</span></span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector-构造与内存管理"><a href="#vector-构造与内存管理" class="headerlink" title="vector 构造与内存管理"></a>vector 构造与内存管理</h2><p>vector为了应对不同的初始化，设有了多个构造函数。有的专门用于初始化头尾与可用空间的尾，有的允许我们指定空间的大小与初值。它们的源码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>() : <span class="built_in">start</span>(<span class="number">0</span>), <span class="built_in">finish</span>(<span class="number">0</span>), <span class="built_in">end_of_storage</span>(<span class="number">0</span>) &#123;&#125;  <span class="comment">// 默认初始化</span></span><br><span class="line">	<span class="built_in">vector</span>(size_type n,<span class="keyword">const</span> T&amp; value) &#123;<span class="built_in">fill_initialize</span>(n,value);&#125;  </span><br><span class="line">	<span class="built_in">vector</span>(<span class="keyword">int</span> n,<span class="keyword">const</span> T&amp; value) &#123;<span class="built_in">fill_initialize</span>(n,value);&#125;</span><br><span class="line">	<span class="built_in">vector</span>(<span class="keyword">long</span> n,<span class="keyword">const</span> T&amp; value) &#123;<span class="built_in">fill_initialize</span>(n,value);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123;<span class="built_in">fill_initialize</span>(n,<span class="built_in">T</span>());&#125;  <span class="comment">// 必须显式的调用构造函数，接受一个值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~<span class="built_in">vector</span>() &#123;</span><br><span class="line">		<span class="built_in">destory</span>(start,finish);</span><br><span class="line">		<span class="built_in">deallocate</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vector构造函数中，缺省使用的是alloc空间配置器，并据此定义了一个data_allocator为了更方便的以元素大小为配置单元。以此为前提，再结合下例中的源码分析。从而探究vector的构造函数的参数初始化与空间分配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受一个大小与初始化值</span></span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123;<span class="built_in">fill_initialize</span>(n,value);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充并初始化</span></span><br><span class="line"><span class="function">vector <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	start = <span class="built_in">allocate_and_fill</span>(n,value);</span><br><span class="line">	finish = start+n;</span><br><span class="line">	end_of_storage = finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置而后填充</span></span><br><span class="line"><span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n,<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">	iterator result = data_allocator::<span class="built_in">allocate</span>(n);</span><br><span class="line">	<span class="built_in">uninitialized_fill_n</span>(result, n, x);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start) &#123;]</span><br><span class="line">		data_allocator::<span class="built_in">deallocate</span>(start,end_of_storage-start);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了<code>uninitialized_fill_n</code>全局函数，它将通过对第一参数的类型是否为POD的判断，从而避免了POD类型对程序性能的拖累。如果是非POD，将在异常处理正确的情况下构造变量。vector的析构是通过直接调用deallocate空间配置器，将区间内对象全部析构且将内存还给空间配置器。</p>
<h2 id="vector-属性获取"><a href="#vector-属性获取" class="headerlink" title="vector 属性获取"></a>vector 属性获取</h2><p>vector的数据结构非常的简单，通过<code>start、finish、end_of_storage</code>就轻松解决了头尾标示、大小、容量以及[]运算符等机能的实现。具体到源码中，基本就是对三个迭代器进行处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 标识头尾</span></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> finish;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 标识长度</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">size_type</span> (<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">	<span class="comment">// 标识容量</span></span><br><span class="line">	<span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_type</span> (end_of_storage - <span class="built_in">begin</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 空容器判断</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123;<span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>();&#125;</span><br><span class="line">	<span class="comment">// []运算子</span></span><br><span class="line">	reference <span class="keyword">operator</span>[] (size_type n) &#123;<span class="keyword">return</span> *(<span class="built_in">begin</span>() + n);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最前端元素</span></span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *<span class="built_in">begin</span>();&#125;</span><br><span class="line">	<span class="comment">// 最后端元素</span></span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>);&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果对源码的表示不存在困惑，可通过下图的案例进行综合的理解<br><img data-src="https://7894651.xyz/STL4/vector/pic.png" alt="avatar"></p>
<h2 id="vector-push与pop"><a href="#vector-push与pop" class="headerlink" title="vector push与pop"></a>vector push与pop</h2><p>vector中<code>push_back()</code>的作用就是将新元素插入vector尾端。不过对于插入，我们需要面对空间配置的问题:<br>&emsp;&emsp;1. 若备用空间充足，则在备用空间上直接构造元素,并调整迭代器finish<br>&emsp;&emsp;2. 如果不够，就扩充空间(重新配置、移动数据、释放空间)<br>push_back在源码中的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (finish != end_of_storage) &#123; <span class="comment">// 仍有备用空间</span></span><br><span class="line">		<span class="built_in">construct</span>(finish, x);</span><br><span class="line">		++finish;					<span class="comment">// 使用后，调整水位高度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);		<span class="comment">// 没有备用空间了，使用insert_aux进行分情况处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在insert_aux()中，它又对是否仍有备用空间进行了一次判断。这样的做法是否合理呢？合理的，因为对于insert_aux，不仅只有push_back会调用它，还有其它的函数会调用它。具体到源码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">	<span class="keyword">if</span> (finish != end_of_storage) &#123;		<span class="comment">// 仍有备用空间</span></span><br><span class="line">		<span class="comment">// 在备用空间起始处构造一个元素,并以vector最后一个元素值为其初值</span></span><br><span class="line">		<span class="built_in">construct</span>(finish, *(finish<span class="number">-1</span>));</span><br><span class="line">		<span class="comment">// 调整水位</span></span><br><span class="line">		++finish;</span><br><span class="line">		T x_copy =x;</span><br><span class="line">		<span class="built_in">copy_backward</span>(position, finish<span class="number">-2</span>,finish<span class="number">-1</span>);</span><br><span class="line">		*position = x_copy;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当真的等到备用空间不足时，我们需要根据配置原则合理分配空间: 如果原大小为0，则配置1(个元素大小);如果原大小不为0，则配置原大小的两倍;前半段用来放置原数据，后半段准备用来放置新数据;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">else</span> &#123;		</span><br><span class="line">		<span class="comment">// 已无备用空间</span></span><br><span class="line">		<span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 以上配置原则：如果原大小0，则配置1(个元素大小)</span></span><br><span class="line">		<span class="comment">// 如果原大小不为0，则配置原大小的两倍</span></span><br><span class="line">		<span class="comment">// 前半段用来放置原数据，后半段准备用来放置新数据</span></span><br><span class="line"></span><br><span class="line">		iterator new_start = data_allocator::<span class="built_in">allocate</span>(len); </span><br><span class="line">		iterator new_finish = new_start;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 将原vector的内容拷贝到新vector</span></span><br><span class="line">			new_finish = <span class="built_in">uninitialized_copy</span>(start,position,new_start);</span><br><span class="line">			<span class="comment">// 为新元素设定实值x</span></span><br><span class="line">			<span class="built_in">construct</span>(new_finish, x);</span><br><span class="line">			<span class="comment">// 调整水位</span></span><br><span class="line">			++new_finish;</span><br><span class="line">			<span class="comment">// 将安插点的原内容也拷贝过来(提示：本函数也可能被insert(p,x)调用)</span></span><br><span class="line">			new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">			<span class="built_in">destroy</span> (new_start, new_finish);</span><br><span class="line">			data_allocator::<span class="built_in">deallocate</span>(new_start,len);</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 析构并释放原vector</span></span><br><span class="line">		<span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">deallocate</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调整迭代器，指向新的vector</span></span><br><span class="line">		start = new_start;</span><br><span class="line">		finish = new_finish;</span><br><span class="line">		end_of_storage = new_start + len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://7894651.xyz/STL4/vector/pic1.png" alt="avatar"></p>
<p>pop_back的作用就是将尾端元素析构掉，并适当的调整大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	--finish;</span><br><span class="line">	<span class="built_in">destroy</span>(finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector-元素删除erase"><a href="#vector-元素删除erase" class="headerlink" title="vector 元素删除erase()"></a>vector 元素删除erase()</h2><p>在vector中提供了两个版本的erase(),一个用于清除[first,last)中的所有元素，一个用于清除某个位置上的元素。earse()就是将要删除的元素后面的内容复制到前面，然后再删除要删除的元素，并调整迭代器finish。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清除[first,last)中的所有元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator first,iterator last)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 将[last,finish)内容复制到区间[first,first+(last-finish))	</span></span><br><span class="line">	iterator i = <span class="built_in">copy</span>(last, finish, first);</span><br><span class="line">	<span class="built_in">destroy</span>(i,finish);  <span class="comment">// 释放[i,finish)区间内存</span></span><br><span class="line">	finish = finish - (last - finish); <span class="comment">// 调整迭代器finish位置</span></span><br><span class="line">	<span class="keyword">return</span> first; <span class="comment">// 迭代器并没有改变，改变的是内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除某个位置上的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (position + <span class="number">1</span> != <span class="built_in">end</span>()) &#123;</span><br><span class="line">		<span class="comment">// 将[position+1,finish)内容复制到区间[position,position+(position+1-finish))</span></span><br><span class="line">		<span class="built_in">copy</span>(position+<span class="number">1</span>, finish,position);</span><br><span class="line">	&#125;</span><br><span class="line">	--finish;</span><br><span class="line">	<span class="built_in">destroy</span>(finish);</span><br><span class="line">	<span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>STL中的clear就是通过调用<code>erase(begin(),end());</code>实现的，earse(first,end);操作过程如下图所示：</p>
<p><img data-src="https://7894651.xyz/STL4/vector/pic2.png" alt="avatar"></p>
<h2 id="vector-元素插入insert"><a href="#vector-元素插入insert" class="headerlink" title="vector 元素插入insert()"></a>vector 元素插入insert()</h2><p>vector元素插入就涉及到了内存空间的配置，我们将它们的情况分成了三种进行分析：<br>&emsp;&emsp; 1. 插入点之后的现有元素个数 &gt; 新增元素个数<br><img data-src="https://7894651.xyz/STL4/vector/pic3.png" alt="avatar"></p>
<p>&emsp;&emsp; 2. 插入点之后的现有元素个数 &lt;= 新增元素个数<br><img data-src="https://7894651.xyz/STL4/vector/pic4.png" alt="avatar"></p>
<p>&emsp;&emsp; 3. 如果备用空间不足时<br><img data-src="https://7894651.xyz/STL4/vector/pic5.png" alt="avatar"></p>
<h2 id="vector-迭代器失效"><a href="#vector-迭代器失效" class="headerlink" title="vector 迭代器失效"></a>vector 迭代器失效</h2><p>由于迭代器是连续动态内存的封装，对于vector迭代器来说仅仅是一个普通的原生指针。对于以下两种操作都会导致迭代器失效：<br>&emsp;&emsp; 1. 元素删除： vector为了保证元素的连续排列，需要将vector的删除元素之后的元素向前移动。<br>&emsp;&emsp; 2. 元素插入： 当vector的备用空间不足时，它将重新申请更大的内存，之后将对应的元素拷贝过去。<br>这样的操作之后就会导致一个问题：指针将所指向的内存将不再存储对应的vector元素。</p>
<h2 id="vector-优缺点总结"><a href="#vector-优缺点总结" class="headerlink" title="vector 优缺点总结"></a>vector 优缺点总结</h2><p>最后还需要提醒的一点是：vector的成员函数是都不会去做边界检查(at会抛出异常)，在编写程序时应保证迭代器与索引值的合法性。<br>我们一起来总结一下vector的的优缺点:<br><font color=red>优点</font><br>&emsp;&emsp;1. 在内存中是一块连续内存的内存空间进行存储，可以像数组一样的操作，并且支持动态扩容。<br>&emsp;&emsp;2. 因此元素的随机的访问方便，支持下标访问与vector.at()操作。<br>&emsp;&emsp;3. 节省空间<br><font color=blue>缺点</font><br>&emsp;&emsp;1. 由于vector的顺序存储的结构特性，vector的插入与删除的时间复杂复为O(n)<br>&emsp;&emsp;2. vector的pop与push仅可在末端进行<br>&emsp;&emsp;3. 当插入长度过大时，需要重新的分配、拷贝与释放</p>
<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>相对于vecotr的连续线性空间，作为SGI STL中的双向链表list就显得复杂许多。但是复杂的list对于空间的配置堪称绝妙，每插入一个元素或删除一个元素就对应的配置或释放一个元素空间。因而list对于数据的插入与删除的时间复杂度永远都是O(1)。相对于vector，它更适合大量数据的插入与删除的环境中使用。</p>
<h2 id="list-数据结构——节点"><a href="#list-数据结构——节点" class="headerlink" title="list 数据结构——节点"></a>list 数据结构——节点</h2><p>一个list通常采用的都是分开设计，对于使用或设计过list的同学这几乎算是一个通识了。但是为何需要分开设计呢？其实节点指针只是为迭代器提供便利，在使用迭代器遍历时根本无需使用到list的数据成员。它的节点大致如下图所示：</p>
<p><img data-src="https://7894651.xyz/STL4/list/pic.png" alt="avatar"></p>
<p>它的源码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">  void_pointer next;</span><br><span class="line">  void_pointer prev;</span><br><span class="line">  T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="list-数据结构－迭代器"><a href="#list-数据结构－迭代器" class="headerlink" title="list 数据结构－迭代器"></a>list 数据结构－迭代器</h2><p>相对于vector线性存储是使用的内存中一块连续区域，list则无法保证节点在内存中的连续。因此，对于list的迭代器的就必须要正确的指向每一个节点。并且可以保证正确的递增、递减、取值与成员操作等。list本身还是一个双向链表，因而它还必须具备前移、后移的能力。<br>所以list节点与迭代器结合就形成了list的主体，它的样子大致如下：</p>
<p><img data-src="https://7894651.xyz/STL4/list/pic1.png" alt="avatar"></p>
<h3 id="迭代器——基本类型"><a href="#迭代器——基本类型" class="headerlink" title="迭代器——基本类型"></a>迭代器——基本类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt;           self;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// list的迭代器类型是bidirectional iterator</span></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器——构造函数"><a href="#迭代器——构造函数" class="headerlink" title="迭代器——构造函数"></a>迭代器——构造函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span> <span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 定义节点指针</span></span><br><span class="line">  	<span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">  	link_type node;</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">  	__list_iterator(link_type x) : <span class="built_in">node</span>(x) &#123;&#125;</span><br><span class="line">  	__list_iterator() &#123;&#125;</span><br><span class="line">  	__list_iterator(<span class="keyword">const</span> iterator&amp; x) : <span class="built_in">node</span>(x.node) &#123;&#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器——重载"><a href="#迭代器——重载" class="headerlink" title="迭代器——重载"></a>迭代器——重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span> <span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 重载</span></span><br><span class="line">  	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">  	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line">    <span class="comment">// 对*和-&gt;操作符进行重载</span></span><br><span class="line">  	reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  	pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++和--是直接操作的指针指向next还是prev, 因为list是一个双向链表</span></span><br><span class="line">  	self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">	    node = (link_type)((*node).next);</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	    ++*<span class="keyword">this</span>;</span><br><span class="line">	    <span class="keyword">return</span> tmp;</span><br><span class="line">  	&#125;</span><br><span class="line">  	self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">    &#123;</span><br><span class="line">	    node = (link_type)((*node).prev);</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	self <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    	--*<span class="keyword">this</span>;</span><br><span class="line">    	<span class="keyword">return</span> tmp;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="list-基本数据结构"><a href="#list-基本数据结构" class="headerlink" title="list 基本数据结构"></a>list 基本数据结构</h2><p>list 自己定义了嵌套类型满足traits编程，list的迭代器类型是bidirectional_iterator_tag类型，并不是一个普通的指针。它的主体结构如下图所示：<br><img data-src="https://7894651.xyz/STL4/list/pic2.png" alt="avatar"></p>
<h2 id="list-构造与析构"><a href="#list-构造与析构" class="headerlink" title="list 构造与析构"></a>list 构造与析构</h2><p>list提供了多个构造函数，其中主要的两类就是：配置n个节点空间、空链表。它们的构造过程如下图所示：<br><img data-src="https://7894651.xyz/STL4/list/pic3.png" alt="avatar"></p>
<h2 id="list-基本元素获取"><a href="#list-基本元素获取" class="headerlink" title="list 基本元素获取"></a>list 基本元素获取</h2><p>在了解了对象构造与析构的基础上，我们再继续深入list的基本元素操作有获取头尾、判断链表为空等元素操作。它所包括的基本操作如下所示：<br><img data-src="https://7894651.xyz/STL4/list/pic4.png" alt="avatar"></p>
<h2 id="list-元素操作"><a href="#list-元素操作" class="headerlink" title="list 元素操作"></a>list 元素操作</h2><p>list所提供的元素操作很多，无法在有限的篇幅中详细讲解。在这里将着重讲解以下几个元素操作：push_front、push_back、pop_front、pop_back。这此包括了元素的插入与删除的基本操作，其它的操作可自行阅读源码进行深入理解。</p>
<h3 id="list-元素操作——插入"><a href="#list-元素操作——插入" class="headerlink" title="list 元素操作——插入"></a>list 元素操作——插入</h3><p>在list中，经常使用push_back()与push_front()实现头部插入与尾部插入,其实现大多是通过调用insert()函数来实现这一功能的。在此，仅介绍一种insert的简单形式，通过它来一窥双链表中的头插与尾插。<br><img data-src="https://7894651.xyz/STL4/list/pic6.png" alt="avatar"></p>
<h3 id="list-元素操作——删除"><a href="#list-元素操作——删除" class="headerlink" title="list 元素操作——删除"></a>list 元素操作——删除</h3><p>对应push_back()与push_front()，它们的删除操作是由pop_back()与pop_front()来管理的。其实实现就是通过对prev、next移动来实现。<br><img data-src="https://7894651.xyz/STL4/list/pic8.png" alt="avatar"></p>
<h2 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h2><p>在list迭代器中，插入与接合操作均不会造成原有的list迭代器失效。当然，如果earse()会导致迭代器失效，不过仅限于当前这个节点,其余的迭代器均不受影响。</p>
<h2 id="list-优缺点总结"><a href="#list-优缺点总结" class="headerlink" title="list 优缺点总结"></a>list 优缺点总结</h2><p>list是一个双向链表,因为其具有链表的特性，在仅需一些指针操作时，应尽可能的使用list成员函数<br><strong>优点</strong><br>&emsp;&emsp; * 插入删除元素效率很高<br>&emsp;&emsp; * 可在两端进行数据进行操作</p>
<p><strong>缺点</strong><br>&emsp;&emsp; * 不支持随机访问<br>&emsp;&emsp; * 相对于vector占用内存过多</p>
<h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p>vector 是单向开口的连续线性空间,对应的deque则是一个双向开口的线性空间。双向开口的意思是deque的两端皆可以做插入与删除操作，deque大致描述图：<br><img data-src="https://7894651.xyz/STL4/deque/pic.png" alt="avatar"><br>deque相对于vector不同点还在于，它并没有所谓的容量的一个概念,原因是它是动态的以分段连续空间组合而成的。deque也提供随机访问迭代器，不过它的设计不同于vector以普通指针的迭代器。它的迭代器也直接影响了deque算法的效率，因此非必要则最好使用vector代替deque。具体个中的奥妙，静看源码剖析。</p>
<h2 id="deque中控器"><a href="#deque中控器" class="headerlink" title="deque中控器"></a>deque中控器</h2><p>deque是连续空间(至少逻辑上来看是这样的),内部也是由一段一段的连续空间构成，一旦有必要在deuqe前端或尾端增加新空间，便配置一段宣连续空间，串接在整个deque的头端或尾端。对于这一段一段的空间，如何使它成为一段连续的空间。维护整体空间连续的假象，同时还要避免与vector(重新配置、移动数据、释放空间)的复杂操作呢？这里STL提供是办法是设计一个复杂的迭代器。<br>作为算法与容器的粘合剂，为了更好的实现效果，deque 数据结构的设计和迭代器前进或后退等操作都非常复杂。deque采用一块所谓的map(非stlmap容器),其实就是就是一块小的连续空间，其中的每个元素都是指针，指向另外一段较大的连续线性空间，称之为<strong>缓冲区</strong>。在之后的内容中，你就可以了解到缓冲区才是deque的依存空间主体。SGI STL允许我们指定缓冲区大小，默认值为0表示将使用512bytes缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> pointer** map_pointer;</span><br><span class="line">  map_pointer map;<span class="comment">//指向 map，map 是连续空间，其内的每个元素都是一个指针。</span></span><br><span class="line">  size_type map_size;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>deque的结构设计示例图，map 与node-buffer的关系：<br><img data-src="https://7894651.xyz/STL4/deque/pic1.png" alt="avatar"></p>
<h2 id="deque-迭代器"><a href="#deque-迭代器" class="headerlink" title="deque 迭代器"></a>deque 迭代器</h2><p>deque 是分段连续空间，维持其”整体连续”假象的任务，就靠它的迭代器来实现，也就是operator++与operator–两个运算子上面。在解析源码之前，可以思考一下，你所认为的deque的结构该是什么样子的？<br>首先，对于分段连续，迭代器就应该指出它的这个空间在什么位置。其次，由于缓冲区是存在边界的，迭代器还应该判断，当前是否处于所在缓冲区的边缘，如果是，下面一步的前进或是后退就必须跳转到下一个或上一个缓冲区。最后还有一个关键点：对应前面两种情况，迭代器必须随时都可以掌控中控器。基于这些分析，再来看源码，就相对轻松一些。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(T)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// deque是random_access_tag类型 </span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="comment">// 基本类型定义，满足traits编程</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 三个迭代器类型</span></span><br><span class="line">  T* cur;  <span class="comment">// 迭代器所指缓冲区中的当前(current)元素</span></span><br><span class="line">  T* first; <span class="comment">// 此迭代器所指的缓冲区的头</span></span><br><span class="line">  T* last; <span class="comment">// 此迭代器所指的缓冲区的尾(含有备用空间)</span></span><br><span class="line">  map_pointer node;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>deque的中控器、缓冲区、迭代器的相互关系如下图所示：<br><img data-src="https://7894651.xyz/STL4/deque/pic2.png" alt="avatar"></p>
<p>每一段都指向一个缓冲区buffer，而缓冲区是需要知道每个元素的位置的，所以需要这些迭代器去访问。这样就十分方便管理，需要注意的是deque的空间是由map管理的，它是一个指向指针的指针，所以三个参数都是指向当前的数组。但是这样的数组可能有多个，只是每个数组都管理这三个变量。<br>之前在deque实现的差不多了，我们还有一个问题存在——缓冲区的大小由谁来决定？在SGI STL提供了一个全局函数来解决这个问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz): <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果 n 不为0，则返回 n，表示缓冲区大小由用户自定义</span></span><br><span class="line"><span class="comment">//如果 n == 0，表示 缓冲区大小默认值</span></span><br><span class="line"><span class="comment">//如果 sz = (元素大小 sizeof(value_type)) 小于 512 则返回 521/sz</span></span><br><span class="line"><span class="comment">//如果 sz 不小于 512 则返回 1</span></span><br></pre></td></tr></table></figure>
<p>如果对这个全局函数存在困惑，可通过下面这个例子与图进行一个较为深入的理解。<br>假设我们产生一个元素类型为int，缓冲区大小为8(个)元素大小的deque(总大小为32)。经过一番操作后，deque现在在20个元素，那么成员函数begin()与end()返回的两个迭代器应该是怎样的？<br>如下图所示：<br><img data-src="https://7894651.xyz/STL4/deque/pic3.png" alt="avatar"></p>
<p>20个元素需要20/(sizeof(int)) = 3 个缓冲区。<br>所以map运用了三个节点，迭代器start内的cur指针指向缓冲区的第一个元素，迭代器finish内的指针指向缓冲区的最后一个元素(的下一个位置)。<br><font color=red>注意：如果最后一个缓冲区尚有备用空间，那么之后若仍有新元素插入，则直接插入到备用空间之中。</font></p>
<h2 id="deque-迭代器操作"><a href="#deque-迭代器操作" class="headerlink" title="deque 迭代器操作"></a>deque 迭代器操作</h2><p>主要操作：前进与后退<br>operator++操作代表需要切换到下一个元素，这里需要先切换再判断是否已经到达缓冲区的末尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">  ++cur;      <span class="comment">//切换至下一个元素</span></span><br><span class="line">  <span class="keyword">if</span> (cur == last) &#123;   <span class="comment">//如果已经到达所在缓冲区的末尾</span></span><br><span class="line">     <span class="built_in">set_node</span>(node+<span class="number">1</span>);  <span class="comment">//切换下一个节点</span></span><br><span class="line">     cur = first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>operator– 操作代表需要切换到上一个元素所在的位置，需要先判断是否到达缓冲区的头部，再后退。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">  <span class="keyword">if</span> (cur == first) &#123;    <span class="comment">//如果已经到达所在缓冲区的头部</span></span><br><span class="line">     <span class="built_in">set_node</span>(node - <span class="number">1</span>); <span class="comment">//切换前一个节点的最后一个元素</span></span><br><span class="line">     cur = last;</span><br><span class="line">  &#125;</span><br><span class="line">  --cur;       <span class="comment">//切换前一个元素</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;  <span class="comment">//结合前面的分段连续空间，你在想一想这样的设计是不是合理呢？</span></span><br></pre></td></tr></table></figure>

<h2 id="deque-构造与析构函数"><a href="#deque-构造与析构函数" class="headerlink" title="deque 构造与析构函数"></a>deque 构造与析构函数</h2><p>deque的构造函数有多个重载函数，接受大部分不同的参数类型，基本上每一个构造函数都会调用create_map_and_nodes,这就是构造函数的核心，之后会对这个函数进行一个具体的分析。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic types</span></span><br><span class="line">  <span class="built_in">deque</span>() : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;  <span class="comment">// 默认构造函数</span></span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">const</span> deque&amp; x) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(x.<span class="built_in">size</span>());</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">uninitialized_copy</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), start);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_map_and_nodes</span>());</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 接受 n:初始化大小, value:初始化的值</span></span><br><span class="line">  <span class="built_in">deque</span>(size_type n, <span class="keyword">const</span> value_type&amp; value) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> value_type&amp; value) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> value_type&amp; value) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>在剖析完deque的构造函数后，再来了解一下deque都会调用的中控器(create_map_and_nodes)的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> deque&lt;T,Alloc,BufSize&gt;::<span class="built_in">create_map_and_nodes</span>(size_type_num_elements) &#123;</span><br><span class="line">  <span class="comment">//需要节点数= (每个元素/每个缓冲区可容纳的元素个数+1)</span></span><br><span class="line">  <span class="comment">//如果刚好整除，多配一个节点</span></span><br><span class="line">  size_type num_nodes = num_elements / <span class="built_in">buffer_size</span>() + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//一个 map 要管理几个节点，最少 8 个，最多是需要节点数+2</span></span><br><span class="line">  map_size = <span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(), num_nodes + <span class="number">2</span>);</span><br><span class="line">  map = map_allocator::<span class="built_in">allocate</span>(map_size);</span><br><span class="line"> <span class="comment">// 计算出数组的头前面留出来的位置保存并在nstart.</span></span><br><span class="line">  map_pointer nstart = map + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">  map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line">  map_pointer cur;<span class="comment">//指向所拥有的节点的最中央位置</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码之下，了无秘密。通过构造函数，我们可以得知<strong>deque的begin与end不是一开始就指向map中控器的开头与结尾，而是指向所拥有的节点的最中央的位置。</strong></p>
<p>这样所带来的好处就是可以使得头尾两边扩充可能性和一样大，因为deque头插与尾插都是O(1)，所以deque在头与尾都留有空间方便头尾插入。</p>
<p>那么map中控器本身何时需要重新调整大小呢？触发条件在于reserve_map_at_back与reserve_map_at_front这两个函数来判断，实现操作由reallocate_map来执行。<br>map调整的实现如下面两个函数所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 map 尾端的节点备用空间不足，符合条件就配置一个新的map(配置更大的，拷贝原来的，释放原来的)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - map))</span><br><span class="line">    <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 map 前端的节点备用空间不足，符合条件就配置一个新的map(配置更大的，拷贝原来的，释放原来的)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nodes_to_add &gt; start.node - map)</span><br><span class="line">    <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="deque-插入与删除"><a href="#deque-插入与删除" class="headerlink" title="deque 插入与删除"></a>deque 插入与删除</h2><p>因为deque是双向的操作，所以push与pop操作都类似于list可以直接有对应的操作。不过需要注意的是list链表，并不会涉及到边界的判，而deque是由数组来存储的，就需要随时对界线进行判断。</p>
<h3 id="push与pop实现"><a href="#push与pop实现" class="headerlink" title="push与pop实现"></a>push与pop实现</h3><p>push 实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// push_* and pop_*</span></span><br><span class="line">    <span class="comment">// 对尾进行插入</span></span><br><span class="line">    <span class="comment">// 判断函数是否达到了数组尾部. 没有达到就直接进行插入</span></span><br><span class="line">  <span class="keyword">void</span> <span class="built_in">push_back</span>(<span class="keyword">const</span> value_type&amp; t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(finish.cur, t);</span><br><span class="line">      ++finish.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">push_back_aux</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 对头进行插入</span></span><br><span class="line">    <span class="comment">// 判断函数是否达到了数组头部. 没有达到就直接进行插入</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.first) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(start.cur - <span class="number">1</span>, t);</span><br><span class="line">      --start.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">push_front_aux</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pop实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// 对尾部进行操作</span></span><br><span class="line">    <span class="comment">// 判断是否达到数组的头部. 没有到达就直接释放</span></span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">pop_back</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.first) &#123;</span><br><span class="line">      --finish.cur;</span><br><span class="line">      <span class="built_in">destroy</span>(finish.cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">pop_back_aux</span>();</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 对头部进行操作</span></span><br><span class="line">    <span class="comment">// 判断是否达到数组的尾部. 没有到达就直接释放</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">destroy</span>(start.cur);</span><br><span class="line">      ++start.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">pop_front_aux</span>();</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pop与push都先调用了reserve_map_at_XX函数，这些函数主要是为了判断前后空间是否足够。</p>
<h3 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h3><p>回想deque的构造函数，我们使用调用了中控器(create_map_and_nodes)函数。这样保证了前后都留有空间，所以push与pop皆可以在前面的数组中进行操作。<br>现在对于删除操作erase,因为deque是由数组构成，所以地址空间是连续，删除因此也需要像vector一样移到所有元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// erase</span></span><br><span class="line">  iterator <span class="built_in">erase</span>(iterator pos) &#123;</span><br><span class="line">    iterator next = pos;</span><br><span class="line">    ++next;</span><br><span class="line">    difference_type index = pos - start;</span><br><span class="line">      <span class="comment">// 删除的地方是中间偏前, 移动前面的元素</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="built_in">copy_backward</span>(start, pos, next);</span><br><span class="line">      <span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 删除的地方是中间偏后, 移动后面的元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">copy</span>(next, finish, pos);</span><br><span class="line">      <span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + index;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 范围删除, 实际也是调用上面的erase函数.</span></span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>对于insert函数的解析：deque的insert函数都调用了insert_auto判断插入的位置离头还是离尾近。<br>如果离头近：则先将头向前移动，调整将要移动的距离，用copy进行调整。<br>如果离尾近:则将尾往前移动，调整将要移动的距离，用copy进行一个调整。<br>注意：push_back是先执行构造再移动node，而push_front是先移动node在进行构造，实现的差异主要是finish是指向最后一个元素的后一个地址而first指向的就只有第一个元素的地址，对于pop也是同理。</p>
<h3 id="其余元素操作"><a href="#其余元素操作" class="headerlink" title="其余元素操作"></a>其余元素操作</h3><p>reallocate_map：判断中控器的容量是否够用，如果不够用，申请更大的空间，拷贝元素过去，修改 map 和 start，finish 的指向。</p>
<p>fill_initialize 函数：申请空间，对每个空间进行初始化，最后一个数组单独处理。毕竟最后一个数组一般不是会全部填充满。</p>
<p>clear 函数：删除所有元素，分两步执行：</p>
<p>首先从第二个数组开始到倒数第二个数组一次性全部删除，这样做是考虑到中间的数组肯定都是满的，前后两个数组就不一定是填充满的，最后删除前后两个数组的元素。</p>
<p>deque 的 swap 操作：只是交换了 start, finish, map，并没有交换所有的元素。</p>
<p>resize 函数： 重新将 deque 进行调整, 实现与 list一样的。</p>
<p>析构函数： 分步释放内存。</p>
<h2 id="deque-迭代器失效"><a href="#deque-迭代器失效" class="headerlink" title="deque 迭代器失效"></a>deque 迭代器失效</h2><p>除了首尾的插入与删除操作不会对deque迭代器造成影响。因为这些操作都不会对现有的元素进行移动，如果一个分段数组满了。仅需创建亲的分段数组，并把对应的分段数组加入索引数组中就可以了。删除其实也是大致的意思，均不会对现有元素作移到操作。<br>但是除了这些操作，其它的插入与删除均会导致deque元素的任何pointers、reference、iterators失效。不过，效率相对于vector会好一些，毕竟不需要复制所有的元素。</p>
<h2 id="deque-总结"><a href="#deque-总结" class="headerlink" title="deque 总结"></a>deque 总结</h2><p>deque 其实就是在功能上合并了vector与list</p>
<p>优点：<br>&emsp;&emsp;1. 随机访问方便，即支持[]操作符与vector.at();<br>&emsp;&emsp;2. 在内部方便的进行插入与删除操作<br>&emsp;&emsp;3. 可在两端进行push、pop</p>
<p>缺点：因为设计比较复杂，采用分段连续空间，所以相对的占用空间会更多。</p>
<h2 id="使用区别"><a href="#使用区别" class="headerlink" title="使用区别"></a>使用区别</h2><ol>
<li>如果你需要高效的随机存取，而不在乎插入与删除的效率，使用vector</li>
<li>如果你需要大量的插入与删除，并不关心随机存取，则应该使用list</li>
<li>如果你随机存取，而且关心两端数据的插入与删除，则应该使用deque</li>
</ol>
<h1 id="stack-And-queue"><a href="#stack-And-queue" class="headerlink" title="stack And queue"></a>stack And queue</h1><p><strong>以deque为底部容器的适配器</strong><br>最后的要介绍的这三种容器，准确来说其实是一种适配器(就是通过将不适用的序列式容器变得适用)<br><strong>栈——stack</strong>: 先入后出，只允许在栈顶添加与删除元素，称为出栈与入栈。<br><img data-src="https://7894651.xyz/STL4/StackAndQueue/pic.png" alt="avatar"><br><strong>队列——queue</strong>: 先入先出，在队首取元素，在队尾添加元素，称为出队与入队。<br><img data-src="https://7894651.xyz/STL4/StackAndQueue/pic1.png" alt="avatar"><br><strong>优先队列</strong>: 带权值的队列。</p>
<p>常见的队列的应用场景包括计算机系统中的各种资源管理，消息缓冲队列的管理与广度优先遍历BFS等。在stack与queue的底层其实都是使用deque容器作为它们的底层数据结构。</p>
<p>信赖于deque的stack与queue的实现，就变得十分容易，具体到源码可见：</p>
<h2 id="stack-源码"><a href="#stack-源码" class="headerlink" title="stack 源码"></a>stack 源码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> deque&lt;T&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;</span><br></pre></td></tr></table></figure>

<h2 id="queue源码"><a href="#queue源码" class="headerlink" title="queue源码"></a>queue源码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> deque&lt;T&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;</span><br></pre></td></tr></table></figure>

<h1 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h1><p>heap 并不归属于STL容器组件之中，它的没有一个实现自己的迭代器，同时也没有遍历操作。准确来说，它只算是一种算法。</p>
<h2 id="push-heap插入元素"><a href="#push-heap插入元素" class="headerlink" title="push_heap插入元素"></a>push_heap插入元素</h2><p>插入函数是push_heap,heap仅接受RandomAccessIterator类型的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  __push_heap_aux(first, last, <span class="built_in">distance_type</span>(first), <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Distance*, T*) &#123;</span><br><span class="line">    <span class="comment">// 这里传入的是两个迭代器的长度, 0, 还有最后一个数据</span></span><br><span class="line">  __push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>),  <span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pop-heap-删除元素"><a href="#pop-heap-删除元素" class="headerlink" title="pop_heap 删除元素"></a>pop_heap 删除元素</h2><p>pop操作其实并没有真正意义去凹陷数据，而是将数据放在最后，只是没有指向最后的元素而已，这里使用array也可以，毕竟没有对数据的大小进行调整。<br>pop的实现有两种，这里都罗列了出来，另一个传入的是cmp仿函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Compare comp)</span> </span>&#123;</span><br><span class="line">    __pop_heap_aux(first, last, <span class="built_in">value_type</span>(first), comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap_aux(RandomAccessIterator first,</span><br><span class="line">                           RandomAccessIterator last, T*, Compare comp) &#123;</span><br><span class="line">  __pop_heap(first, last - <span class="number">1</span>, last - <span class="number">1</span>, <span class="built_in">T</span>(*(last - <span class="number">1</span>)), comp,</span><br><span class="line">             <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">                       RandomAccessIterator result, T value, Compare comp,</span><br><span class="line">                       Distance*) &#123;</span><br><span class="line">  *result = *first;</span><br><span class="line">  __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value, comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">                       RandomAccessIterator result, T value, Distance*) &#123;</span><br><span class="line">  *result = *first; <span class="comment">// 因为这里是大根堆, 所以first的值就是最大值, 先将最大值保存.</span></span><br><span class="line">  __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h2><p>将数组变成堆存放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  __make_heap(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,</span><br><span class="line">                 Distance*) &#123;</span><br><span class="line">  <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 计算长度, 并找出中间的根值</span></span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance parent = (len - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 一个个进行调整, 放到后面</span></span><br><span class="line">    __adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent)));</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    parent--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h2><p>堆排序：其实就是每次将第一位数据弹出从而实现排序功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>) <span class="built_in">pop_heap</span>(first, last--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">               Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>) <span class="built_in">pop_heap</span>(first, last--, comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>最后我们来看一下priority_queue<br>上一节分析heap，其实就是为priority_queue做准备，priority_queue是一个优先级队列。是带权值的，支持插入与删除操作，其只能从尾部插入，头部删除，并且它的顺序也并非是根据加入的顺序排列的。<br>priority_queue 因为也是队列的一种体现，所以也就跟队列一样不能直接的遍历数组，也就没有迭代器。<br>priority_queue 本身也不算是一个容器，它是<strong>以vector为容器以heap为数据操作的配置器。</strong></p>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> vector&lt;T&gt;, </span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">priority_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// 符合traits编程规范</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c; <span class="comment">// 定义vector容器的对象</span></span><br><span class="line">  Compare comp; <span class="comment">// 定义比较函数(伪函数)</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h2><p>priority_queue 只有简单的3个属性获取的函数，其本身的操作也很简单，只是实现依赖了vector与heap就变得比较复杂。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">priority_queue</span> &#123;</span></span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="push与pop实现-1"><a href="#push与pop实现-1" class="headerlink" title="push与pop实现"></a>push与pop实现</h2><p>push与pop本身实现是很复杂的，但是将其剖析开，就是vector与heap的组合。将vector作为容器，heap作为算法来操作的配置器。这样同样的显示出了STL的灵活性：通过各个容器与算法的结合就能实现另一种功能。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在实际的使用中，为了避免拷贝的开销。还是还要直接把大的对象直接往里存放，而是使用指针来替代。</p>
]]></content>
      <categories>
        <category>Read Notes</category>
      </categories>
      <tags>
        <tag>theory</tag>
      </tags>
  </entry>
  <entry>
    <title>The Annotated STL Sources-1</title>
    <url>/2021/The_Annotated_STL_Sources/</url>
    <content><![CDATA[<h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>&emsp;&emsp;在深入探索今天的内容前，你可以在心中思考思考下列问题：</p>
<ul>
<li>当你调用new与delete时编译器底层的做了什么事情?</li>
<li>STL 各大容器底层空间配置器是什么样子的?</li>
<li>STL 的到底需要做什么样的实现?</li>
<li>什么是内存池及它的实现是怎样的？</li>
<li>…</li>
</ul>
<h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><p>&emsp;&emsp;在深入空间配置器前，我觉得我们还是有必要先了解一下STL的基础知识<br>&emsp;&emsp;STL仅仅是一个标准，内部实现是没有任何要求的。因此导致STL存在许多的实现版本,PJ STL(被Visual C++)所采用。我们所学习的SGI STL版本注释丰富、结构清晰、可读性最强，所以最后被GCC所采用，同时也是最流行的版本。STL主要有六大组件来支撑着，它们是：</p>
<ul>
<li>配置器(allocator): 为容器提供空间配置与释放，对象的构造与析构的服务,也是一个class template。</li>
<li>容器(containers): 常用的数据结构，大致分为两种序列容器与关联容器。在实现上是类模板。</li>
<li>迭代器(iterator): 一套访问容器的接口，行为类似于指针。它为不同的算法提供相对统一的容器访问方式，便利设计算法时无需过多关心数据。</li>
<li>算法(algorithms): 提供一套常用的算法，如<code>sort、search、copy、erase ...</code>。在实现上，可以认为是一种函数模板。</li>
<li>仿函数(functor): 作为函数使用的对象，用于泛化算法中的操作。</li>
<li>配接器(adapter): 将一种容器修饰为不同的另一种容器。<br>&emsp;&emsp;大致关系如下图所示<br><img data-src="https://7894651.xyz/effective/pic.png" alt="avatar"></li>
</ul>
<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><p>&emsp;&emsp;从STL使用的角度来说，空间配置器是最不需要介绍的东西。因为它们早已被容器封装好了，在一切组件后默默付出。但是从实用角度来说，若是不了解STL的空间配置器，无异于空中楼阁，在阅读其它STL实现时都会遇到困难。</p>
<h2 id="专属配置器"><a href="#专属配置器" class="headerlink" title="专属配置器"></a>专属配置器</h2><p>&emsp;&emsp;对于SGI STL来说，很多的项目早已脱离了STL标准规格。因此，SGI STL使用了一个专属的、拥有次层配置(sub-allocation)能力的、效率卓越的特殊配置器的<code>alloc</code>。当然SGI STL也提供了一个默认的内存配置器为<code>allocator</code>,只不过在大部分情况下，我们很少使用这个效率不佳且仅做内存分配与释放的配置器。<br>alloc不同于allocator，它不接受任何参数，以<code>vector</code>为例，它的的标准写法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt; <span class="comment">// 缺省使用alloc为配置器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span>...&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="对象与内存"><a href="#对象与内存" class="headerlink" title="对象与内存"></a>对象与内存</h2><p>回到上面的问题，对于C++中new/delete的操作是怎样的？在日常使用中，我们所习惯的操作大致如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span>...&#125;;</span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo;    <span class="comment">// 配置内存，然后构造对象</span></span><br><span class="line"><span class="keyword">delete</span> pf;            <span class="comment">// 将对象析构，然后释放内存</span></span><br></pre></td></tr></table></figure>
<p>对于这里的new/delete算式都内含了两步的操作<br>&emsp;&emsp;new :调用::operator new 配置内存;调用Foo::Foo() 构造对象内容。<br>&emsp;&emsp;delete:调用对象Foo::~Foo()将对象析构;调用::operator delete 释放内存</p>
<p>为了精密分工，STL allocator 决定将这两个阶段分开<br>&emsp;&emsp;对于内存:分配时使用 alloc::allocate();释放时使用 alloc::deallocate()。<br>&emsp;&emsp;对于对象:构造时使用::construct();析构时使用::destroy();</p>
<p><font color=blue>大家可以通过下图来帮助理解与记忆</font><br><img data-src="https://7894651.xyz/STL2/pic.png" alt="avatar"></p>
<h1 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h1><p>&emsp;&emsp;通过上图的理解，知道这两个函数是如何完成对象的构造与析构。接下来我们通过对其源码的剖析，对其作用加深理解。</p>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">t1</span>, <span class="keyword">class</span> <span class="title">t2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(t1* p,<span class="keyword">const</span> t2&amp;value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> (p) <span class="built_in">t1</span>(value);    <span class="comment">//placement new;调用t1::t1(value);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destory()第一版本,仅接受一个指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">t</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(t* pointer)</span> </span>&#123;</span><br><span class="line">  pointer-&gt;~<span class="built_in">t</span>();     <span class="comment">//调用destroy ~t(0)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都是destroy() 第二个版本以及它的特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">forwarditerator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">(forwarditerator first,forwarditerator last)</span> </span>&#123;</span><br><span class="line">  __destroy(first,last,<span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素的数值类别(value type)是否有trivial destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">forwarditerator</span>,<span class="keyword">class</span> <span class="title">t</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __destroy(forwarditerator first, forwarditerator last,t*) &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits::has_trival_destructor trivial_destructor;</span><br><span class="line">  __destroy_aux(first,last,<span class="built_in">trivial_destructor</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果元素的数值类型有non-trival destructor...</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">forwarditerator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__destroy_aux(forwarditerator first,forwarditerator last,__false_type) &#123;</span><br><span class="line">  <span class="keyword">for</span> (; first &lt; last; ++first) </span><br><span class="line">    <span class="built_in">destroy</span>(&amp;*first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的数值类型有trival destructor..</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">forwarditerator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __destroy_aux(forwarditerator,forwarditerator,__true_type) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是destory()第二版本针对迭代器为char*与wchar_t*的特化版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">char</span>* ,<span class="keyword">char</span>**)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">wchar_t</span>*,<span class="keyword">wchar_t</span>*)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>&emsp;&emsp;在STL源码中，<code>construct()</code>仅接受一个指针p与一个初值value。它的使用是将初值设定到指针所指向空间上。在C++中placement new运算子也可完成这一操作。<br><img data-src="https://7894651.xyz/STL2/pic1.png" alt="avatar"><br>&emsp;&emsp;对于析构<code>destroy</code>则存在两个版本。第一个版本仅接受一个指针，准备将该指针所指向之物析构掉；第二个版本则是接受[first,last)两个迭代器，将范围内的对象析构掉。为了效率的考虑，调用类型萃取防止无效析构拖慢性能。在检查结束后，就会调用第一版本的destroy来析构对象。<br><img data-src="https://7894651.xyz/STL2/pic2.png" alt="avatar"></p>
<h1 id="空间配置核心"><a href="#空间配置核心" class="headerlink" title="空间配置核心"></a>空间配置核心</h1><p>剖析完对象构造与析构的源码后，接下来我们一起深入内存的配置与释放之旅，了解空间配置器核心————alloc。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对象构造前的空间配置与对象析构后的空间释放，全由&lt;stl_alloc.h&gt;负责，SGI对此的设计哲学如下：</p>
<ul>
<li><font color=red> 向system heap要求空间 </font></li>
<li><font color=red> 考虑多线程(multi-threads)状态</font></li>
<li><font color=red> 考虑内存不足的应变措施</font></li>
<li><font color=red> 考虑过多”小型区块”可能造成的内存碎片(fragment)问题</font></li>
</ul>
<p>&emsp;&emsp;考虑到小型区块可能造成的内存破碎问题，SGI设计了双层级配置器。当配置区块&gt;128bytes时，则采用一级配置器。当配置区块&lt;128bytes时，则调用二级配置的memory pool来处理。<br>&emsp;&emsp;之前提及过，alloc这个次层配置、效率卓越的特殊配置器逸脱了STL标准。SGI为其包装了一个接口从而符合STL规格。下面是它们的定义与包装后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __USER_MALLOC</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 令 alloc 为二级配置器</span></span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ! __USER_MALLOC */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> <span class="number">0</span> == n ? <span class="number">0</span> : (T*)  Alloc::<span class="built_in">allocate</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(T));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> (T*) Alloc::<span class="built_in">allocate</span>(<span class="built_in"><span class="keyword">sizeof</span></span> (T));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in"><span class="keyword">sizeof</span></span>(T));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span> <span class="params">(T *p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;Alloc::<span class="built_in">deallocate</span>(p,<span class="built_in"><span class="keyword">sizeof</span></span>(T));&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><font color=blue>一二级配置器关系</font><br><img data-src="https://7894651.xyz/STL2/pic3.png" alt="avatar"></p>
<p><font color=blue>一二级配置器的包装接口与运用方式</font><br><img data-src="https://7894651.xyz/STL2/pic4.png" alt="avatar"></p>
<h2 id="一级配置器剖析"><a href="#一级配置器剖析" class="headerlink" title="一级配置器剖析"></a>一级配置器剖析</h2><p>&emsp;&emsp;结合上图，让我们看看一级配置器是如何仿真<code>C++ set_malloc_handler</code>的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 以下是用来处理内存不足情况的</span></span><br><span class="line">    <span class="comment">// oom： out of memory;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span>* ,<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_bandler)</span> <span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">void</span> *result = <span class="built_in">malloc</span>(n)  <span class="comment">//一级配置器直接使用malloc()</span></span><br><span class="line">      <span class="comment">// 以下情况无法满足时，才会改用oom_malloc()</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">com_malloc</span>(n);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span>)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">free</span>(p) <span class="comment">// 一级配置器直接使用free()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p,<span class="keyword">size_t</span> ,<span class="keyword">size_t</span> new_sz)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">void</span> *result = <span class="built_in">reallocate</span>(p, new_sz);  <span class="comment">// 一级配置器直接使用reallocate() </span></span><br><span class="line">      <span class="comment">// 以下情况无法满足时，才会改用oom_realloc()</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_realloc</span>(p, new_sz);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来就是仿真C++ new handler()</span></span><br><span class="line">    <span class="comment">// 你可以通过这个来设定你的的out-of-memory handler</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="keyword">void</span> (*f)()))</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in"><span class="keyword">void</span></span> (* old)() = __malloc_alloc_oom_bandler;</span><br><span class="line">      __malloc_alloc_oom_bandler = f;</span><br><span class="line">      <span class="keyword">return</span> (old);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过观察一级配置器可以得知，一级配置器是以<font color=red>malloc()、free()、realloc()</font>等C函数执行实际的内存的配置、释放、重配置等操作，并实现出类似<code>C++ new handler</code>的操作。<br>&emsp;&emsp;SGI一级配置器的顺序是先使用<code>allocate()</code>与<code>realloc()</code>(allocate 调用malloc，realloc调用realloc())。若是分配没有成功，就会改而调用<code>oom_malloc()</code>与<code>oom_realloc()</code>。它们会不断的循环调用内存不足处理例程，去解决问题。倘若没有设定内存不足处理例程，编程器则会调 _ _ THROW_BAD_ALLOC,丢出bac_alloc异常，或是直接调用exit(1)强制中止程序。<br>&emsp;&emsp;一级配置器的malloc-based allocator 相对于二级配置器的default alloc 会慢一些。但是对于线程安全和空间的运用上来说，malloc-base allocator会显得更加高效。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 实现部分</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 以下是用来处理内存不足情况的</span></span><br><span class="line">    <span class="comment">// oom： out of memory;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span>* ,<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_bandler)</span> <span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">void</span> *result = <span class="built_in">malloc</span>(n)  <span class="comment">//一级配置器直接使用malloc()</span></span><br><span class="line">      <span class="comment">// 以下情况无法满足时，才会改用oom_malloc()</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">com_malloc</span>(n);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span>)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">free</span>(p) <span class="comment">// 一级配置器直接使用free()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p,<span class="keyword">size_t</span> ,<span class="keyword">size_t</span> new_sz)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">void</span> *result = <span class="built_in">reallocate</span>(p, new_sz);  <span class="comment">// 一级配置器直接使用reallocate() </span></span><br><span class="line">      <span class="comment">// 以下情况无法满足时，才会改用oom_realloc()</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_realloc</span>(p, new_sz);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来就是仿真C++ new handler()</span></span><br><span class="line">    <span class="comment">// 你可以通过这个来设定你的的out-of-memory handler</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="keyword">void</span> (*f)()))</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in"><span class="keyword">void</span></span> (* old)() = __malloc_alloc_oom_bandler;</span><br><span class="line">      __malloc_alloc_oom_bandler = f;</span><br><span class="line">      <span class="keyword">return</span> (old);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二级配置器剖析"><a href="#二级配置器剖析" class="headerlink" title="二级配置器剖析"></a>二级配置器剖析</h2><p>&emsp;&emsp;二级配置器对于一级来说又多了一些机制，专门针对于内存碎片的处理。内存的碎片化不仅是增加了回收的难度，对于配置来说也是一个负担。并且这种负担是无法避免的，因为不管任何程序向system heap申请内存，都必须缴税。这个税也就是用来记录内存大小的信息，系统也正是依赖这些税才可以更好的管理内存。<br><img data-src="https://7894651.xyz/STL2/pic5.png" alt="avatar"><br>&emsp;&emsp;那么对于这些浩如烟海的税，我们的系统又是如何去管理的呢？二级配置器提供了一个很好的方法即使用自由链表去管理。大家肯定好奇自由链表为何是自由的？首先，自由链表每次都是直接配置一大块内存，客户端需要时直接分配给它，也就是从free-list中拔出。若客户端释还小额区块，则依旧还给free-list即重新插入free-list中。<br>&emsp;&emsp;既然使用链表，那我们又该如何去维护它呢？在这里大师提供了一个绝妙的方法，在了解这个方法之前，我们先了解一个概念————union(共用体)。如果了解过了可跳过这部分，不了解的同学可以学习回顾一下。</p>
<ol>
<li>共用体是一种特殊的类，也是一种构造类型的数据结构</li>
<li>共用体表示几个变量共用一个内存位置，在不同的时间保存不同的数据类型与不同长度的变量。</li>
<li>所有的共用借机成员共用一个空间，并且同一时间只能存放一个成员变量的值<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">double</span> c;</span><br><span class="line">  <span class="keyword">long</span> d;</span><br><span class="line">  <span class="keyword">char</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;&emsp;对于test来说，这里的数据大小就是long的大小。在C++中union主要用来压缩空间的。<br>&emsp;&emsp;在了解union之后，我们就可以来学习自由链表节点设计的精妙了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">obj</span>* <span class="title">free_list_link</span>;</span></span><br><span class="line">  <span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为了防止需要额外指针去指向下一个，因而union的第一个字段可以当做一个指针指向下一个。对于第二个区块，也可作为一个指针，不过此时指向的是实际的内存区。这样的一物两用，既实现了维护的目标又达到了避免浪费的目的。<br><img data-src="https://7894651.xyz/STL2/pic6.png" alt="avatar"></p>
<p><font color = blue>底下是二级配置器中的free_list的部分实现代码</font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>__ALIGN = <span class="number">8</span>&#125;; <span class="comment">// 小型区块的上调边界</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>__MAX_BYTES = <span class="number">128</span>&#125;; <span class="comment">// 小型区块的上限</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>__NFRELISTS = __MAX_BYTES / __ALIGN&#125;;  <span class="comment">// free-lists 个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads,<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ROUND_UP() 将bytes 上调至8的倍数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">ROUND_UP</span> <span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (((bytes)+__ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">obj</span> &#123;</span>  <span class="comment">// free-list 节点构造</span></span><br><span class="line">      <span class="class"><span class="keyword">union</span> <span class="title">obj</span> * <span class="title">free_list_link</span>;</span></span><br><span class="line">      <span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> obj * <span class="keyword">volatile</span> free_list[__NFRELISTS];</span><br><span class="line">    <span class="comment">// 以下函数根据区块大小、决定使用第n号free-list。n从0开始</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (((bytes)+__ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN<span class="number">-1</span>)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个大小n的对象，并可能加入大小为n的其它区块到free list</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置一大块空间，可容纳nobjs个大小为&quot;size&quot;的区块</span></span><br><span class="line">    <span class="comment">// 如果配置nobjs个区块有所不便，nobjs可能会降低</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size,<span class="keyword">int</span> &amp;nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// chunk allocation state</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>* start_free; <span class="comment">// 内存池起始位置,仅在chunk_alloc()中变化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>* end_free; <span class="comment">// 内存池结束位置，只在chunk_alloc()中变化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p,<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p,<span class="keyword">size_t</span> old_sz,<span class="keyword">size_t</span> new_sz)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是static data member 的定义与初值设定</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads,<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads,inst&gt;::start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> threads,<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line">__default_alloc_template&lt;threads,inst&gt;::obj * <span class="keyword">volatile</span></span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::free_list[__NFRELISTS]=</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="allocate源码剖析"><a href="#allocate源码剖析" class="headerlink" title="allocate源码剖析"></a>allocate源码剖析</h2><p>&emsp;&emsp;在了解free-list这样一个二级配置器的密钥后，我们就带着这个钥匙打开allocate()的大门。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  obj * <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">  obj * result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 大于128就调用一级配置器</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">    <span class="keyword">return</span> (malloc_alloc::<span class="built_in">allocate</span>(n));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找16个free list 中适当的一个</span></span><br><span class="line">  my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">  result = * my_free_list;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有找到可用的free list，准备重新填充free list</span></span><br><span class="line">    <span class="keyword">void</span> *r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//调整 free list</span></span><br><span class="line">  *my_free_list = result -&gt; free_list_link;</span><br><span class="line">  <span class="keyword">return</span> (result);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;作为二级配置器，( _ _ default_alloc_templat)同样也拥有配置的标准接口函数allocate()。函数的作用：首先判断区块大小，超过128就调用一级配置器。小于就检查对应的free-list，如果free list有可用区块，就直接拿来使用。如果没有可用的，就将区块大小上调至8的倍数，然后调用refill()，为free list重新填充空间。<br><font color=blue>allocate函数实现示意图</font><br><img data-src="https://7894651.xyz/STL2/pic7.png" alt="avatar"></p>
<h2 id="deallocate-源码剖析"><a href="#deallocate-源码剖析" class="headerlink" title="deallocate()源码剖析"></a>deallocate()源码剖析</h2><p>&emsp;&emsp;在了解完alloate的空间配置，我们同时也应该明白，空间的释放是如何进行的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p,<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  obj *q = (obj*) p;</span><br><span class="line">  obj * <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//大于128则调用一级配置器</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">    malloc_alloc::<span class="built_in">deallocate</span>(p, n);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找对应的free list</span></span><br><span class="line">  my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">  <span class="comment">// 调整free list，回收区块</span></span><br><span class="line">  q-&gt;free_list_link = *my_free_list;</span><br><span class="line">  *my_free_list = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;作为二级配置器的标准接口函数deallocate()。它的使用是：首先判断区块大小，大于128调用一级，小于128就找到对应的free list，将其回收。<br><font color=blue>deallocate函数作用示意图</font><br><img data-src="https://7894651.xyz/STL2/pic1.png" alt="avatar"></p>
<h2 id="refill-源码剖析"><a href="#refill-源码剖析" class="headerlink" title="refill()源码剖析"></a>refill()源码剖析</h2><p>&emsp;&emsp;作为品尝内存池的餐前小点，你确定不看看吗？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个大小为n的对象，并且有时候会为适当的free list 增加节点</span></span><br><span class="line"><span class="comment">// 假设n已经适当上调至8的倍数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> *__default_alloc_template&lt;threads, inst&gt;::<span class="built_in">refill</span>(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">  <span class="keyword">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">// 调用chunk_alloc(),尝试取得nobjs个区块作为free list的新节点</span></span><br><span class="line">  <span class="comment">// 注意参数nobjs是psss by reference</span></span><br><span class="line">  <span class="keyword">char</span>* chunk = <span class="built_in">chunk_alloc</span>(n, nobjs);</span><br><span class="line">  obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line"></span><br><span class="line">  obj * result;</span><br><span class="line">  obj * current_obj, * next_obj;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果只获得一个区块，这个区块就分配给调用者使用,free list无新节点</span></span><br><span class="line">  <span class="keyword">if</span> (i == nobjs) <span class="keyword">return</span> (chunk);</span><br><span class="line">  <span class="comment">// 否则准备调整free list,纳入新节点</span></span><br><span class="line">  my_free_list = free_lis + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下在chunk空间内建立free list</span></span><br><span class="line">  result = (obj*) chunk;  <span class="comment">//这一块准备返回给客户端</span></span><br><span class="line">  <span class="comment">// 以下导引free list指向新配置的空间(取自内存池)</span></span><br><span class="line">  *my_free_list = next_obj = (*obj *)(chunk + n);</span><br><span class="line">  <span class="comment">// 以下将free list各节点串接起来</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; ;i++) &#123; <span class="comment">// 从1开始，因为第0个将返回给客端</span></span><br><span class="line">    current_obj = next_obj;</span><br><span class="line">    next_obj = (obj*)((<span class="keyword">char</span> *)next_obj + n);</span><br><span class="line">    <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">      current_obj -&gt; free_list_link = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current_obj -&gt; free_list_link = next_obj;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当发现free list中没有可用区块时，就会调用refill()为free list注入新空间。新的空间皆是取自内存池(经由chunk_alloc()完成)。当内存池水够时，缺省会获得20个新区块。如果水不够，获得的节点可能少于20。<br>&emsp;&emsp;形象一点的说法就是：refill()就相当于水杯，free list里没有水了，它就会从内存池子里面舀水并灌到free list中。当内存池水不够了，那么杯子就是能舀多少舀多少水灌到free list中。</p>
<h2 id="二级配置器核心——内存池"><a href="#二级配置器核心——内存池" class="headerlink" title="二级配置器核心——内存池"></a>二级配置器核心——内存池</h2><p>&emsp;&emsp;在有了前面的基础下，我们终于来到memory pool这里了。其实内存池的意思很简单，就像下图表示的一样<br><img data-src="https://7894651.xyz/STL2/pic11.png" alt="avatar"></p>
<p>&emsp;&emsp;让我们再通过源码来深入了解了解内存池</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 假设size 已经上调至8的倍数</span></span><br><span class="line"><span class="comment">// 注意参数nobjs 是 pass by reference</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;threads,inst&gt;::</span><br><span class="line"><span class="built_in">chunk_alloc</span>(<span class="keyword">size_t</span> size,<span class="keyword">int</span>&amp; nobjs) &#123;</span><br><span class="line">  <span class="keyword">char</span> * result;</span><br><span class="line">  <span class="keyword">size_t</span> total_types = size * nobjs;</span><br><span class="line">  <span class="keyword">size_t</span> bytes_left = end_free - start_free; <span class="comment">// 内存池剩余空间</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( bytes_left &gt;= total_types) &#123;</span><br><span class="line">    result = start_free;</span><br><span class="line">    start_free += total_types;</span><br><span class="line">    <span class="keyword">return</span>(result);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123;</span><br><span class="line">    <span class="comment">// 内存池剩余空间不能完全满足需要量，但是足够供应一个(含)以上的区块</span></span><br><span class="line">    nobjs = bytes_left /size;</span><br><span class="line">    total_types = size * nobjs;</span><br><span class="line">    result = start_free;</span><br><span class="line">    start_free += total_types;</span><br><span class="line">    <span class="keyword">return</span> (result);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 内存池剩余空间边一个区块的大小都无法提供</span></span><br><span class="line">    <span class="keyword">size_t</span> types_to_get = <span class="number">2</span> * total_types + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 以下都是尝试让内存池中的残余还有利用价值</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 内存池中还有一些零头，先配给给适当的free list</span></span><br><span class="line">      <span class="comment">// 首先寻找适当的 free list</span></span><br><span class="line">      obj * <span class="keyword">volatile</span> * my_free_list = </span><br><span class="line">        free_list + <span class="built_in">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line">      <span class="comment">//调整feee list,将内存池中的残余编入</span></span><br><span class="line">      ((*obj)start_free)-&gt; free_list_link = *my_free_list;</span><br><span class="line">      *my_free_list  = (obj*)start_free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置heap 空间,用来补充内存池</span></span><br><span class="line">    start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;</span><br><span class="line">      <span class="comment">// heap 空间不足，malloc()失败</span></span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      obj * <span class="keyword">volatile</span> * my_free_list *p;</span><br><span class="line">      <span class="comment">// 试着检视我们手上拥有的东西，这不会造成伤害，我们不打算尝试配置</span></span><br><span class="line">      <span class="comment">// 较小的区块，因为在多进程机器上容易导致灾难</span></span><br><span class="line">      <span class="comment">// 以下搜寻适当的free list，适当就是“还有可用区块，且够大&quot;的free list</span></span><br><span class="line">      <span class="keyword">for</span> (i = size; i&lt; __MAX_BYTES; i += __ALIGN) &#123;</span><br><span class="line">        my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i);</span><br><span class="line">        p = *my_free_list;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;  <span class="comment">// free list 还有没有的区块</span></span><br><span class="line">          <span class="comment">// 调整free list以释放出未用区块</span></span><br><span class="line">          *my_free_list = p-&gt;free_list_link;</span><br><span class="line">          start_free = (<span class="keyword">char</span>*) p;</span><br><span class="line">          end_free = start_free + i;</span><br><span class="line">          <span class="comment">// 递归调用自己，为了修正nobjs</span></span><br><span class="line">          <span class="keyword">return</span> (<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">          <span class="comment">// 注意，任何残余零头终将被编入适当的free list中备用</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      end_free = <span class="number">0</span> <span class="comment">// 如果出现意外(山穷水尽,没有内存可用)</span></span><br><span class="line">        <span class="comment">// 没用一级配置器，看看out-of-memory机制能否尽点力</span></span><br><span class="line">        start_free = (<span class="keyword">char</span>*) malloc_alloc::<span class="built_in">allocate</span>(bytes_to_get);</span><br><span class="line">      <span class="comment">// 这会导致抛出异常，或内存不足的情况改善</span></span><br><span class="line">    &#125;</span><br><span class="line">    heap_size += bytes_to_get;</span><br><span class="line">    end_free = start_free + bytes_to_get;</span><br><span class="line">    <span class="comment">// 递归调用自己，为了修正nobjs</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">chunk_alloc</span>(size,nobjs));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;结合书上的例子与下图，对内存池理解进一步加深<br><img data-src="https://7894651.xyz/STL2/pic9.png" alt="avatar"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;空间配置器作为STL六大组件的基础，我们之后学习新的内容时。要时常的复习这部分，要结合新的内容，进行全面开拓。</p>
]]></content>
      <categories>
        <category>Read Notes</category>
      </categories>
      <tags>
        <tag>theory</tag>
      </tags>
  </entry>
  <entry>
    <title>宝华山之旅</title>
    <url>/2021/Travel-1/</url>
    <content><![CDATA[<h1 id="景区背景"><a href="#景区背景" class="headerlink" title="景区背景"></a>景区背景</h1><p>&emsp;&emsp;宝华山距离南边的句容市、东边的镇江市、西边的南京市都约30公里，宝华山海拔437.2米。隆昌寺始建于公元502元年原名为宝志庵，相传是梁代的高僧宝志和尚(民间济公和尚的原型)在此结庵传经，故有此名。后<strong>明神宗</strong>敕赐大藏经及<strong>“护国圣化隆昌寺”</strong>,宝志庵改名为隆昌寺。清代的<strong>康熙乾隆</strong>曾多次驾幸隆昌寺。隆昌寺作为景区最主要的景点,它的三坛大戒非常的出名，是目前国内最大的传戒道场，僧人取得隆昌寺的戒牒相当于获得北大、清华的毕业证，宝华山也因此有<strong>“律宗第一名山”</strong>的美誉。<br><font color=blue>明宗所赐”护国圣化隆昌寺”牌匾</font><br><img data-src="https://7894651.xyz/travel1/pic1.jpg" alt="avatar"><br><font color=blue>寺中的大鼎</font><br><img data-src="https://7894651.xyz/travel1/pic2.jpg" alt="avatar"></p>
<h1 id="景点介绍"><a href="#景点介绍" class="headerlink" title="景点介绍"></a>景点介绍</h1><p><img data-src="https://7894651.xyz/travel1/pic3.jpg" alt="avatar"><br>&emsp;&emsp;从北大门进入，向里走几百米就可以到达游客中心处购买门票。这里的门票不同于其它的景点，它将门票制作成一张精致的明信片，让我们可以将宝华山的美景邮寄给远方的好友。<br><img data-src="https://7894651.xyz/travel1/pic4.jpg" alt="avatar"><br>&emsp;&emsp;进入里后，首先来到的是千华古村。这里就是一个类似于古代小村庄的样子，沿街也会有人在售卖一些零食、手工艺品等等。在村子里也可看到戏台上的一曲霓裳，或是街边孩同的追逐嬉戏。这样一个充满生活气息的小村庄，给我一种许久未曾体会过的感受，一种快节奏下无法体验到的生活。在村子中兜兜转转下，来到了宝志和尚的大殿中，他的宝相庄严，脸上又似乎是带着对世人的怜悯。四周的壁画是描述的是宝志和尚,准确来说是济公和尚在人间救苦救难的故事。出了千华古村，就要准备登山了。<br><font color=blue>千华古村图片</font><br><img data-src="https://7894651.xyz/travel1/pic6.jpg" alt="avatar"></p>
<p>&emsp;&emsp;在登山的过程中，我们会看到开国上将许世友挖掘的煤洞——“将军洞”。之后，便可看到乾隆御道，不过由于各种原因。御道被封了，我们也只是无可奈何的继续登山。再往后就到了”秦淮之源”,不过这个仅仅是告诉游客宝华是秦淮河的源头，但是却不能在这里看到秦淮河的源头的。沿途还有山龟听经、丁沙地部落等景点。登顶后，我们便来到了隆昌寺。寺庙的厦门朝北，微派的建筑风格。内部还有一个清康熙年间的汉白玉台，自清代以来，无数僧众在此戒台上受戒。在隆昌寺最顶盛时期，曾有殿宇九百九十九间半，因此寺内还存有五口千人大锅。<br><font color=blue>观音像</font><br><img data-src="https://7894651.xyz/travel1/pic7.jpg" alt="avatar"></p>
<p><font color=blue> 众山点头</font><br><img data-src="https://7894651.xyz/travel1/pic8.jpg" alt="avatar"></p>
<p><font color=blue> 律宗第一名山 </font><br><img data-src="https://7894651.xyz/travel1/pic9.jpg" alt="avatar"></p>
<h1 id="门票价格"><a href="#门票价格" class="headerlink" title="门票价格"></a>门票价格</h1><p>这里的票价应该是淡季的票价，旺季的票价不清楚<br>学生票价：25/人<br>成人票价：45/人</p>
<h1 id="出行"><a href="#出行" class="headerlink" title="出行"></a>出行</h1><p>在镇江或是南京的朋友，可以选择自驾出行。当然费用会贵一些，需要额外的购买停车票:小型车（15座以下）10元/辆，大型车15元/辆。<br>选择公交出行也是可以的，镇江这里可以到南门汽车站坐606到宝华山风景区站下车。进入景区可以选择徒步或是坐观光车上去，价格：10/位。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;宝华山还是一个极具文化底蕴的景区，在游览大好风光之时。我们同时也可以了解到不一样的佛教文化，一个我们很少会接触到的另一个世界。或许，在林间，在这庙宇之内传出的梵音中，才是探寻自我的好去处。</p>
]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title>Two Pointers Technique</title>
    <url>/2020/Two-Pointers/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>  &emsp;&emsp;双指针，顾名思义就是利用两个指针去遍历数组。一般来说遍历数组都是使用单指针(index)去遍历的，<br>  两个指针一般是在有序数组中使用，一个放首，一个放尾，同时向中间遍历，直到两个指针相交，完成遍历，时间复杂度<br>  也是O(n).</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>  一般会有两个指针 <code>font</code>,<code>tail</code>。分别指向开始和结束的位置。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">front &#x3D; 0;</span><br><span class="line">tail &#x3D; A.length()-1</span><br></pre></td></tr></table></figure>

<p>  一般循环结束条件采用的是判断两个指针是否相遇</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (front &lt; tail)</span><br><span class="line">  &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  对于in place 交换问题，循环结束条件一般是其中一个指针遍历完成的</p>
<h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><p>  一般双指针在有序数组中使用的特别多。(部分情况下，未排序数组也有应用)一般用来解决下列问题</p>
<ul>
<li><p>两数求和<br>一般这种问题都是问，寻找两个数的和为一个特定值，这时候，如果数组有序，我们采用两个指针，分别从<br>前和后往中间遍历,front移动和增大，tail移动和减小，通过特定的判断，可以求出特定的和<br>时间复杂度为O(n)，如果要使用双重循环则时间复杂度为O($n^{2}$)</p>
</li>
<li><p>in place 交换<br>数组的in place原地交换一般都得用双指针，不然数组中添加或这删除一个元素，需要移动大量的元素。这时候一般是一个指针遍历，一个指针用来找可以交换的元素。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>theory</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯光子一面</title>
    <url>/2021/interview_first/</url>
    <content><![CDATA[<h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>时间复杂度与空间复杂</li>
<li>不同的排序的最好与最坏的时间复杂度</li>
<li>快排<ol>
<li>如何实现的</li>
<li>何时会导致快排的最坏时间复杂度</li>
<li>快排是否稳定，为什么不稳定</li>
</ol>
</li>
<li>了解堆排序吗</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li>反转链表(Leetcode ＃206)</li>
</ul>
<h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++ 基础"></a>C++ 基础</h2><ul>
<li>C++ 关键字static，它的作用</li>
<li>C++ 关键字sizeof作用<ul>
<li>strlen与它的区别</li>
<li>sizeof(“hello”)与strlen(“hello”)区别</li>
<li>double<code><em></code> (<code></em></code>a) [3][6]; sizeof(*a)与sizeof(a)的大小</li>
</ul>
</li>
<li>C++ 多态<ul>
<li>如何实现</li>
<li>什么是虚函数，什么是虚表和虚拟指针</li>
<li>内存中的布局是什么样子的</li>
</ul>
</li>
<li>C++ 重载与重写<ul>
<li>什么是重载，什么是重写</li>
<li>它们的区别</li>
<li>重载是否与类有关，重载是如何实现的</li>
</ul>
</li>
<li>C++ new/delete &amp;&amp; malloc/free<ul>
<li>它们的区别</li>
</ul>
</li>
<li>C++ 的内存分区<ul>
<li>说一下每个区的作用</li>
</ul>
</li>
<li>C++ 堆栈的区别</li>
<li>C++ 编译执行的过程</li>
<li>C++ 深拷贝与浅拷贝的区别</li>
<li>C++ 11新特性有了解过哪些?</li>
<li>C++ 动态转换有了解过？<ul>
<li>常见的几种动态转换说一下</li>
<li>它们的作用</li>
</ul>
</li>
<li>C++ define 与 typedef<ul>
<li>define的功能与作用</li>
<li>define 与 typedef 区别</li>
</ul>
</li>
<li>C++ 内存泄漏的原因</li>
<li>C++ move <ul>
<li>move的使用与功能</li>
</ul>
</li>
</ul>
<h2 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h2><ul>
<li>你有用过哪些容器，可以讲讲</li>
<li>vector容器的底层实现<ul>
<li>map底层实现红黑树</li>
</ul>
</li>
<li>有使用过迭代器吗</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>进程间的通信方式</li>
<li>进程与线程的区别</li>
</ul>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li>讲一下TCP/IP的三次握手与四次挥手<ul>
<li>三次握手<ul>
<li>TCP/IP 是否可以为两次，为什么</li>
<li>TCP/IP 最后一个确认包server端一直接收不到，client应如何操作</li>
</ul>
</li>
<li>四次挥手<ul>
<li>什么时候会进入Time_wait 等待状态，时间为多久</li>
<li>server 是否也会进入Time_wait 等待状态，什么状况会导致server进行这个状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="结束反问"><a href="#结束反问" class="headerlink" title="结束反问"></a>结束反问</h2><ul>
<li>面试官评价<ul>
<li>指针使用仍有欠缺</li>
<li>对于一些底层原理应深入了解</li>
<li>操作系统还需要深入</li>
</ul>
</li>
<li>面试官荐书<ul>
<li>书箱大致属于一些经典书目</li>
<li>可以多阅读一些优秀的Blog，参考这些优秀博主的如何思考以及他们对于底层原理的解析</li>
</ul>
</li>
</ul>
<h1 id="面试问题答案总结"><a href="#面试问题答案总结" class="headerlink" title="面试问题答案总结"></a>面试问题答案总结</h1><h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><ol>
<li><strong>排序算法的时间复杂度与空间复杂度</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最坏时间复杂度</th>
<th align="center">最好时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^{2})$</td>
<td align="center">$O(n^{2})$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center"><font color=red>直接选择排序</font></td>
<td align="center">$O(n^{2})$</td>
<td align="center">$O(n^{2})$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td align="center"><font color=red>不稳定</font></td>
</tr>
<tr>
<td align="center">直接插入排序</td>
<td align="center">$O(n^{2})$</td>
<td align="center">$O(n^{2})$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center"><font color=red>快速排序</font></td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(n^{2})$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center"><font color=red>不稳定</font></td>
</tr>
<tr>
<td align="center"><font color=red>堆排序</font></td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(1)$</td>
<td align="center"><font color=red>不稳定</font></td>
</tr>
<tr>
<td align="center"><font color=red>希尔排序</font></td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(ns)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td align="center"><font color=red>不稳定</font></td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(n)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">$O(N * M)$</td>
<td align="center">$O(N * M)$</td>
<td align="center">$O(N * M)$</td>
<td align="center">$O(M)$</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<ol start="2">
<li><strong>快速排序</strong></li>
</ol>
<ul>
<li> 基本思想    *  通过一趟排序将待排记录分割成独立的两个部分，其中一部分关键字均比另一部分记录关键字小，接着对这两部分记录继续进行排序，以达到整个序列有序的目的。</li>
<li>最优与最坏情况分析<ul>
<li>最优的情况：Parition每次都划分得很均匀。在获得枢轴后将数组一分为二，各自仅需$(n/2)$的时间，这是最好的情况，时间复杂度为$O(nlogn)$</li>
<li>最坏的情况：待排序的数组是正序或逆序，每次划分只得到一个比上一次少一个记录的子序列，这里另一个记录是为空的。如果用二叉树表示就是一个斜树,这里就需要n-1次递归调用，所以其最终时间复杂度为$O(n^{2})$</li>
</ul>
</li>
<li>快排的不稳定的原因<ul>
<li>关键字的比较是跳跃进行的，因此快排是不稳定的</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>堆排序</strong></li>
</ol>
<ul>
<li>基本思想：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将其移走(实际就是将其与堆数组末尾元素交换，此时末尾元素为最大值),然后将剩余的n-1个序列重新构造成一个椎，这样就会得到n个元素中的次小值。之后重复之前的操作，就可以得到一个有序序列了</li>
<li>稳定性：由于记录的比较与交换是跳跃的，所以堆排序是一种不稳定的排序方式</li>
<li>适用场景：不适合待排序</li>
</ul>
<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><ol>
<li><strong>反转链表</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* prev &#x3D; nullptr;</span><br><span class="line">        ListNode* cur &#x3D; head;</span><br><span class="line">        </span><br><span class="line">        while (cur !&#x3D; nullptr) &#123;</span><br><span class="line">            ListNode* next &#x3D; cur-&gt;next;</span><br><span class="line">            cur-&gt;next &#x3D; prev;</span><br><span class="line">            prev &#x3D; cur;</span><br><span class="line">            cur &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="C-基础-1"><a href="#C-基础-1" class="headerlink" title="C++ 基础"></a>C++ 基础</h2><ol>
<li><strong>C++ 用法与作用</strong></li>
</ol>
<ul>
<li>隐藏: 在编译多个文件时，所有未加static前缀的全局变量与函数都具有全局可见性</li>
<li>保持变量内容的持久</li>
<li>static变量默认初始化为0</li>
<li>类成员声明为static<ul>
<li>static 变量只会被分配一次内存，因此它具有对值的记忆性</li>
<li>static 全局变量可以被模块内所有函数访问，不可以被模块外的其它函数访问</li>
<li>类中static成员变量属于整个类，对类的对象仅有一份拷贝</li>
<li>类的static成员函数为这个类所拥有，这个函数不接收this指针，所以只可以访问类的static成员变量</li>
<li>static类对象必须在类外进行初始化</li>
<li>static成员函数不可以被virtul修饰</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>C++ sizeof用法与作用</strong></li>
</ol>
<ul>
<li>定义： sizeof是一个操作符，作用是返回一个对象或类型所占的内存字节数</li>
<li>数组： sizeof(数组)的值等于数组所占用内存字节数</li>
<li>联合类型：操作数为联合类型时，sizeof的结果为其最大字节成员的字节数</li>
<li>内存对齐问题：由于结构体会自动对齐，所以sizeof的结果就是最大类型的所占用的字节数</li>
<li>类：空类大小为1，一个空类作为基类，它的大小为0。如果类的成员函数中有虚函数，就是固定占用4字节</li>
<li>strlen与它的区别<ul>
<li>sizeof 是运算符，strlen是库函数</li>
<li>sizeof的参数可以为任何数据类型或者数据，strlen参数只能是字符指针且结尾为’\0’的字符串</li>
<li>sizeof值在编译时确定，所以不能得到动态分配存储空间的大小</li>
</ul>
</li>
<li>sizeof(“hello”) 与 strlen(“hello”) <ul>
<li>sizeof(“hello”) 结果为6</li>
<li>strlen(“hello”) 结果为5，因为不包含’\0’</li>
</ul>
</li>
<li>sizeof( * a)指向的是整个数组空间，所以大小为144。sizeof(a)指的是单个变量所占用的字节数，又因为指向double类型，所以为8字节</li>
</ul>
<ol start="3">
<li><strong>C++ 多态</strong></li>
</ol>
<ul>
<li>如何实现多态<ul>
<li>在基类的函数前加上<code>virtual</code>关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数。</li>
</ul>
</li>
<li>多态实现过程<ul>
<li>编译器发现类中在虚函数，会自动为其生成一份虚表，该表是一个一维数组，虚表里存储了虚函数入口地址</li>
<li>编译器会在对象的前四个字节中保存一个虚表指针，即vptr</li>
<li>调用构造函数，在构造函数中创建虚表并对其进行初始化</li>
<li>派生类对基类的虚函数没有重写，则派生类的vptr指向基类的虚表。有重写的话，派生类的vptr会指向自身的虚表。当派生类中有自己的虚表时，会将其添加在后面。</li>
</ul>
</li>
<li>内存布局<ul>
<li>单一继承的内存布局<ul>
<li>每个类最多只会有一个vptr指针，并放在第一个拥有virtual function 的类之后(<font color=red>父类必须保证对象的完整性</font>)</li>
<li>virtual function 工作方式：可以通过vptr找到vtable，对应的vtable记录了所指对象的真正类型。vtable中第一个slot存储了type_info。对应的函数的真正的地址可以从vtable中的对应slot中找到。</li>
</ul>
</li>
<li>多重继承下的内存布局<ul>
<li>根据继承父类的个数保存对应的vptr</li>
<li>根据所保存的虚表指针个数，产生相应个数的虚表</li>
<li>构造时会行构造会优先构造第一个基类</li>
<li>多重继承中的菱形继承是存在二义性的风险的，即使可以通过明确调用路径，但是二义性的潜在性还未消除。</li>
</ul>
</li>
<li>虚拟继承<ul>
<li>解决了菱形继承中，子类拥有多个间接父类实例的情况</li>
<li>虚拟继承而来的子类会生成一个隐藏的虚基类指针，虚基类指针总是在vptr之后</li>
<li>子类会覆盖基类的虚函数 </li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>C++ 重载与重写</strong></li>
</ol>
<ul>
<li>重载是指在同一范围定义中的同名成员函数才存在重载关系,其特点为：<ul>
<li>参数名相同</li>
<li>参数类型与数目有所不同</li>
<li>不能出现参数个数与类型均相同</li>
</ul>
</li>
<li>重写指的是在派生类中的基类中的同名函数，<strong>重写就是重写函数体，要求基类函数必须是虚函数</strong>且<ul>
<li>与基类的虚函数有相同的参数个数</li>
<li>与基类的虚函数有相同的参数类型</li>
<li>与基类的虚函数有相同的返回类型</li>
</ul>
</li>
<li>区别<ul>
<li>重写是父类与子类之间的垂直关系，重载是不同函数间的水来关系</li>
<li>重写要求参数列表相同，重载要求参数列表不同，返回值不要求</li>
<li>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</li>
</ul>
</li>
<li>重载的实现原理<ul>
<li>利用命名倾轧技术(name mangling)，来改名函数名，区分参数不同的同名函数</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>C++ new/delete 与 malloc/free 区别</strong></li>
</ol>
<ul>
<li>new/delete是C++ 关键字需要编译器支持；malloc/free 是库函数，需要头文件支持。</li>
<li>使用new申请的内存，编译器会自动计算分配大小；malloc申请的内存，需要手动计算大小</li>
<li>new 内存分配成功，返回的是对象的类型指针，无须强制类型转换；malloc分配内存成功后返回是void，需要强制类型转,所以malloc不安全。</li>
<li>new 内存分配失败会抛出bac_alloc异常，malloc分配失败会返回NULL</li>
<li>new/delete 会去调用constructor与deconstructor，而malloc/free 仅是对于资源的申请与释放</li>
</ul>
<ol start="6">
<li><strong>C++ 内存分区</strong></li>
</ol>
<ul>
<li>一共分为六个区域，分别是：栈、自由存储区、堆、全局/静态存储区、常量存储区与代码区</li>
<li>简单说明各个分区的作用<ul>
<li>栈：在函数中，函数内部局部变量的存储单元都可以在栈上创建，结束后自动释放。由于栈内置于处理器中，效率高，但是分配的内存有限</li>
<li>堆：就是那些由new分配的内存块，需要我们程序去控制。一个delete对应一个new，如果没有释放，程序结束后会由系统自动回收</li>
<li>自由存储区：全局变量与静态变量被分配到一块内存中，它们会被自动初始化</li>
<li>常量存储区：仅存放常量，不允许修改</li>
<li>代码区：存放函数体的二进制代码</li>
</ul>
</li>
</ul>
<ol start="7">
<li><strong>C++ 堆栈的区别</strong></li>
</ol>
<ul>
<li>申请方式不同<ul>
<li>栈是由系统自动分配的</li>
<li>堆是由自己申请与释放的</li>
</ul>
</li>
<li>申请的大小限制<ul>
<li>栈顶与栈底是预设好的，栈是向栈底扩展，大小固定</li>
<li>堆向高地址扩展，是不连续的内存区域</li>
</ul>
</li>
<li>申请效率不同<ul>
<li>栈由系统分配，速度快，不会在碎片</li>
<li>堆是由程序员分配，速度会比较慢，且会有内存碎片</li>
</ul>
</li>
<li>各自大小<ul>
<li>栈默认4M</li>
<li>堆区一般为1G-4G</li>
</ul>
</li>
</ul>
<ol start="8">
<li><strong>C++ 程序编译过程</strong></li>
</ol>
<ul>
<li>具体为两步：编译、链接</li>
<li>编译可以细分为三个阶段<ul>
<li>预编译处理</li>
<li>编译优化</li>
<li>转换成汇编</li>
</ul>
</li>
<li>链接<ul>
<li>需要链接原因：某个文件调用了另一个文件的函数或常量,或者是调用了某库函数</li>
<li>主要工作就是将有关目标文件连接起来</li>
</ul>
</li>
</ul>
<ol start="9">
<li><strong>深拷贝与浅拷贝的区别</strong></li>
</ol>
<ul>
<li>浅拷贝<ul>
<li>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针与原来的指针指向同一块地址，如果原来的指针所指向的资源被释放了，那么再释放浅拷贝指针的资源就会出现错误。</li>
</ul>
</li>
<li>深拷贝<ul>
<li>深拷贝不仅影响值，还为其开辟一个新的空间来存放这个值。即使原先的对象被析构且内存被释放掉了，这也不会对深拷贝的值有所影响。在自己实现拷贝赋值时，如果有指针变量的话需要自己实现深拷贝的。</li>
</ul>
</li>
</ul>
<ol start="10">
<li><strong>C++ 新特性有了解过哪些</strong></li>
</ol>
<ul>
<li>nullptr替代了NULL</li>
<li>引入了auto与decltype这两个关键字，实现了类型推导</li>
<li>基于范围的for循环 <code> for(auto& i : res) &#123;&#125; </code></li>
<li>类与结构体中初始化列表 </li>
<li>Lambda表达式(匿名函数)</li>
<li>std::forward_list(单向链表)</li>
<li>右值引用与move语义</li>
<li>…..</li>
</ul>
<ol start="11">
<li><strong>了解C++四种强制转换</strong></li>
</ol>
<ul>
<li>reinterpret_cast<ul>
<li>reinterpret_cast(expression)</li>
<li>type_id必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间的强制转换</li>
</ul>
</li>
<li>const_cast <ul>
<li>const_cast<type_id>(expression)</li>
<li>该运算符用来修改类型const与volatile属性。除了const与volatile修饰之外,type_id与expression的类型一致。用法如下：<ul>
<li>常量指针被转化为非常量的指针，并且仍然指向原来的对象</li>
<li>常量引用被转化为非常量的引用，并且仍然指向原来的对象</li>
<li>const_cast一般用于修改底层指针，如const char *p形式</li>
</ul>
</li>
</ul>
</li>
<li>static_cast<ul>
<li>static_cast<type_id>(expression)</li>
<li>该运算符把expression转换为type_id类型，但没有运行时类型检查来保证转换的安全性，主要有如下几种用法<ul>
<li>用于类层次结构中基类与派生类之间指针或引用的转换<ul>
<li>进行上行转换(把派生类指针或引用转换为基类表示)是安全的</li>
<li>进行下行转换(把基类的指针或引用转换为派生类表示)时，由于没有动态类型检查，所以是不安全的。</li>
</ul>
</li>
</ul>
</li>
<li>用于基本数据类型之间的转换,如int转换为char，int转换为enum。这种类型的转换的安全性需由开发者来保证</li>
<li>把空指针转换为目标类型的空指针</li>
<li>把任何类型的表达式转换为void类型</li>
<li><font color=red> static_cast 不能转换expression的const、volatile、_unaligned属性</font></li>
</ul>
</li>
<li>dynamic_cast <ul>
<li>dynamic_cast(expression)</li>
<li>在类型检查，基类向派生类转换是安全的，但是派生类向基类转换就有一些不安全</li>
<li>该运算符把expression转换为type_id类型。type_id必须是类指针、类的引用或void *</li>
<li>如果type_id 是指针类型，那么expression也必须是一个指针，如果type_id是一个引用，那么expression也必须是一个引用</li>
<li>这个转换是可以在执行期间决定真正的类型，因此expression必须是多态。</li>
<li>在类之间进行转换，dynamic_cast与static_cast的效果一样</li>
<li>在进行上下转换时，dynamic_cast具有类型检查功能,比static_cast功能</li>
</ul>
</li>
</ul>
<ol start="12">
<li><strong>C++ define 与typedef</strong></li>
</ol>
<ul>
<li>宏主要用于定义常量及书写复杂的内容；typedef 主要用于定义类型别名</li>
<li>宏替换发生在编译阶段，属于文本插入替换；typedef是编译的一部分</li>
<li>宏不检查类型；typedef会检查数据类型</li>
<li>宏不是语句，不用在最后添加分号；typedef 是语句，要加分号标识</li>
<li>注意对指针的操作，typedef char * p_char与#define p_char char * 区别巨大</li>
</ul>
<ol start="12">
<li><strong>C++ 内存泄漏原因</strong></li>
</ol>
<ul>
<li>定义<ul>
<li>内存泄漏是指<strong>堆内存的泄漏</strong>。堆内存是指程序从堆中分配的大小任意的内存块。如果通过new/malloc申请意资源后，没有使用delete/free来释放，那么这个内存块将不可被再次使用，这就是内存泄漏。</li>
</ul>
</li>
<li>泄漏的几种情况<ul>
<li>基类的析构函数没有申明为虚函数</li>
<li>对象数组没有使用delete[]来释放</li>
<li>new/delete,malloc/free 必须成对出现</li>
</ul>
</li>
</ul>
<ol start="13">
<li><strong>C++ move语义</strong></li>
</ol>
<ul>
<li>作用<ul>
<li>独享指针所有权的转移</li>
<li>左值到右值属性的转移</li>
</ul>
</li>
</ul>
<h2 id="C-STL-1"><a href="#C-STL-1" class="headerlink" title="C++ STL"></a>C++ STL</h2><ol>
<li>使用过哪些容器</li>
</ol>
<ul>
<li>vector</li>
<li>map</li>
<li>set</li>
<li>…</li>
</ul>
<ol start="2">
<li>vector容器的底层实现  </li>
</ol>
<ul>
<li>vector 是一个类似于array的序列容器。但是array维护的是静态空间，而vector则使用灵活的动态空间配置,维护一块连续的线性空间。在空间不足时，可以自动扩充空间容纳新元素。扩充时也需经历的有：重新配置空间、移动数据、释放原空间行操作</li>
<li>vector 扩充规则<ul>
<li>以原大小的两倍配置另外一块较大空间(或者 旧长度+新增元素个数)(Win+Vs下扩展1.5倍，Linux+GCC扩展是两倍)</li>
</ul>
</li>
</ul>
<ol start="3">
<li>迭代器使用</li>
</ol>
<ul>
<li>迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器的情况下遍历容器。除此之外，它还是作为容器与STL算法的重要粘合剂。</li>
<li>迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此容器内部必须保存一个与容器相关联的指针</li>
<li>常用的五种迭代器： value type、different type、pointer、reference、iterator catagoly;</li>
</ul>
<h2 id="操作系统-1"><a href="#操作系统-1" class="headerlink" title="操作系统"></a>操作系统</h2><ol>
<li>进程间的通信方式(Linux)</li>
</ol>
<ul>
<li>管道<ul>
<li>无名管道(内存文件): 管道是一种半双工的通信方式，数据只能单向的流通，而且只能在具有亲缘关系的进程之间使用。(进程的亲缘关系：父子进程关系)</li>
<li>有名管道(FIFO文件，借助文件系统): 有名管道是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式</li>
</ul>
</li>
<li>共享内存：映射一段能被其它进程所访问的内存，这段共享内存是由一个进程创建，可由多个进程访问。共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而设计的。它往往与信号量配合使用来实现进程间的同步与通信</li>
<li>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>套接字： 适用于不同的机器间进程通信，在本地也可作为两个进程通信的方式</li>
<li>信号：用于通知接收进程某个事件已经发生，比如按下<code>Ctrl+c</code>就是信号。</li>
<li>信号量：这是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问</li>
</ul>
<ol start="2">
<li>进程与线程</li>
</ol>
<ul>
<li>定义<ul>
<li>进程是资源分配与拥有的基本单位；线程是程序执行的基本单位</li>
</ul>
</li>
<li>切换过程<ul>
<li>进程是：用户态-&gt;内核态-&gt;用户态;线程是与其一致</li>
</ul>
</li>
<li>拥有的资源<ul>
<li>进程拥有CPU资源、内存资源、文件资源与句柄；线程拥有程序计数器、寄存器、栈与状态字。</li>
</ul>
</li>
<li>并发性<ul>
<li>不同的进程之间acrq实现并发，各自占有CPU实现并行;一个进程内部的多个线程并执行。</li>
</ul>
</li>
<li>通信方面<ul>
<li>进程间通信需要借助操作系统；线程间可以直接读写进程数据段。</li>
</ul>
</li>
</ul>
<h2 id="计算机网络-1"><a href="#计算机网络-1" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol>
<li>TCP/IP的三次握手<br>刚开始客户端处于Closed的状态，服务端处于Listen状态，进行三次握手</li>
</ol>
<ul>
<li>第一次握手：客户端给服务端发一个SYN报文，并指明客户端的初始化序列号ISN(c)。此时客户端处于<code>SYN_SEND</code>状态<ul>
<li>首部的同步位SYN=1,初始化seq=x,SYN=1的报文段不能携带数据，但要消耗一个序列号</li>
</ul>
</li>
<li>第二次握手：服务器收到客户端SYN报文之后，会以自己的SYN报文作为应答，并且也是指定了自己的初始化ISN(s)。同时会把客户端的ISN+1作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器牌SYN_RCVD的状态<ul>
<li>在确认报文段中SYN=1,ACK=1,确认号ack=x+1,初始序号seq = y.</li>
</ul>
</li>
<li>第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，当然，也是一样把报务器的ISN＋1作为ACK的值，表示已经收到了服务端的SYN报文，此时客户端牌ESTABLISHED状态。服务器收到ACK报文之后，也处于ESTABLISHED状态，此时，双方已经建立起了连接<ul>
<li>确认报文段ACK＝1，确认号ack=y+1,序号seq=x+1(初始为seq=x,第二个报文段所以要＋1),ACK报文段可以携带数据，不携带数据则不消耗序号。</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;发送第一个SYN的一端执行主动打开(avtive open),接收这个SYN并发回下一个SYN的另一端执行被动打开(passive open)。在socket编程中，客户端执行connect()时，将触发三次握手。</p>
<ol start="2">
<li>TCP/IP是否可以为两次，为什么</li>
</ol>
<ul>
<li>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能否使用再次握手达到目的。<ul>
<li>第一次握手：客户端发送网络包，服务端到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力正常。</li>
<li>第二次握手：服务端发包，客户端到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li>
<li>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li>
</ul>
</li>
<li>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</li>
<li>如果使用两次握手，则会出现以下这种情况<ul>
<li>客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。</li>
<li>后来收到确认，建立连接。数据传输完毕后，就释放连接，客户端共发出两个连接请求报文段，其中第一个丢失，第二个到达了服务端。</li>
<li>但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端。</li>
<li>此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立，不采用三次握手，只要服务端发出确认，就建立新的连接了。</li>
<li>此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>TCP/IP最后一个确认包server端一直接收不到，client应如何操作</li>
</ol>
<ul>
<li>SYN-ACK重传次数的问题：服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。(<font color=red>每次重传等待的时间不一定趋同，一般会是指数增长，例如间隔时间为1s,2s,4s,8s…</font>)</li>
</ul>
<ol start="4">
<li>TCP/IP 四次挥手<br>刚开始双方都处于ESTABLISHED状态,假如是客户端先发起关闭请求。四次挥手的过程如下:</li>
</ol>
<ul>
<li>第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端牌FIN_WATI1状态。即发出<strong>连接释放报文段</strong>(FIN=1,seq=u),并停止再发送数据，主动关闭TCP连接，进入FIN_WATI1状态(终止等待1)状态，等待服务端的确认。</li>
<li>第二次挥手：服务器收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于<code>CLOSE_WAIT</code>(关闭等待)状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进行FIN_WATI2(终止等待2)状态，等待服务端发出的连接释放报文段。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给FIN报文，且指定一个序列号。此时服务端处于<code>LAST_ACK</code>状态。即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文</strong>(FIN=1,ACK=1,seq=w,ack=u+1),服务端进入LAST_ACK(最后确认)状态，等待客户端的确认。</li>
<li>第四次挥手：客户端收到FIN之后，一样发送一个ACK报文作为应答，且把服务器端的序列号值+1作为自己ACK报文的序列号值，此时客户端处于<code>TIME_WAIT</code>， 。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。<br>&emsp;&emsp;收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。在socket编程中，任何一方执行close()操作即可产生挥手操作。</li>
</ul>
<ol start="5">
<li>何时会进入TIME_WAIT等待状态，多长时间，为什么是那么长时间</li>
</ol>
<ul>
<li>当收到一个FIN只意味着这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT。</li>
<li>2msl，理论上，四个报文者发送完毕，就可以直接进入CLOSED状态了，但是可能网络是不可靠的，在可能最后一个ACK丢失。所以TIME_WAIT状态就是用来生性可能丢失的ACK报文。</li>
</ul>
<ol start="6">
<li>server是否也会进入TIME_WAIT状态，什么情况会导致server进行这个状态</li>
</ol>
<ul>
<li>会的，出现在高并发短连接的TCP服务器上</li>
</ul>
]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>程序安全局-锁</title>
    <url>/2022/lock_use/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>锁，作为我们日常生活中最常见的物品。它让着我们的资源物品不会被他人取用，提供了更好的保护性。在程序中，也同样引入了锁的概念来保护程序中的某些重要资源。为也理解锁的原理与应用，我将搭配示例来讲解它们的实际用途与效果。</p>
<h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><p>程序中锁的应用，最常见的莫过于数据库中的读写锁、行锁、表锁，亦或者是多并发程序中应用的线程锁。无论是数据库或是并发线程中，使用锁的主要目的就是为了在同一时间内，仅有一个对象可以获取资源，以此来保证线程结果的正确性。数据库的行锁、表锁亦是如此。在深入锁之前，我想我们应提前搞清一个问题，那么就是我们为什么需要在程序中使用锁。</p>
<h2 id="何为锁"><a href="#何为锁" class="headerlink" title="何为锁"></a>何为锁</h2><p>在传统的单线程编程中，我们无需考虑是否需要为线程加锁。因为所有程序都运行在一个主线程中，且所有的函数都是按照顺序进行的。但随着并发思想的兴起，应用单线程的方法就开始有问题出现了。我们可以从如下的对话中，得到答案:<br><img data-src="https://7894651.xyz/Locker/multhread_locker.png" alt="avatar"><br>图片中的故事，清晰的讲解了单线程、多线程的区别。这其中也有一些常用的名词，如: 竞争条件、临界区、锁变量。</p>
<h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>在操作系统中，程序可能需要读取</p>
]]></content>
      <categories>
        <category>theory</category>
      </categories>
      <tags>
        <tag>locker</tag>
      </tags>
  </entry>
  <entry>
    <title>简单验证邮件发送应用</title>
    <url>/2022/mail_timer_apply/</url>
    <content><![CDATA[<p><img data-src="https://7894651.xyz/mail_timer_apply.md/xmind.png" alt="avatar"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>如今这样一个互联网迅速发展的时代，我们有时总是会需要注册不同的帐号以满足我们日常工作生活的需要。但是在注册时，不同的邮件验证码就成了注册中最为麻烦的一个步骤。从日常使用的角度来看，这样的设计简直就是”中秋夜里打灯笼——多此一举”。当然，切换角度从开发者的角度去度量，这些限制措施则是极有必要的。如发送验证码邮件，就是验证邮箱地址是否可用的一个有有效方法。每次获取验证码后，必须要间隔多少秒后才可以重新获取验证码。这是防止旧的验证码没有被使用就去请求新的验证码内容，从而请求过多导致服务器崩溃。那么这些限制又是依赖什么去实现的，随着应用的设计与完善，我们就可以解答这些问题了。</p>
<h1 id="发送流程"><a href="#发送流程" class="headerlink" title="发送流程"></a>发送流程</h1><p>为了实现这些限制，我们首先需要厘清发送邮件的流程。</p>
<h2 id="终端发送"><a href="#终端发送" class="headerlink" title="终端发送"></a>终端发送</h2><p>首先在终端使用telnet连接smtp.qq.com:25，来完成发送邮件的模拟:</p>
<ul>
<li><p>发送邮件<br><img data-src="https://7894651.xyz/mail_timer_apply.md/telnet_connect_smtp_qq.png" alt="avatar"></p>
</li>
<li><p>邮件接收<br><img data-src="https://7894651.xyz/mail_timer_apply.md/mail_receive.png" alt="avatar"></p>
</li>
</ul>
<h2 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h2><p>从以上的发送中，我们可以很轻松的提取出这个清晰的过程:</p>
<ol>
<li>使用telnet连接到smtp.qq:25这个服务器上，即连接服务邮件服务器: <code>telnet smtp.qq.com 25</code></li>
<li>发送EHLO命令，通知服务器: <code>EHLO hello</code></li>
<li>由于qq邮箱需要密码验证，因此使用auth login命令: <code>auth login</code></li>
<li>输入对应的邮件地址与密码</li>
<li>告知邮箱服务器发送地址: <code>mail from: <a href="mailto:&#49;&#x35;&#48;&#x38;&#x34;&#x39;&#x38;&#x31;&#48;&#56;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#109;">&#49;&#x35;&#48;&#x38;&#x34;&#x39;&#x38;&#x31;&#48;&#56;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#109;</a></code></li>
<li>告知邮箱服务器接收方地址 <code>rcpt to: <a href="mailto:&#x31;&#53;&#49;&#56;&#57;&#x31;&#x32;&#49;&#56;&#56;&#x35;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;">&#x31;&#53;&#49;&#56;&#57;&#x31;&#x32;&#49;&#56;&#56;&#x35;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;</a></code></li>
<li>发送数据命令: data</li>
<li>指定主题: subject</li>
<li>换行后输入正文内容</li>
<li>输入quit,结束发送</li>
</ol>
<h2 id="提取需求"><a href="#提取需求" class="headerlink" title="提取需求"></a>提取需求</h2><p>分析完整个流程后，发送邮箱的基本需求也就明了了。</p>
<ul>
<li>首先我需要连接到smtp.qq.com:25这个服务器上</li>
<li>发送命令到服务器上</li>
<li>接收服务返回的数据</li>
</ul>
<p>在服务器连接上，我们使用socket进行连接。</p>
<ol>
<li>使用socket去connect对应的ip:port</li>
<li>发送使用send()</li>
<li>接收使用recv()</li>
</ol>
<h1 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h1><p>我们需要对外两个接口:</p>
<ol>
<li>initsocket 初始化连接</li>
<li>SendVerificationCode 发送验证码</li>
</ol>
<h2 id="初始化socket"><a href="#初始化socket" class="headerlink" title="初始化socket"></a>初始化socket</h2><p>使用socket是为了连接QQ邮件服务器，这里作为我们仅是作为客户端，使用服务器来发送邮件的。但是对于socket而言，只接收ip与Port来进行初始化。因此，我们需要将smtp.qq.com这个域名进行有效的转化，才可以初始化socket。<br>我们可以定义一个private的函数: HostNameToIp(const std::string&amp; hostname) 来进行域名与IP的转化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMail::initSocket</span><span class="params">(<span class="keyword">const</span> std::string &amp;Host, <span class="keyword">const</span> <span class="keyword">int</span> &amp;Port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> std::string Ip = <span class="built_in">HostNameToIp</span>(Host);</span><br><span class="line">    ser_sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ser_sock  &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server: create socket error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_address, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(server_address));</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_port = <span class="built_in">htons</span>(Port);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, Ip.<span class="built_in">c_str</span>(), &amp;server_address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">connect</span>(ser_sock, (struct sockaddr*)&amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>(server_address));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server: connect failed! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> std::string <span class="title">SendMail::HostNameToIp</span><span class="params">(<span class="keyword">const</span> std::string&amp; hostname)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">host</span>;</span></span><br><span class="line">    std::string resIp = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IP地址的正则匹配表达式</span></span><br><span class="line">    <span class="function">std::regex <span class="title">ip_match</span><span class="params">(<span class="string">&quot;^(?:[01]?\\d&#123;1,2&#125;|2(?:[0-4][0-9]|5[0-5]))(?:\\.(?:[01]?\\d&#123;1,2&#125;|2(?:[0-4][0-9]|5[0-5])))&#123;3&#125;$&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 判断是否为IP,若是IP，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(hostname, ip_match)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;successfully&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> hostname;</span><br><span class="line">    &#125;</span><br><span class="line">    host = <span class="built_in">gethostbyname</span>(hostname.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (host-&gt;h_addrtype != AF_INET) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resolved domain name is not IPV4!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> resIp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; host-&gt;h_addr_list[i]; i++) &#123;</span><br><span class="line">        resIp = <span class="built_in">inet_ntoa</span>(*(struct in_addr*) host-&gt;h_addr_list[i]);</span><br><span class="line">        <span class="keyword">if</span> (resIp != <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> resIp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resIp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证码发送"><a href="#验证码发送" class="headerlink" title="验证码发送"></a>验证码发送</h2><p>这是一个public接口，其内部封装了三个功能: 发送、接收、验证码生成。明确的属性分类，有效降低心智负担。</p>
<h3 id="发送与接收"><a href="#发送与接收" class="headerlink" title="发送与接收"></a>发送与接收</h3><p>发送封装成一个private函数，通过返回值确认是否发送成功。<br>接收也是一样，不过需要留意的是: 由于邮件服务器返回的不是一个常规的字符串(包含转义字符的字符串)，因此不可以使用sizeof来获取接收的长度，而应使用strlen来获取。<br>具体实现如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMail::sendMsg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="built_in">send</span>(ser_sock, msg, <span class="built_in">strlen</span>(msg), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server: send message error !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(message, <span class="number">0x00</span>, BUFSIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMail::recvMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(message, <span class="number">0x00</span>, BUFSIZE);</span><br><span class="line">    ret = <span class="built_in">recv</span>(ser_sock, message, BUFSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server: recv failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证码生成"><a href="#验证码生成" class="headerlink" title="验证码生成"></a>验证码生成</h3><p>验证码生成采用了六位随机数，来实现。验证码发送后，本地变量进行保存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMail::GenerateVerificationCode</span><span class="params">(<span class="keyword">const</span> std::string&amp; mail)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">long</span> num = (<span class="built_in">rand</span>()%(MAXNUM - MINNUM + <span class="number">1</span>)) + MINNUM;</span><br><span class="line">    VerficationCode = std::<span class="built_in">to_string</span>(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="功能整合"><a href="#功能整合" class="headerlink" title="功能整合"></a>功能整合</h3><p>将三个功能全部整合到public接口SendVerificationMail()中:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMail::SendVerificationMail</span><span class="params">(<span class="keyword">const</span> std::string&amp; mail)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;HELO qq.com\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">recvMsg</span>();</span><br><span class="line">    <span class="comment">// 验证登陆</span></span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;auth login\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">recvMsg</span>();</span><br><span class="line">    <span class="comment">// 用户名(bash64编码)</span></span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;MTUwODQ5ODEwOEBxcS5jb20=&quot;</span>);</span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">recvMsg</span>();</span><br><span class="line">    <span class="comment">// 密码(bash64编码)</span></span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;xxxxxxxx&quot;</span>);</span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">recvMsg</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送方邮箱配置</span></span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;mail from: &lt;&quot;</span>);</span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;1508498108@qq.com&quot;</span>);</span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">recvMsg</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收方邮箱配置</span></span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;rcpt to: &lt;&quot;</span>);</span><br><span class="line">    <span class="built_in">sendMsg</span>(mail.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">recvMsg</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="built_in">GenerateVerificationCode</span>(mail);</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始发送邮件内容</span></span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;data\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;subject: Verfication Code\r\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送的生成的六位验证码</span></span><br><span class="line">    <span class="built_in">sendMsg</span>(VerficationCode.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">sendMsg</span>(<span class="string">&quot;\r\n.\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">recvMsg</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="添加限制"><a href="#添加限制" class="headerlink" title="添加限制"></a>添加限制</h1><p>显然，对于单人使用而言，这些功能，已然可以全部覆盖需求。回归我们之前的问题: 为什么需要这些依赖?我们可以设想一个场景: 这是一个注册界面，十个用户都需要去使用你的这个SendVerificationCode来获取验证码，以及最后的验证需求。但是你仅仅使用了一个本地变量去存储它们，本地变量一直在改变，直到最后一个用户邮件发送完成。到比对验证码时，只有最后一名用户可以注册成功。如此来看，上面的接口，已然无法覆盖我们的需求。这里我们就可以使用unordered_map，用以完成我们的需求。以邮件地址为键，验证码为值。若是使用完成，则将其中map中删除。<br>应用设计到这里，似乎已经完成了。但是，我们仍需考虑一个问题: 邮件验证码，是否可以不断的请求发送。显示这是行不通，因为这对服务器资源是一种无意义的消耗。因此，我们需要引入定时器来为每个验证码设定一个过期时间，即在一定时间范围内验证码都是有效的。这样，也同样有效降低了服务的负担。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>这里，我们使用时间堆定时器。这是一个基于优先队列完成的时间堆，可以存储多个定时器。具体的代码实现请看: <a href="https://github.com/WDXC/Mail_VerifyCode/blob/main/mail/code/TimerHeap.h">TimeHeap</a><br>引入定时器，主要需要两个函数: AddTimer()与TicK()。通过它们来完成对于定时器的设定。</p>
<h2 id="SIGALRM信号"><a href="#SIGALRM信号" class="headerlink" title="SIGALRM信号"></a>SIGALRM信号</h2><p>在AddTimer()之后，我们就需要为其提供alarm函数，设定闹钟的时间。<br>在处理signal函数时，由于其所需要的回调函数是一个static函数。因此，我们就通过单例模式来调用其内部函数。</p>
<p>若是想要了解全部的代码: <a href="https://github.com/WDXC/Mail_VerifyCode">项目地址</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用socket完成数据的收发，并没有什么难度。主要设计关键在于设置验证码的限制措施:</p>
<ol>
<li>确保不会在同一时间内向服务器发送大量获取验证码请求</li>
<li>确保验证码会在使用完成后被有效的删除，不会被重复的使用</li>
</ol>
<p>这仅仅是笔者所能考虑到的范畴，若是应用到真正落实到应用，可能需要的限制更多。<br>笔者技术比较菜，若是文中在在什么错误，还请大家多多批评与指正。邮箱地址: <a href="mailto:&#x31;&#x35;&#x30;&#56;&#x34;&#x39;&#56;&#x31;&#x30;&#56;&#122;&#116;&#x79;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;">&#x31;&#x35;&#x30;&#56;&#x34;&#x39;&#56;&#x31;&#x30;&#56;&#122;&#116;&#x79;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;</a></p>
]]></content>
      <categories>
        <category>apply</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者——消费者问题</title>
    <url>/2021/system1/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>系统中有一组生产者进程与一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。生产者、消费者同时共享一个初始为空，大小为n的缓冲区,否则必须等待。只有缓冲区不空时，消费者才可以从中取出产品，否则必须等待。<br>如下图所示：<br><img data-src="https://7894651.xyz/Producer_Customer/pic4.png" alt="avatar"></p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>这个问题的关键就在于是要保证生产者不会在缓冲区满时加数据，同时消费者也不会在缓冲区为空时消费数据。对于缓冲区而言，它是一个临界资源，因而各个进程必须互斥的访问。这样我们就需要使用互斥量(mutex),这里如果不使用mutex就会导致竞争条件的出现，进而引发死锁。加入mutex后，就可以限制只有一个进程可以被执行。如图所示：<br><img data-src="https://7894651.xyz/Producer_Customer/pic5.png" alt="avatar"><br>若要解决该问题，就必须让生产者在缓冲区满时休眠(亦或者是直接放弃数据),等到下次消费者消费缓冲区中的数据时，生产者才可以被唤醒，开始往缓冲区中添加数据。同理，也可以让消费者在缓冲区为空时进入休眠状态，等到生产者往缓冲区添加数据之后，再唤醒消费者。常见的方法有：信号灯法、管程法。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>对于C++来说，并没有提供管程。如果对管程实现感兴趣的，可以参考这篇<a href="http://dengzuoheng.github.io/cpp-concurency-pattern-6-monitor">文章</a><br>对于信号灯法，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex g_mutex;</span><br><span class="line">condition_variable Product;  </span><br><span class="line">condition_variable Customer;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; share_buff; <span class="comment">// 共享缓冲区</span></span><br><span class="line"><span class="keyword">int</span> maxSize = <span class="number">20</span>;  <span class="comment">// 共享缓冲区大小为20</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 与条件变量所搭配的锁</span></span><br><span class="line">	<span class="function">unique_lock&lt;mutex&gt; <span class="title">lck</span><span class="params">(g_mutex)</span></span>; </span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">		Product.<span class="built_in">wait</span>(lck,[]&#123;<span class="keyword">return</span> share_buff.<span class="built_in">size</span>() != maxSize;&#125;);</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-&gt;producer &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; : &quot;</span>;</span><br><span class="line">		cout &lt;&lt; share_buff.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		share_buff.<span class="built_in">push</span>(share_buff.<span class="built_in">size</span>());</span><br><span class="line">		Customer.<span class="built_in">notify_all</span>(); </span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">if</span> (count % <span class="number">20</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;===========================================&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;	THIS IS CUSTOMER&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;===========================================&quot;</span>&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	lck.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">unique_lock&lt;mutex&gt; <span class="title">lck</span><span class="params">(g_mutex)</span></span>; </span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">700</span>)); </span><br><span class="line">		Customer.<span class="built_in">wait</span>(lck,[] &#123;<span class="keyword">return</span> share_buff.<span class="built_in">size</span>() != <span class="number">0</span>;&#125; );</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Customer &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">		cout &lt;&lt; share_buff.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		share_buff.<span class="built_in">pop</span>();</span><br><span class="line">		Product.<span class="built_in">notify_all</span>(); </span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">if</span> (count % <span class="number">20</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;===========================================&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;	THIS IS Producter&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;===========================================&quot;</span>&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumerThread</span><span class="params">()</span></span>&#123; <span class="built_in">customers</span>();&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producerThread</span><span class="params">()</span> </span>&#123;<span class="built_in">producer</span>();&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(consumerThread)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(consumerThread)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="问题推广"><a href="#问题推广" class="headerlink" title="问题推广"></a>问题推广</h1><p>上面我们是根据单个生产者与消费者进行讨论的，那么对于多个生产者或多个消费者时。我们又该如何处理</p>
<h2 id="多生产者单消费者（MPSC）"><a href="#多生产者单消费者（MPSC）" class="headerlink" title="多生产者单消费者（MPSC）"></a>多生产者单消费者（MPSC）</h2><p>对于多对于多生产者单消费者来说，多生产者之间具有互斥关系，所以这里需要一个互斥锁来实现缓冲区的互斥访问，那么具体的实现方式就是在单生产者单消费者的基础之上，加一个互斥信号量useQueue<br>如果采用信号量来实现的话可以如下：</p>
<ul>
<li>emptyCount = N ; fullCount = 0 ; useQueue = 1<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">produce:</span><br><span class="line">    <span class="built_in">P</span>(emptyCount)<span class="comment">//信号量emptyCount减一</span></span><br><span class="line">    <span class="built_in">P</span>(useQueue)<span class="comment">//二值信号量useQueue减一，变为0（其他线程不能进入缓冲区，阻塞状态）</span></span><br><span class="line">    <span class="built_in">putItemIntoQueue</span>(item)<span class="comment">//执行put操作</span></span><br><span class="line">    <span class="built_in">V</span>(useQueue)<span class="comment">//二值信号量useQueue加一，变为1（其他线程可以进入缓冲区）</span></span><br><span class="line">    <span class="built_in">V</span>(fullCount)<span class="comment">//信号量fullCount加一</span></span><br><span class="line">consume:</span><br><span class="line">    <span class="built_in">P</span>(fullCount)<span class="comment">//fullCount -= 1</span></span><br><span class="line">    item ← <span class="built_in">getItemFromQueue</span>()</span><br><span class="line">    <span class="built_in">V</span>(emptyCount)<span class="comment">//emptyCount += 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="单生产者多消费者（SPMC）"><a href="#单生产者多消费者（SPMC）" class="headerlink" title="单生产者多消费者（SPMC）"></a>单生产者多消费者（SPMC）</h2><p>对于单生产者多消费者同多生产者多消费者</p>
<ul>
<li>emptyCount = N ; fullCount = 0 ; useQueue = 1<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">produce:</span><br><span class="line">    <span class="built_in">P</span>(emptyCount)<span class="comment">//信号量emptyCount减一</span></span><br><span class="line">    <span class="built_in">putItemIntoQueue</span>(item)<span class="comment">//执行put操作</span></span><br><span class="line">    <span class="built_in">V</span>(fullCount)<span class="comment">//信号量fullCount加一</span></span><br><span class="line">consume:</span><br><span class="line">    <span class="built_in">P</span>(fullCount)<span class="comment">//fullCount -= 1</span></span><br><span class="line">    <span class="built_in">P</span>(useQueue)<span class="comment">//二值信号量useQueue减一，变为0（其他线程不能进入缓冲区，阻塞状态）</span></span><br><span class="line">    item ← <span class="built_in">getItemFromQueue</span>()</span><br><span class="line">    <span class="built_in">V</span>(useQueue)<span class="comment">//二值信号量useQueue加一，变为1（其他线程可以进入缓冲区）</span></span><br><span class="line">    <span class="built_in">V</span>(emptyCount)<span class="comment">//emptyCount += 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多生产者多消费者（MPMC）-单缓冲区-SB"><a href="#多生产者多消费者（MPMC）-单缓冲区-SB" class="headerlink" title="多生产者多消费者（MPMC）-单缓冲区(SB)"></a>多生产者多消费者（MPMC）-单缓冲区(SB)</h2><p>对于多生产者多消费者问题，是一个同步+互斥问题，不仅需要生产者和消费者之间的同步协作，还需要实现对缓冲区资源的互斥访问。<br>采用信号量：</p>
<ul>
<li>emptyCount = N ; fullCount = 0 ; useQueue = 1<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">produce:</span><br><span class="line">    <span class="built_in">P</span>(emptyCount)<span class="comment">//信号量emptyCount减一</span></span><br><span class="line">    <span class="built_in">P</span>(useQueue)<span class="comment">//二值信号量useQueue减一，变为0（其他线程不能进入缓冲区，阻塞状态）</span></span><br><span class="line">    <span class="built_in">putItemIntoQueue</span>(item)<span class="comment">//执行put操作</span></span><br><span class="line">    <span class="built_in">V</span>(useQueue)<span class="comment">//二值信号量useQueue加一，变为1（其他线程可以进入缓冲区）</span></span><br><span class="line">    <span class="built_in">V</span>(fullCount)<span class="comment">//信号量fullCount加一</span></span><br><span class="line">consume:</span><br><span class="line">    <span class="built_in">P</span>(fullCount)<span class="comment">//fullCount -= 1</span></span><br><span class="line">    <span class="built_in">P</span>(useQueue)<span class="comment">//二值信号量useQueue减一，变为0（其他线程不能进入缓冲区，阻塞状态）</span></span><br><span class="line">    item ← <span class="built_in">getItemFromQueue</span>()</span><br><span class="line">    <span class="built_in">V</span>(useQueue)<span class="comment">//二值信号量useQueue加一，变为1（其他线程可以进入缓冲区）</span></span><br><span class="line">    <span class="built_in">V</span>(emptyCount)<span class="comment">//emptyCount += 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Read Notes</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学家就餐问题</title>
    <url>/2021/system2/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>&emsp;&emsp;哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每位哲学家之间各有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和五根筷子而不是意大利面和餐叉来描述，因为吃米饭必须用两根筷子。这个问题不考虑意大利面有多少，也不考虑哲学家的胃有多大。假设两者都是无限大。<br>&emsp;&emsp;问题在于如何设计一套规则，使得在哲学家们在完全不交谈，也就是无法知道其他人可能在什么时候要吃饭或者思考的情况下，可以在这两种状态下永远交替下去。<br>哲学家就餐——流程：<br>&emsp;&emsp;1. 先拿起左手的筷子<br>&emsp;&emsp;2. 再拿起右手的筷子<br>&emsp;&emsp;3. 若筷子正好被其它人所使用，则需要等待其它人使用结束<br>&emsp;&emsp;4. 吃完后，需将筷子放加原位<br>如下图所示：<br><img data-src="https://7894651.xyz/philosophers/pic.png" alt="avatar"></p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>&emsp;&emsp;系统中有五位哲学家，这五位哲学家与左右邻居对其中间筷子的访问是互斥的关系。这里的哲学家需要同时持有两个临界资源才能开始吃饭，如果解决不当就会导致死锁情况：所有哲学家都饿了，每个哲学家都是左手拿一个筷子，一直在等右手的筷子。(亦可相反)。<br>&emsp;&emsp;主要是使用锁对两个筷子进行限制，从而避免了死锁情况的发生。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>原语代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Pi</span>() &#123;                                <span class="comment">// 哲学家i的进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(mutex);                     <span class="comment">// 互斥地取筷子</span></span><br><span class="line">        <span class="built_in">P</span>(chopstick[i]);              <span class="comment">// 拿左</span></span><br><span class="line">        <span class="built_in">P</span>(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);    <span class="comment">// 拿右</span></span><br><span class="line">        <span class="built_in">V</span>(mutex);                     <span class="comment">// 已经取好筷子</span></span><br><span class="line">        吃饭</span><br><span class="line">        <span class="built_in">V</span>(chopstick[i]);              <span class="comment">// 放左</span></span><br><span class="line">        <span class="built_in">V</span>(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);    <span class="comment">// 放右</span></span><br><span class="line">        思考</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++ 代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> no_of_philosophers = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chopstics</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Chopstics</span>()&#123;;&#125;</span><br><span class="line">        std::mutex mu;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> eat = [](Chopstics &amp;left_chopstics, Chopstics&amp; right_chopstics, <span class="keyword">int</span> philosopher_number) &#123;</span><br><span class="line">        </span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; <span class="built_in">llock</span>(left_chopstics.mu);</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">rlock</span><span class="params">(right_chopstics.mu)</span></span>;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; philosopher_number &lt;&lt; <span class="string">&quot; is eating&quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        std::<span class="function">chrono::milliseconds <span class="title">timeout</span><span class="params">(<span class="number">1500</span>)</span></span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(timeout);</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; philosopher_number &lt;&lt; <span class="string">&quot; has finished eating&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//create chopstics</span></span><br><span class="line">    Chopstics chp[no_of_philosophers];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//create philosophers</span></span><br><span class="line">    std::thread philosopher[no_of_philosophers];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Philosophers Start reading</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; (<span class="number">0</span>+<span class="number">1</span>) &lt;&lt; <span class="string">&quot; is reading..&quot;</span> &lt;&lt; endl;</span><br><span class="line">    philosopher[<span class="number">0</span>] = std::<span class="built_in">thread</span>(eat, std::<span class="built_in">ref</span>(chp[<span class="number">0</span>]), std::<span class="built_in">ref</span>(chp[no_of_philosophers<span class="number">-1</span>]), (<span class="number">0</span>+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; no_of_philosophers; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Philosopher &quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot; is reading..&quot;</span> &lt;&lt; endl;</span><br><span class="line">        philosopher[i] = std::<span class="built_in">thread</span>(eat, std::<span class="built_in">ref</span>(chp[i]), std::<span class="built_in">ref</span>(chp[i<span class="number">-1</span>]), (i+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ph: philosopher) &#123;</span><br><span class="line">        ph.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解法推广"><a href="#解法推广" class="headerlink" title="解法推广"></a>解法推广</h1><p>上面提供的仅仅是一种根据原语改编的基本解法，对于哲学家就餐问题，存在多种更加合理且高效的解法。</p>
<h2 id="服务生解法"><a href="#服务生解法" class="headerlink" title="服务生解法"></a>服务生解法</h2><p>&emsp;&emsp;一个简单的解法就是引入服务生，哲学家必须经过他的允许才能拿起餐叉。因为服务生知道哪只餐叉正在使用，所以他能够作出判断避免死锁。<br>&emsp;&emsp;对于此解法的简单演示，假设哲学家依次标号为A至E。如果A和C在吃东西，则有四只餐叉在使用中。B坐在A和C之间，所以两只餐叉都无法使用，而D和E之间有一只空余的餐叉。假设这时D想要吃东西。如果他拿起了第五只餐叉，就有可能发生死锁。相反，如果他征求服务生同意，服务生会让他等待。这样，我们就能保证下次当两把餐叉空余出来时，一定有一位哲学家可以成功的得到一对餐叉，从而避免了死锁</p>
<h2 id="资源分级解法"><a href="#资源分级解法" class="headerlink" title="资源分级解法"></a>资源分级解法</h2><p>&emsp;&emsp;另一个简单的解法是为资源（这里是餐叉）分配一个偏序或者分级的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放，而且保证不会有两个无关资源同时被同一项工作所需要。在哲学家就餐问题中，资源（餐叉）按照某种规则编号为1至5，每一个工作单元（哲学家）总是先拿起左右两边编号较低的餐叉，再拿编号较高的。用完餐叉后，他总是先放下编号较高的餐叉，再放下编号较低的。在这种情况下，当四位哲学家同时拿起他们手边编号较低的餐叉时，只有编号最高的餐叉留在桌上，从而第五位哲学家就不能使用任何一只餐叉了。而且，只有一位哲学家能使用最高编号的餐叉，所以他能使用两只餐叉用餐。当他吃完后，他会先放下编号最高的餐叉，再放下编号较低的餐叉，从而让另一位哲学家拿起后边的这只开始吃东西。<br>&emsp;&emsp;尽管资源分级能避免死锁，但这种策略并不总是实用的，特别是当所需资源的列表并不是事先知道的时候。例如，假设一个工作单元拿着资源3和5，并决定需要资源2，则必须先要释放5，之后释放3，才能得到2，之后必须重新按顺序获取3和5。对需要访问大量数据库记录的计算机程序来说，如果需要先释放高编号的记录才能访问新的记录，那么运行效率就不会高，因此这种方法在这里并不实用。</p>
<h2 id="Chandy-Misra解法"><a href="#Chandy-Misra解法" class="headerlink" title="Chandy/Misra解法"></a>Chandy/Misra解法</h2><p>允许任意的用户争用任意数量的资源。与资源分级解法不同的是，这里编号可以是任意的<br>&emsp;&emsp; 1. 把餐叉凑成对，让要吃的人先吃，没餐叉的人得到一张换餐叉券<br>&emsp;&emsp; 2. 饿了，把换餐叉券交给有餐叉的人，有餐叉的人吃饱了会把餐叉交给有券的人。有了券的人不会再得到第二张券<br>&emsp;&emsp; 3. 保证有餐叉的都有得吃<br>这个解法允许很大的并行性，适用于任意大的问题</p>
]]></content>
      <categories>
        <category>Read Notes</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业逸事</title>
    <url>/2022/%E6%AF%95%E4%B8%9A%E9%80%B8%E4%BA%8B/</url>
    <content><![CDATA[<p><img data-src="https://7894651.xyz/%E6%AF%95%E4%B8%9A%E9%80%B8%E4%BA%8B/graduate.jpg" alt="avatar"></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>&emsp;&emsp;大学四年，张未明同学总是与宿舍里的好朋友们称兄道弟，总是一起的出入教室与实验楼。当然，这样”广泛”的交际圈也成功控制了他本就有限的异性朋友圈。或许是不多，才会更加显得珍贵。这不是正好赶上毕业了，送花的这个香风也是吹动了他那活络的心思。然而，极少送礼的他却是根本不了解这送花的方法。他原想着随便买上一束鲜花也就可以了，心念通达也就达到目的了，可这并没有那样的简单。。。。。。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>&emsp;&emsp;那么就算是送花也是要有较为详尽的规划的才好，这样即不会让他显得太过无措，也不会让朋友觉着太惊讶。原先他是打算送给与他关系最好的异性朋友的，但又害怕伤了关系又是作罢。思来相去，一个清晰的人影浮于脑海之中，那就是社团之中一起参与活动的她。原本刚刚加入社团时，本就是抱着混点社团学分的心思。第一次社团会议，社长就宣布了社团的规定，无缘由不可随意缺席社团活动与社团会议，此外每次社团的签到都必须是本人签字才可以作效，接着会议社长又说：“由于考虑到大家白天可能都有课程安排，所以我们的社团会议会安排在每周三晚上，若是不参加将会被社团清退!”。张未明在底下听着真是一阵头大，不由得在心中腹腓了几句:“早知道不来参加这个社团了，这么些个条条框框真是麻烦死了，但是我这么一个优秀青年总不能被社团清退吧，那不是太没面子了，算了，骑驴看唱本咱们走着瞧”。<br>&emsp;&emsp;倒也是奇怪，张未明从抗拒到接受的思想转变似是在那一瞬，大概就是图个热闹想感受感受这校园生活罢了。第一次举办的活动，他就以参与者的身份加入了进去。概是第一次没有太多的经验，仅仅就拿了一个安慰人的优秀奖。这活动也是算是破题了，之后也是熟门熟路参与了不少活动。大量的社团活动与会议中，可算是将他跳脱的一面全部释放了出来，他在这个社团之中也结交了不少的朋友，其中也包括了她。本是一场过路的朋友之情，可是一次次活动，一次次会议游戏都不断的改变着他对她的看法与感情。当时的他并没有感觉太多，只是感觉这是我的一个极好的朋友，他应当珍惜这段朋友之情。随着社团的结束，也不在有社团活动、社团会议的束缚，大学的生活又重新归于平静，随之被平静埋藏的还有他那颗曾经燥动的心。本来大学结束了，离开了学校他也就没有了念想，可是不知是在<font color=red><a href="https://kknews.cc/zh-tw/emotion/3vyxpxo.html">打烊效应</a></font>的作弄之下，还是这段被封存的情感随着毕业的来临，而放开了原有的桎梏。<br>&emsp;&emsp;那般美好的人儿，该是配上怎样的鲜花呢？他这愣头青竟直接想着去买玫瑰，玫瑰可是情花啊，若是送去岂不是让人误解了。凭借着他对于鲜花的深入了解，冥思苦想一阵之后，他发现对于鲜花的认知似乎仅限于”情人节送玫瑰花”、”探病送康乃馨”。虽是无奈，但是去网络上搜罗一番总是会有些收获。浏览诸多帖子之后，也归纳了几个可选的鲜花品类:白玫瑰、粉色康乃馨、棉花、向日葵、满天星。可选的鲜花的有了，购花算是有了明确的目标了。</p>
<h1 id="买花"><a href="#买花" class="headerlink" title="买花"></a>买花</h1><p>&emsp;&emsp;买花这件事情上，张未明也是大姑娘上花轿——头一次。不过，这也不过就是买个鲜花，想来也就是比菜市场买菜高级了些。他先是在地图上搜罗了几家鲜花外送，首先入眼的并不是那艳丽的鲜花，而是各家那高企的花价。外送价格这么高可能是包含着配送的费用，要是线下亲自去购买想必要便宜上许多。心思一动，他便骑着小电驴，按着地图上的位置，去各家探店。他本是逛街的菜鸟，砍价方面的手法也是稚嫩，许是怕是着了奸商的道，想着这次一定要货比三家。路上不知怎么想到: 若是花店老板和电视上的演员似的，可是如何狠得下心来与她砍价。不过这样的忧虑也仅仅在逛店之前，连着几家花店走完，打理花店的人大多是中年的大叔或阿姨，果然电视剧里都是骗人的。各家花店的老板、老板娘们虽然满脸带笑，可开价却都毫不留情，价格最少都是几百，想必他们是有意借着这高价震住我这个买花的新手，从而牟取那可观地利润。张未明他也不回应，就是含糊的敷衍着。几家花店逛完，他心里也大致了解市场行情，又在心中对价格斟酌了几番，这才回头与各家老板进行了轮番的价格拉锯，最终定下了那束粉色的康乃馨。<br><img data-src="https://7894651.xyz/%E6%AF%95%E4%B8%9A%E9%80%B8%E4%BA%8B/flowers.webp" alt="avatar"></p>
<h1 id="赠花"><a href="#赠花" class="headerlink" title="赠花"></a>赠花</h1><p>&emsp;&emsp;这天他起了一个大早，吃了些东西垫补垫补了肚子，简单的收拾了一下行头，便是急匆匆的出门去取花。虽然和她约好了时间，但是第一次送花的他，总是觉着自己哪儿哪儿都不够，心里不断的想着就不觉着取花的时间长了。花店里，老板娘也早已将花准备好了，他拿着花坐在公交车上，感受到别人投来的目光，让他觉着十分的害羞。不时的看一看花儿，想着这毒辣的太阳，要是坐着公交过去，花儿岂不是都蔫了。他又是下了公车，顶着这火热的太阳走到那商场的地下停车场里租了辆新能源汽车。有人说：“近乡情更怯，不敢问来人”，换来描述他就是:”近香情更怯，不敢显痴心”。到校之后，本是以为可以直接进校，谁知进校材料审核不过关，这也断了她在女生宿舍楼下表现一番的机会。不表现就不表现吧，电话联系之后，只能约在了学校大门处见面。<br>&emsp;&emsp;天气炎热，他小心翼翼的捧着花站在了也有着阴凉下。张未明他心里还想着若是材料没有问题，我不就是可以亲自到她楼下送给她了嘛。这样的念想，随着等待也不断的加深，不时的他还向里面张望着，防止走错了校门。等了一会，焦急等待的他仍未看到她的身影，又想着打个电话催一催她，但是这样就显得他自己太不解风情了。因而，他就这样静静地等待了几分钟，那个身材高挑、穿着靓丽，脸上还挂着浅浅微笑的她来了。大概都是许久不曾会面，原先有的千语万言似在这一刻都说不上来。为了缓解尴尬，总不能让女孩子先开口吧。<br>&emsp;&emsp;他抢先说道: “祝你毕业快乐呀!”<br>&emsp;&emsp;”你也一样呀”<br>&emsp;&emsp;”我也不太了解这花，这花束有点小，你可不要嫌弃啊”。<br>&emsp;&emsp;”不会的，不会的，你来祝我毕业快乐就很好”。<br>&emsp;&emsp;他这时也是全然忘记之前准备的内容，开始有一搭没一搭的闲谈着，但是太阳毒辣，他也不想她被晒着，也就想着快点让她回宿舍。<br>&emsp;&emsp;“握个手吧”，他说着。<br>&emsp;&emsp;”嗯”<br>&emsp;&emsp;”你快点回宿舍吧，别晒着了”，他撤下手来就向车子跑去，不忘说道。等到她回身离开，他又远远的目送着她。坐回车中，又回想想刚刚的场景，激动的心情依旧久久不曾散去。<br>&emsp;&emsp;车道漫漫，他细细回望了这所承载他四载青春的大学。<br><img data-src="https://7894651.xyz/%E6%AF%95%E4%B8%9A%E9%80%B8%E4%BA%8B/send_flower.jpg" alt="avatar"></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>毕业</tag>
      </tags>
  </entry>
  <entry>
    <title>Effect_STL 阅读笔记(一)</title>
    <url>/2022/Effect-STL-1/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>C++语言是其实是一个语言的联邦，它既有C语言的强大，又提供了面向对象的方法，方法的灵活实现与复用又是可以通过STL来实现。STL是一个集合，它包含了迭代器、算法、容器等，但最为人所熟知是主要是容器。容器具有着极强的扩展性与适配性，因此学习STL就是对容器的掌握与理解。</p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>STL中提供了多种类型的容器:</p>
<ol>
<li>标准化STL序列容器: vector、deque、list</li>
<li>标准化STL关联容器: set、multiset、map、multimap</li>
<li>非标准化STL容器: rope(重型string)、slist(single list)</li>
<li>非标准化STL关联容器: hash_set、hash_multiset、hash_map、hash_multimap<br>这些个容器之中，平常使用较多的容器是: vector、list、set、map。</li>
</ol>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>STL中容器的分类不仅仅可以通过序列化与关联化来区分，还可以通过内存地址的布局来区分。在STL中主要可以分为两种布局:</p>
<ol>
<li>连续内存</li>
<li>基于节点</li>
</ol>
<p>STL中内存布局为连续内存的有: vector、deque、string。即与数组的内存分布一致。而基于节点的容器，一个内存之中只会存在一个元素，通过指针来连接每个节点，STL之中的容器有: set、multiset、map、multimap、list。</p>
<h2 id="速度衡量"><a href="#速度衡量" class="headerlink" title="速度衡量"></a>速度衡量</h2><p>相对而言非序列化的关联容器，即哈希容器。它可以根据哈希表，快速定位数据的地址，时间复杂为O(1)。若是要使用标准的STL库，则就是使用vector容器，其内存地址连续且支持随机迭代器访问，查询效率高。最后，就是关联容器，基于底层的红黑树，它们也有着极为高效的查询效率。</p>
<h2 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h2><p>若是关联式容器则不存在迭代器失效问题，原因是关联式容器是基于节点式的，因为在插入与删除时，它们从不会使用迭代器。而关联式容器则不同，它们是一段连续内存地址，若是删除某个元素，则会导致此元素之后的元素迭代器失效。</p>
<h2 id="容器泛化"><a href="#容器泛化" class="headerlink" title="容器泛化"></a>容器泛化</h2><p>不要这样做，原因有如下几点:</p>
<ol>
<li>若是泛化，则是提供一个所有迭代皆通用的容器，那么这个容器，则只能使用所有容器的通用功能，极大减少了容器的丰富的拓展功能</li>
<li>不同的迭代之间，迭代器的失效情况是不同的(连续内存与基于节点的容器)</li>
</ol>
<p>使用容器过程之中，若是出现了需要更改容器的需要。那么将容器封装进类中，则是极为明智的。对容器功能封装，对外提供相应的接口暴露。</p>
<h2 id="empty-vs-size"><a href="#empty-vs-size" class="headerlink" title="empty() vs size()"></a>empty() vs size()</h2><p>代码之中常常会写出这样的代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;...&#125;</span><br><span class="line"><span class="keyword">if</span> (obj.<span class="built_in">empty</span>()) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>一般而言，这没有什么区别，它们似乎可以被划上等号。但是STL中List容器却是这个等号之中的意外情况。list之中提供了函数splice(),它可以将一个list链接到另一个list上。若是使用splice()函数之后，list之中元素个数size()就需要重新计算。因此list在设计时，使size()作为了让步，最终结果是splice()操作为O(1),而size()则是O(n)。<br>成员函数empty()，它的操作时间复杂度总是O(1),因此empty()的使用具有更大的时间效率保证。</p>
<h2 id="区间元素"><a href="#区间元素" class="headerlink" title="区间元素"></a>区间元素</h2><p>若是将vector A赋值给vector B，你大概会有如下两种操作:</p>
<ol>
<li>循环对每个元素进行赋值</li>
<li>使用STL提供了copy函数</li>
</ol>
<p>对方法一进行分析，它这样做会有哪些操作产生:</p>
<ol>
<li>每个元素都进行赋值，使用拷贝构造函数，产生临时空间</li>
<li>需要循环n次，时间复杂度O(n)<br>显然个元素的循环赋值，成本极高。</li>
</ol>
<p>方法二分析:</p>
<ol>
<li>调用copy函数</li>
<li>没有使用for循环，但是copy的时间复杂度就是O(n)</li>
</ol>
<p>综合以上两种方法的分析，显然这两个方法并不是多么的优秀。而STL之中提供了一个函数，则正好为其服务: assign()，可以将另一个vector某区间上的元素一次性复制到指定的list上。</p>
<p>区间成员对于单个元素的处理函数，优点也是十分明显的:</p>
<ol>
<li>使用区间成员处理函数，少写循环代码</li>
<li>使用区间成员函数，代码用意更加清晰</li>
</ol>
<p>STL的对于插入删除等操作的方法如下所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**区间创建**/</span></span><br><span class="line">container::<span class="built_in">container</span>(InputIterator begin, InputIterator end);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**区间插入**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">container::insert</span><span class="params">(iterator postion, InputIterator begin, InputIterator end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**区间删除**/</span></span><br><span class="line"><span class="comment">// 序列化容器</span></span><br><span class="line"><span class="function">iterator <span class="title">container::erase</span><span class="params">(iterator begin, iterator end)</span></span>;</span><br><span class="line"><span class="comment">// 关联式容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">container::erase</span><span class="params">(iterator begin, iterator end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**区间赋值**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">container::assign</span><span class="params">(InputIterator begin, InputIterator end)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="容器资源安全"><a href="#容器资源安全" class="headerlink" title="容器资源安全"></a>容器资源安全</h2><p>若是容器包含了一个由new创建的指针，那么它需要在结束时，使用delete去释放掉。若是程序出现异常则会导致，资源的泄漏。因此若是想要避免此情况的发生，我们需要使用智能指针去管理容器中的所有对象，从而保证了安全性。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>STL容器有着许多的应用与变化，若是正确使用与规范化，我们就需要遵守STL的游戏规则。</p>
]]></content>
      <categories>
        <category>Read Notes</category>
      </categories>
      <tags>
        <tag>theory</tag>
      </tags>
  </entry>
  <entry>
    <title>Effect_STL_2</title>
    <url>/2022/Effect-STL-2/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>空间配置器，可能是STL中最是默默无闻的组件了。但是，作为STL组件的基石，若是无法深入了解它，那么在学习STL中也会阻碍不断。有了前期的准备，那么再去了解一下vector与string的使用与规则，那便也是水到渠成的事情了。</p>
<h1 id="空间配置与常用容器"><a href="#空间配置与常用容器" class="headerlink" title="空间配置与常用容器"></a>空间配置与常用容器</h1><p>STL基础空间配置器中，这里主要着重描述Allocator配置子，这里将从两个方面来描述Allocator，它的使用限制与使用场景。</p>
<h2 id="Allocator使用限制"><a href="#Allocator使用限制" class="headerlink" title="Allocator使用限制"></a>Allocator使用限制</h2><p>Allocator原先的作用是管理内存，但是容器设计中却没有得到应用。这就导致了一个问题，即多数容器不会使用配置子去申请空间内存。<br>Eg:</p>
<ol>
<li>若是两个链表都通过alloctor申请了内存</li>
<li>使用过程中，list1持有了list2的元素</li>
<li>使用结束，析构list</li>
<li>必须先释放list2，再释放list1<br>那么问题就出现了，为什么list1可以调用list2的分配子去释放。那么这就是alloctor的限制，即分配子之间必须要等价，也就意味着分配子的所有成员都必须是静态成员。<br>对于配置子的限制可以归纳为以下几点:</li>
<li>分配子也是一个模板，模板参数T代表你为它分配内存的对象类型。</li>
<li>提供类型定义pointer与reference,但是始终让pointer为T*,reference为T&amp;</li>
<li>不要让分配子拥有随着对象改变的状态(pre-object state)。通常，分配子不应为非静态成员</li>
<li>一定要提供rebind模板，因为标准容器依赖该模板。</li>
</ol>
<h2 id="Alloctor应用场景"><a href="#Alloctor应用场景" class="headerlink" title="Alloctor应用场景"></a>Alloctor应用场景</h2><p>当你需要手动去管理你的内存空间时，你就可以使用Allocator去处理。如共享内存场景。<br>当某个容器的都有相应的静态成员函数来执行内存分配与释放操作，使用静态成员管理内存的时，也可以使用Alloctor分配子<br>不过需要谨记分配子allocator的使用限制</p>
<h2 id="多线程下的容器"><a href="#多线程下的容器" class="headerlink" title="多线程下的容器"></a>多线程下的容器</h2><p>多线下的容器，我们可以希望的可以有两点:</p>
<ol>
<li>可以安全的读出</li>
<li>不同的线程可以对不同的容器进行写入<br>当然，这也都是希望，并非你的依赖。<br>多线程若要保证读写问题的正常，就需要为线程上锁。那么若是直接调用lock_guard<mutex>，程序结束时也不一定会释放。但若是将锁封装进类中，通过RAII手法，即保证了锁在程序结束时一定会被释放，锁的正常使用也同样保证了线程的安全。</li>
</ol>
<h2 id="vector与string"><a href="#vector与string" class="headerlink" title="vector与string"></a>vector与string</h2><p>相对于标准之中的数组，我们可以使用更倾向于去使用可以动态扩展的vector或string。<br>vector与string也是十分类似，它们在(需要的size &gt; capacity)时，会自动的以2x的方式去扩容。<br>但这也导致了一个直接的问题，即它们的扩容方式:</p>
<ol>
<li>开一个新空间，将原元素拷贝到新空间之中，</li>
<li>原有的迭代器失效，需要更新迭代器与指针。</li>
<li>析构原先的空间</li>
<li>释放旧内存<br>若是数据量小，还是可以接受的，如果是一个1000这样的数据，其扩容的次数将是2~10次。这样的代价是相对沉重的。<br>vector与string不断的扩容，对运行效能影响是巨大的。因此，STL提供了一个类似于普通数组的解决方案。那就是根据数据量预先分配指定大小的空间，这样就可以有效避免数据的复杂拷贝。</li>
</ol>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>通常string 内部的实现是通过引用计数的方式来实现的，这样的好处是消除不必须的内存分配与不必须的内存拷贝。<br>但这同样埋下了多线程下使用string的坑，若是我在多线程中使用string，那么引用计数将会导致数据的死锁，从而引发程序的崩溃。<br>对于string的设计方式有许多，这样设计上的区别总结如下:</p>
<ol>
<li>string 的值可能被引用计数，也可能不会。(默认是会的)</li>
<li>string对象大小的范围可以是一个char*指针大小的1~7倍</li>
<li>创建一个新的字符串可能需要零次、一次或两次的动态内存分配</li>
<li>string 对象可能共享，也可能不共享其大小与容量</li>
</ol>
<h2 id="swap清除冗余"><a href="#swap清除冗余" class="headerlink" title="swap清除冗余"></a>swap清除冗余</h2><p>前文我们提及vector与swap由于扩容的因素，可能导致最后的capacity过大。若是想要空间上的浪费，我们最好的方法即是通过使用swap的方法去清除，从而做到shrink to fit。<br>方法:</p>
<ol>
<li>使用一个临时变量去置换目标值</li>
<li>由于目标值的因素，不会存在多余的空间</li>
<li>交换完成后，数据空间被收缩，临时变量被销毁</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>vecotr与string 都是日常开发时，最常使用的容器。除了熟练的掌握之外，对于其内里的实现与使用规则也是需要深入理解的。</p>
]]></content>
      <categories>
        <category>Read Notes</category>
      </categories>
      <tags>
        <tag>theory</tag>
      </tags>
  </entry>
</search>
