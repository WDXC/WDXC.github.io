<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"qfxul.cn",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Effective C++ 读书笔记-I"><meta property="og:type" content="article"><meta property="og:title" content="Effective-C++ Reading Notes"><meta property="og:url" content="https://qfxul.cn/2021/Effective-C-Read-Note/index.html"><meta property="og:site_name" content="Rabbet"><meta property="og:description" content="Effective C++ 读书笔记-I"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://7894651.xyz/effective/pic.png"><meta property="og:image" content="https://7894651.xyz/effective/pic1.png"><meta property="og:image" content="https://7894651.xyz/effective/pic2.png"><meta property="article:published_time" content="2021-03-23T00:27:00.000Z"><meta property="article:modified_time" content="2021-06-08T02:17:41.626Z"><meta property="article:author" content="Rabbet"><meta property="article:tag" content="theory"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://7894651.xyz/effective/pic.png"><link rel="canonical" href="https://qfxul.cn/2021/Effective-C-Read-Note/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Effective-C++ Reading Notes | Rabbet</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a target="_blank" rel="noopener" href="https://github.com/WDXC" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Rabbet</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">悦已者</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">9</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">26</span></a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qfxul.cn/2021/Effective-C-Read-Note/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/header.jpg"><meta itemprop="name" content="Rabbet"><meta itemprop="description" content="个人Blog网站"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Rabbet"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Effective-C++ Reading Notes</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-23 08:27:00" itemprop="dateCreated datePublished" datetime="2021-03-23T08:27:00+08:00">2021-03-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-06-08 10:17:41" itemprop="dateModified" datetime="2021-06-08T10:17:41+08:00">2021-06-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Read-Notes/" itemprop="url" rel="index"><span itemprop="name">Read Notes</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span><div class="post-description">Effective C++ 读书笔记-I</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="第一章-让自己习惯C"><a href="#第一章-让自己习惯C" class="headerlink" title="第一章 让自己习惯C++"></a><center>第一章 让自己习惯C++</center></h1><h2 id="条款一：视C-为一个语言联邦"><a href="#条款一：视C-为一个语言联邦" class="headerlink" title="条款一：视C++为一个语言联邦"></a>条款一：视C++为一个语言联邦</h2><p>&emsp;&emsp;最初，C++仅是C加上了一些面象对象的特性。经历多年的发展，随着大量特性与功能的加入，使得C++成为了一个无可匹敌的工具。但也是这些特性与功能，会让我们困惑于，我们应如何使用它们，该如何理解这样一个复杂的语言呢？<br>&emsp;&emsp;最简单的方法就是将C++视为一个相关语言的组成的一个联邦，对于C++来说，它大致由四个部分组成：</p><ul><li>C语言<ul><li>作为C++的基础。C++中的区块、语句、预处理器、内置数据类型、数组、指针等皆是来自于C。部分特性展示:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> k 45</span></span><br><span class="line"><span class="keyword">double</span> blance[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br></pre></td></tr></table></figure></li></ul></li><li>Object-Oriented C++<ul><li>在初始C with Classes,缺乏真正的面向对象思想。因此加入了:class(包括构造与析构)、封装(encapulation)、继承(inheritance)、多态(polymorphism)…等,从而符合面向对象设计的古典守则。部分特性展示:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    ~<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> :</span> <span class="keyword">public</span> test &#123;</span><br><span class="line">  <span class="comment">// 封装</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> k</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>Template C++<ul><li>这是C++ 泛型编程部分，它们威力强大。它们也带来了新的编程范型，也就是template metaprogramming(模板元编程)。部分特性展示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span> <span class="params">(T a,T b)</span> </span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>&lt;</span>T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>STL<ul><li>这是Template 程序库，它由六大组件构成。它们有着严格的要求，与它们工作时，我们也必须遵守它们的条约。六大组件图：<br><img data-src="https://7894651.xyz/effective/pic.png" alt="avatar"><br><font color="red"><strong>C++语言的高效编程需要根据使用它的不同部分不断变化的。</strong></font></li></ul></li></ul><h2 id="条款二：尽量以const、enum、inline替换-define"><a href="#条款二：尽量以const、enum、inline替换-define" class="headerlink" title="条款二：尽量以const、enum、inline替换#define"></a>条款二：尽量以const、enum、inline替换#define</h2><p>&emsp;&emsp;#define属于一个从C继承而来的特性，那么说明我们对它还是存在一定的需求的。但是对于现代版本的C++来说，它存在了一些我们不得不去替换它的原因。</p><ol><li>#define会盲目替换目标码</li></ol><ul><li>可以使用一个常量来替换宏定义，这样就会避免出现多个目标码的情况。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 2</span></span><br><span class="line">替换为</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>常量字符串最好使用std::string 替换 char *</li></ol><ul><li>char * 仅是声明了一个char指针指向字符串，C++中提供了专门处理字符串的类型即std::string。非必要则默认使用std::string。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//最好替换为</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> std::string <span class="title">test</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>#define 不提供任何的封装性</li></ol><ul><li>由于#define不重视作用域，可以被随意调用，因此它不具备封装性。我们可以使用static const为class创建专属变量，限制作用域实现封装。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// static 限制作用域</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> demo = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>#define无法阻止reference或pointer指向某个常量</li></ol><ul><li>可以通过enum来实现这个约束。</li></ul><ol start="5"><li>形似函数的宏会带来意想不到的错误</li></ol><ul><li>使用inline替换，它遵守作用域与访问规则。</li></ul><h2 id="条款三：尽可能使用const"><a href="#条款三：尽可能使用const" class="headerlink" title="条款三：尽可能使用const"></a>条款三：尽可能使用const</h2><p>&emsp;&emsp;const是一件奇妙的关键字，它给所有被修饰对象添加了一个约束，即不可被改动。编译器会严格的帮你执行这个约束直至程序结束。<br>&emsp;&emsp;使用const修饰变量，我们常用的两种方法:Top-level const 与 Low-level const;</p><ul><li>顶层const (Top-level const)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 顶层const</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> b = &amp;a;</span><br></pre></td></tr></table></figure><ul><li>const所修饰的变量<strong>本身</strong>是一个常量无法修改,指的是指针。</li></ul></li><li>底层const(Low-level const)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 底层const,它存在两种写法(根据习惯)</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *b = &amp;a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *b = &amp;a;</span><br></pre></td></tr></table></figure><ul><li>const所修饰的变量<strong>所指向的对象</strong>是一个常量，指的是变量。</li></ul></li></ul><p>&emsp;&emsp;根据const的性质，合理的使用const。有利于我们侦测代码中的错误，避免一些类似于”==”打成”=”的低级错误。<br>&emsp;&emsp;使用好const也是编写高效代码的关键其原因有二：第一，<font color="red">它使得class接口比较容易理解</font>，清晰的知道什么可以改动，什么不可以；第二，<font color="red">使得操作const对象成为可能</font>。</p><p>&emsp;&emsp;在const与non-const有着同等的实现时，<font color="red">我们最好使用non-const版本去调用const版本</font>。倘若我们使用const版本调用non-const版本，我们岂不是违背了const的性质。当然有人说，可以使用转型不就可以了。但是转型之中又存在了安全性与破坏类型系统的风险，因此，使用non-const版本去调用const版本就成了优选。这样还成功避免了代码重复。</p><h2 id="条款四：-确定对象被使用前已被初始化"><a href="#条款四：-确定对象被使用前已被初始化" class="headerlink" title="条款四： 确定对象被使用前已被初始化"></a>条款四： 确定对象被使用前已被初始化</h2><p>&emsp;&emsp;读取未初始化值将会导致某些意想不到的行为，以及之后一些痛苦的调试过程。对于内置类型我们只能进行手工的初始化，对此之外的初始化操作全都落到了构造函数的身上。<br>&emsp;&emsp;对于构造函数初始化，我们常用的两种方式：赋值初始化、初始化列表。</p><ul><li>赋值初始化<ul><li>一个伪初始化，可能创建临时对象,并调用operator=();<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">  public:</span><br><span class="line">    test(int num);</span><br><span class="line">  private:</span><br><span class="line">    int len;</span><br><span class="line">&#125;;</span><br><span class="line">test::test(int num) &#123;</span><br><span class="line">  len &#x3D; num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>成员列表初始化<ul><li>单纯的初始化，编译器会一一操作初始化列表,在任何显式用户代码之前。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">  public:</span><br><span class="line">    test(int num);</span><br><span class="line">  private:</span><br><span class="line">    int len;</span><br><span class="line">&#125;;</span><br><span class="line">test::test():len(2) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>&emsp;&emsp;对于成员列表初始化操作，对于成员排列顺序应和它们在class中的声明次序相同。当然，如果忘记了排序，编译器也会对列表进行一个重新排序。</p><p>&emsp;&emsp;为了免除”跨编译单元的初始化次序”问题，我们需要使用local static对象替换non-local static对象。其原因是：C++保证函数中local static对象会在”该函数被调用期间”首次遇上该对象的定义式时被初始化。</p><h1 id="第二章-构造、析构、赋值运算"><a href="#第二章-构造、析构、赋值运算" class="headerlink" title="第二章 构造、析构、赋值运算"></a><center>第二章 构造、析构、赋值运算</center></h1><h2 id="条款五：了解C-默默编写并调用哪些函数"><a href="#条款五：了解C-默默编写并调用哪些函数" class="headerlink" title="条款五：了解C++ 默默编写并调用哪些函数"></a>条款五：了解C++ 默默编写并调用哪些函数</h2><p>&emsp;&emsp;当我们创建了一个空类时，它真的是空类？当我们在编译运行时，编译器会为我们创建一个copy函数、一个assignment操作符、一个析构函数还有一个默认构造函数。这些类型都是public类型且它们都是内联(inline)里面。当然，仅在它们被需要的时候，都会被创建出来。这样就像如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Empty</span>() &#123;..&#125;	<span class="comment">// default构造函数</span></span><br><span class="line">		<span class="built_in">Empty</span>(<span class="keyword">const</span> Empty&amp; rhs) &#123;...&#125;	<span class="comment">//copy构造函数</span></span><br><span class="line">		~<span class="built_in">Empty</span>() &#123;...&#125;		<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">		Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs) &#123;...&#125; <span class="comment">//copy assignment操作符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这些默认函数都提供了哪些功能呢？接下来我们将对它们进行一一分析<br>&emsp;&emsp;首先对于copy构造与assignment操作符的作用仅是把每一个non-static(class 中的成员)成员变量拷贝到目标对象。<br>&emsp;&emsp;对于析构函数，它们仅仅是将对象释放掉。由于是编译器提供，所以它的默认属性是<font color="red">virtualness</font>，在多重继承中这可会导致内存泄漏之类的麻烦问题<br>&emsp;&emsp;默认的构造函数被构造出来，仅仅是为了让满足编译器需要。它们并不会被直接合成出来，只有被需要时都会被合成。它也不会显式设定class的init值。</p><p><img data-src="https://7894651.xyz/effective/pic1.png" alt="avatar"></p><h2 id="条款六：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款六：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款六：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款六：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>&emsp;&emsp;在一个系统中，若是每个数据都是独有的。那么对于编译器的copy构造与copy assignment操作符，就应该明确拒绝。<br>&emsp;&emsp;但是如何拒绝编译器提供的版本呢？大师提供了一个思路，那么就是在类的private中将它们声明出来，以此来明确拒绝编译器提供的版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	demo obj1; <span class="comment">// 使用default constructor</span></span><br><span class="line">	<span class="function">demo <span class="title">obj2</span><span class="params">(obj1)</span></span>; <span class="comment">// 企图拷贝obj1 不可以通过编译</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其替换成,避免使用默认版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">demo</span>(<span class="keyword">const</span> demo&amp;); <span class="comment">// 仅声明</span></span><br><span class="line">		demo&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> demo&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是对于class 的member function 与友元函数，依旧可以调用private函数。所以最好的办法，使用继承的办法。将copy构造与copy assignment操作符写入基类，用以防止子类调用它们。*</p><h2 id="条款七：-为多态基类声明virtual-析构函数"><a href="#条款七：-为多态基类声明virtual-析构函数" class="headerlink" title="条款七： 为多态基类声明virtual 析构函数"></a>条款七： 为多态基类声明virtual 析构函数</h2><p>&emsp;&emsp;在条款五中，我们提及了virtualness的虚拟函数会导致灾难的。这节我们将深入理解这个背后的原因。<br>&emsp;&emsp;当deirved class经由一个base class指针被删除，而被base class带着一个non-virtual析构函数，其结果未有定义——实际执行时通常发生的是对象的derived成分没被销毁。<br>&emsp;&emsp;如果派生类中含有基类的成员，但是调用析构函数后。诡异的事情发生了，派生类中的基类对象被销毁了，但是对于派生类对象没有被销毁。这就产生了局布销毁的对象，这也是导致资源泄漏、败坏数据结构的源头。给base class 析构加上虚函数，在delete父类指针时，会先调用子类的析构函数，再调用父类析构函数。<br>&emsp;&emsp;当然，对析构使用虚函数仅在多重继承使用。如果是在单继承，随意的使用虚函数会额外的增加编译器的负担。<br><img data-src="https://7894651.xyz/effective/pic2.png" alt="avatar"></p><h2 id="条款八：-别让异常逃离析构函数"><a href="#条款八：-别让异常逃离析构函数" class="headerlink" title="条款八： 别让异常逃离析构函数"></a>条款八： 别让异常逃离析构函数</h2><p>&emsp;&emsp;如果我们在析构中捕获异常，如果程序正常结束，一切OK。但是如果调用导致异常，析构将会传播这个异常，将程序带向一个不归路。对于这个问题，我们提供了两个办法来解决。<br>&emsp;&emsp;如果出现异常就通过abort()结束程序。强制结束，也就避免了异常从析构传播出去，提前阻止的不明确行为的发生。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test::~<span class="built_in">test</span>() &#123;</span><br><span class="line">	std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一般来说，将异常吞掉会是一个馊主意。但是这种行为可比草率结束程序或发生不明确行为带来的风险好。<br>&emsp;&emsp;对于异常处理，我们最好是提供一个普通函数(非在析构函数中)来执行这个操作。</p><h2 id="条款九：绝不在构造与析构过程中调用virtual-函数"><a href="#条款九：绝不在构造与析构过程中调用virtual-函数" class="headerlink" title="条款九：绝不在构造与析构过程中调用virtual 函数"></a>条款九：绝不在构造与析构过程中调用virtual 函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transation</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Transation</span>();</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transation::<span class="built_in">Transation</span>() &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">logTransaction</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transation &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTransaction</span>:</span> <span class="keyword">public</span> Transation &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于b来说，作为子类初始化时。一定会对基类成员进行先初始化，但是在基类构造函数最后一行调用了virtual logTransaction,这也是引发错误的点。那么这里就导致b使用了错误版本的logTransaction()。这直接导致的结果是，virtual 将不再是virtual 函数,这也是一条通往不归路的直达列车。<br>&emsp;&emsp;但是如何确保derived class 对象不会调用错误的函数版本？ 确保构造与析构都没有调用virtual 函数，而它们调用的所有函数也都服从这个约束。</p><h2 id="条款十：今operator-返回一个reference-to-this"><a href="#条款十：今operator-返回一个reference-to-this" class="headerlink" title="条款十：今operator= 返回一个reference to * this"></a>条款十：今operator= 返回一个reference to * this</h2><p>&emsp;&emsp;为了实现连续赋值，赋值操作符必须返回一个reference指向操作符的左侧实参;其标准的赋值形式，同样也适用于所有的赋值相关的运算，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款十一：在operator-中处理”自我赋值”"><a href="#条款十一：在operator-中处理”自我赋值”" class="headerlink" title="条款十一：在operator= 中处理”自我赋值”"></a>条款十一：在operator= 中处理”自我赋值”</h2><p>&emsp;&emsp;自我赋值的存在，会在你不注意时引诱你进入一个”在停止使用资源之前意外释放了它”的陷阱。我们以下面代码为例，进行一个理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		Bitmap *pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">	<span class="keyword">delete</span> pb;</span><br><span class="line">	pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; * this与rhd可能是同一个对象。那么不仅删除了当前对象的bitmap，也删除了rhs的bitmap。那么最后 * this 发现自己指向一个已被删除的对象。<br>&emsp;&emsp;为了阻止这种错误，我们可以在这个最前面添加一个”证同测试”,达到检测的目的。具体如这条语句所示：if (this == &amp;rhs) return * this;。由于证同测试使用次数较低，因此，我们使用<code>copy and swap</code>技术。其实现手法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>; <span class="comment">// 交换*this与rhs数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">	Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">	<span class="built_in">swap</span>(temp);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款十二：-复制对象时勿忘其每一个成分"><a href="#条款十二：-复制对象时勿忘其每一个成分" class="headerlink" title="条款十二： 复制对象时勿忘其每一个成分"></a>条款十二： 复制对象时勿忘其每一个成分</h2><p>&emsp;&emsp;如果为class添加一个成员变量，你必须同时修改copying函数,同时也需要修改class中的构造函数。<br>&emsp;&emsp;我们在编写一个copying函数，我们就需要确保:1、复制所有local 成员变量，2、调用所有base classes内的适当的copying 函数。由于大量的copying函数几近相似，有人为了避免代码的重复，就会在一个copying 函数中调用另一个copying函数，这样可能还是无法达到你的目标。对于copy assignment操作符调用copying 函数以及它的反调用，都是不合理且没有意义的。这里最好的办法就是，新建一个成员函数供两者调用，这样就可以安全消除代码的重复问题了。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/theory/" rel="tag"># theory</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/NRV_Opt/" rel="prev" title="NRV优化"><i class="fa fa-chevron-left"></i> NRV优化</a></div><div class="post-nav-item"><a href="/2021/The-Annotated-STL-Sources-2/" rel="next" title="The Annotated STL Sources-2">The Annotated STL Sources-2 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC"><span class="nav-text">第一章 让自己习惯C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE%E4%B8%80%EF%BC%9A%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="nav-text">条款一：视C++为一个语言联邦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%8C%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const%E3%80%81enum%E3%80%81inline%E6%9B%BF%E6%8D%A2-define"><span class="nav-text">条款二：尽量以const、enum、inline替换#define</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE%E4%B8%89%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="nav-text">条款三：尽可能使用const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE%E5%9B%9B%EF%BC%9A-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">条款四： 确定对象被使用前已被初始化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="nav-text">第二章 构造、析构、赋值运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%94%EF%BC%9A%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-text">条款五：了解C++ 默默编写并调用哪些函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE%E5%85%AD%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="nav-text">条款六：若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE%E4%B8%83%EF%BC%9A-%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">条款七： 为多态基类声明virtual 析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE%E5%85%AB%EF%BC%9A-%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">条款八： 别让异常逃离析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE%E4%B9%9D%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual-%E5%87%BD%E6%95%B0"><span class="nav-text">条款九：绝不在构造与析构过程中调用virtual 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%EF%BC%9A%E4%BB%8Aoperator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference-to-this"><span class="nav-text">条款十：今operator&#x3D; 返回一个reference to * this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%B8%80%EF%BC%9A%E5%9C%A8operator-%E4%B8%AD%E5%A4%84%E7%90%86%E2%80%9D%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D"><span class="nav-text">条款十一：在operator&#x3D; 中处理”自我赋值”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%BA%8C%EF%BC%9A-%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="nav-text">条款十二： 复制对象时勿忘其每一个成分</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Rabbet" src="/images/header.jpg"><p class="site-author-name" itemprop="name">Rabbet</p><div class="site-description" itemprop="description">个人Blog网站</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="/1508498108@qq.com" title="E-Mail → 1508498108@qq.com"><i class="fa fa-fw fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Rabbet</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">136k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">2:04</span></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/01/2019 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="本站已安全运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备19033310</a></div></div></footer></div><script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/utils.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/motion.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/schemes/pisces.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/local-search.js"></script><script>document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script>window.addEventListener("load",()=>{quicklink({timeout:3e3,priority:!0,ignores:[e=>e.includes("#"),e=>"https://qfxul.cn/2021/Effective-C-Read-Note/"===e]})})</script></body></html>