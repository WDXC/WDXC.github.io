<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"qfxul.cn",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="C++后端开发"><meta property="og:type" content="article"><meta property="og:title" content="腾讯光子一面"><meta property="og:url" content="https://qfxul.cn/2021/interview_first/index.html"><meta property="og:site_name" content="Rabbet"><meta property="og:description" content="C++后端开发"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-03-17T02:31:00.000Z"><meta property="article:modified_time" content="2021-06-08T02:17:41.594Z"><meta property="article:author" content="Rabbet"><meta property="article:tag" content="interview"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://qfxul.cn/2021/interview_first/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>腾讯光子一面 | Rabbet</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a target="_blank" rel="noopener" href="https://github.com/WDXC" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Rabbet</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Saty Happy</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">6</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">17</span></a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qfxul.cn/2021/interview_first/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/header.jpg"><meta itemprop="name" content="Rabbet"><meta itemprop="description" content="个人Blog网站"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Rabbet"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">腾讯光子一面</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-17 10:31:00" itemprop="dateCreated datePublished" datetime="2021-03-17T10:31:00+08:00">2021-03-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-06-08 10:17:41" itemprop="dateModified" datetime="2021-06-08T10:17:41+08:00">2021-06-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/experience/" itemprop="url" rel="index"><span itemprop="name">experience</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9.8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span><div class="post-description">C++后端开发</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>时间复杂度与空间复杂</li><li>不同的排序的最好与最坏的时间复杂度</li><li>快排<ol><li>如何实现的</li><li>何时会导致快排的最坏时间复杂度</li><li>快排是否稳定，为什么不稳定</li></ol></li><li>了解堆排序吗</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>反转链表(Leetcode ＃206)</li></ul><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++ 基础"></a>C++ 基础</h2><ul><li>C++ 关键字static，它的作用</li><li>C++ 关键字sizeof作用<ul><li>strlen与它的区别</li><li>sizeof(“hello”)与strlen(“hello”)区别</li><li>double<code><em></em></code> (<code></code>a) [3][6]; sizeof(*a)与sizeof(a)的大小</li></ul></li><li>C++ 多态<ul><li>如何实现</li><li>什么是虚函数，什么是虚表和虚拟指针</li><li>内存中的布局是什么样子的</li></ul></li><li>C++ 重载与重写<ul><li>什么是重载，什么是重写</li><li>它们的区别</li><li>重载是否与类有关，重载是如何实现的</li></ul></li><li>C++ new/delete &amp;&amp; malloc/free<ul><li>它们的区别</li></ul></li><li>C++ 的内存分区<ul><li>说一下每个区的作用</li></ul></li><li>C++ 堆栈的区别</li><li>C++ 编译执行的过程</li><li>C++ 深拷贝与浅拷贝的区别</li><li>C++ 11新特性有了解过哪些?</li><li>C++ 动态转换有了解过？<ul><li>常见的几种动态转换说一下</li><li>它们的作用</li></ul></li><li>C++ define 与 typedef<ul><li>define的功能与作用</li><li>define 与 typedef 区别</li></ul></li><li>C++ 内存泄漏的原因</li><li>C++ move<ul><li>move的使用与功能</li></ul></li></ul><h2 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h2><ul><li>你有用过哪些容器，可以讲讲</li><li>vector容器的底层实现<ul><li>map底层实现红黑树</li></ul></li><li>有使用过迭代器吗</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>进程间的通信方式</li><li>进程与线程的区别</li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li>讲一下TCP/IP的三次握手与四次挥手<ul><li>三次握手<ul><li>TCP/IP 是否可以为两次，为什么</li><li>TCP/IP 最后一个确认包server端一直接收不到，client应如何操作</li></ul></li><li>四次挥手<ul><li>什么时候会进入Time_wait 等待状态，时间为多久</li><li>server 是否也会进入Time_wait 等待状态，什么状况会导致server进行这个状态</li></ul></li></ul></li></ul><h2 id="结束反问"><a href="#结束反问" class="headerlink" title="结束反问"></a>结束反问</h2><ul><li>面试官评价<ul><li>指针使用仍有欠缺</li><li>对于一些底层原理应深入了解</li><li>操作系统还需要深入</li></ul></li><li>面试官荐书<ul><li>书箱大致属于一些经典书目</li><li>可以多阅读一些优秀的Blog，参考这些优秀博主的如何思考以及他们对于底层原理的解析</li></ul></li></ul><h1 id="面试问题答案总结"><a href="#面试问题答案总结" class="headerlink" title="面试问题答案总结"></a>面试问题答案总结</h1><h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><ol><li><strong>排序算法的时间复杂度与空间复杂度</strong></li></ol><table><thead><tr><th align="center">排序算法</th><th align="center">平均时间复杂度</th><th align="center">最坏时间复杂度</th><th align="center">最好时间复杂度</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">$O(n^{2})$</td><td align="center">$O(n^{2})$</td><td align="center">$O(n)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center"><font color="red">直接选择排序</font></td><td align="center">$O(n^{2})$</td><td align="center">$O(n^{2})$</td><td align="center">$O(n)$</td><td align="center">$O(1)$</td><td align="center"><font color="red">不稳定</font></td></tr><tr><td align="center">直接插入排序</td><td align="center">$O(n^{2})$</td><td align="center">$O(n^{2})$</td><td align="center">$O(n)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center"><font color="red">快速排序</font></td><td align="center">$O(nlogn)$</td><td align="center">$O(n^{2})$</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center"><font color="red">不稳定</font></td></tr><tr><td align="center"><font color="red">堆排序</font></td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(1)$</td><td align="center"><font color="red">不稳定</font></td></tr><tr><td align="center"><font color="red">希尔排序</font></td><td align="center">$O(nlogn)$</td><td align="center">$O(ns)$</td><td align="center">$O(n)$</td><td align="center">$O(1)$</td><td align="center"><font color="red">不稳定</font></td></tr><tr><td align="center">归并排序</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td align="center">计数排序</td><td align="center">$O(n+k)$</td><td align="center">$O(n+k)$</td><td align="center">$O(n+k)$</td><td align="center">$O(n+k)$</td><td align="center">稳定</td></tr><tr><td align="center">基数排序</td><td align="center">$O(N * M)$</td><td align="center">$O(N * M)$</td><td align="center">$O(N * M)$</td><td align="center">$O(M)$</td><td align="center">稳定</td></tr></tbody></table><ol start="2"><li><strong>快速排序</strong></li></ol><ul><li>基本思想 * 通过一趟排序将待排记录分割成独立的两个部分，其中一部分关键字均比另一部分记录关键字小，接着对这两部分记录继续进行排序，以达到整个序列有序的目的。</li><li>最优与最坏情况分析<ul><li>最优的情况：Parition每次都划分得很均匀。在获得枢轴后将数组一分为二，各自仅需$(n/2)$的时间，这是最好的情况，时间复杂度为$O(nlogn)$</li><li>最坏的情况：待排序的数组是正序或逆序，每次划分只得到一个比上一次少一个记录的子序列，这里另一个记录是为空的。如果用二叉树表示就是一个斜树,这里就需要n-1次递归调用，所以其最终时间复杂度为$O(n^{2})$</li></ul></li><li>快排的不稳定的原因<ul><li>关键字的比较是跳跃进行的，因此快排是不稳定的</li></ul></li></ul><ol start="3"><li><strong>堆排序</strong></li></ol><ul><li>基本思想：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将其移走(实际就是将其与堆数组末尾元素交换，此时末尾元素为最大值),然后将剩余的n-1个序列重新构造成一个椎，这样就会得到n个元素中的次小值。之后重复之前的操作，就可以得到一个有序序列了</li><li>稳定性：由于记录的比较与交换是跳跃的，所以堆排序是一种不稳定的排序方式</li><li>适用场景：不适合待排序</li></ul><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><ol><li><strong>反转链表</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* prev &#x3D; nullptr;</span><br><span class="line">        ListNode* cur &#x3D; head;</span><br><span class="line">        </span><br><span class="line">        while (cur !&#x3D; nullptr) &#123;</span><br><span class="line">            ListNode* next &#x3D; cur-&gt;next;</span><br><span class="line">            cur-&gt;next &#x3D; prev;</span><br><span class="line">            prev &#x3D; cur;</span><br><span class="line">            cur &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="C-基础-1"><a href="#C-基础-1" class="headerlink" title="C++ 基础"></a>C++ 基础</h2><ol><li><strong>C++ 用法与作用</strong></li></ol><ul><li>隐藏: 在编译多个文件时，所有未加static前缀的全局变量与函数都具有全局可见性</li><li>保持变量内容的持久</li><li>static变量默认初始化为0</li><li>类成员声明为static<ul><li>static 变量只会被分配一次内存，因此它具有对值的记忆性</li><li>static 全局变量可以被模块内所有函数访问，不可以被模块外的其它函数访问</li><li>类中static成员变量属于整个类，对类的对象仅有一份拷贝</li><li>类的static成员函数为这个类所拥有，这个函数不接收this指针，所以只可以访问类的static成员变量</li><li>static类对象必须在类外进行初始化</li><li>static成员函数不可以被virtul修饰</li></ul></li></ul><ol start="2"><li><strong>C++ sizeof用法与作用</strong></li></ol><ul><li>定义： sizeof是一个操作符，作用是返回一个对象或类型所占的内存字节数</li><li>数组： sizeof(数组)的值等于数组所占用内存字节数</li><li>联合类型：操作数为联合类型时，sizeof的结果为其最大字节成员的字节数</li><li>内存对齐问题：由于结构体会自动对齐，所以sizeof的结果就是最大类型的所占用的字节数</li><li>类：空类大小为1，一个空类作为基类，它的大小为0。如果类的成员函数中有虚函数，就是固定占用4字节</li><li>strlen与它的区别<ul><li>sizeof 是运算符，strlen是库函数</li><li>sizeof的参数可以为任何数据类型或者数据，strlen参数只能是字符指针且结尾为’\0’的字符串</li><li>sizeof值在编译时确定，所以不能得到动态分配存储空间的大小</li></ul></li><li>sizeof(“hello”) 与 strlen(“hello”)<ul><li>sizeof(“hello”) 结果为6</li><li>strlen(“hello”) 结果为5，因为不包含’\0’</li></ul></li><li>sizeof( * a)指向的是整个数组空间，所以大小为144。sizeof(a)指的是单个变量所占用的字节数，又因为指向double类型，所以为8字节</li></ul><ol start="3"><li><strong>C++ 多态</strong></li></ol><ul><li>如何实现多态<ul><li>在基类的函数前加上<code>virtual</code>关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数。</li></ul></li><li>多态实现过程<ul><li>编译器发现类中在虚函数，会自动为其生成一份虚表，该表是一个一维数组，虚表里存储了虚函数入口地址</li><li>编译器会在对象的前四个字节中保存一个虚表指针，即vptr</li><li>调用构造函数，在构造函数中创建虚表并对其进行初始化</li><li>派生类对基类的虚函数没有重写，则派生类的vptr指向基类的虚表。有重写的话，派生类的vptr会指向自身的虚表。当派生类中有自己的虚表时，会将其添加在后面。</li></ul></li><li>内存布局<ul><li>单一继承的内存布局<ul><li>每个类最多只会有一个vptr指针，并放在第一个拥有virtual function 的类之后(<font color="red">父类必须保证对象的完整性</font>)</li><li>virtual function 工作方式：可以通过vptr找到vtable，对应的vtable记录了所指对象的真正类型。vtable中第一个slot存储了type_info。对应的函数的真正的地址可以从vtable中的对应slot中找到。</li></ul></li><li>多重继承下的内存布局<ul><li>根据继承父类的个数保存对应的vptr</li><li>根据所保存的虚表指针个数，产生相应个数的虚表</li><li>构造时会行构造会优先构造第一个基类</li><li>多重继承中的菱形继承是存在二义性的风险的，即使可以通过明确调用路径，但是二义性的潜在性还未消除。</li></ul></li><li>虚拟继承<ul><li>解决了菱形继承中，子类拥有多个间接父类实例的情况</li><li>虚拟继承而来的子类会生成一个隐藏的虚基类指针，虚基类指针总是在vptr之后</li><li>子类会覆盖基类的虚函数</li></ul></li></ul></li></ul><ol start="4"><li><strong>C++ 重载与重写</strong></li></ol><ul><li>重载是指在同一范围定义中的同名成员函数才存在重载关系,其特点为：<ul><li>参数名相同</li><li>参数类型与数目有所不同</li><li>不能出现参数个数与类型均相同</li></ul></li><li>重写指的是在派生类中的基类中的同名函数，<strong>重写就是重写函数体，要求基类函数必须是虚函数</strong>且<ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回类型</li></ul></li><li>区别<ul><li>重写是父类与子类之间的垂直关系，重载是不同函数间的水来关系</li><li>重写要求参数列表相同，重载要求参数列表不同，返回值不要求</li><li>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</li></ul></li><li>重载的实现原理<ul><li>利用命名倾轧技术(name mangling)，来改名函数名，区分参数不同的同名函数</li></ul></li></ul><ol start="5"><li><strong>C++ new/delete 与 malloc/free 区别</strong></li></ol><ul><li>new/delete是C++ 关键字需要编译器支持；malloc/free 是库函数，需要头文件支持。</li><li>使用new申请的内存，编译器会自动计算分配大小；malloc申请的内存，需要手动计算大小</li><li>new 内存分配成功，返回的是对象的类型指针，无须强制类型转换；malloc分配内存成功后返回是void，需要强制类型转,所以malloc不安全。</li><li>new 内存分配失败会抛出bac_alloc异常，malloc分配失败会返回NULL</li><li>new/delete 会去调用constructor与deconstructor，而malloc/free 仅是对于资源的申请与释放</li></ul><ol start="6"><li><strong>C++ 内存分区</strong></li></ol><ul><li>一共分为六个区域，分别是：栈、自由存储区、堆、全局/静态存储区、常量存储区与代码区</li><li>简单说明各个分区的作用<ul><li>栈：在函数中，函数内部局部变量的存储单元都可以在栈上创建，结束后自动释放。由于栈内置于处理器中，效率高，但是分配的内存有限</li><li>堆：就是那些由new分配的内存块，需要我们程序去控制。一个delete对应一个new，如果没有释放，程序结束后会由系统自动回收</li><li>自由存储区：全局变量与静态变量被分配到一块内存中，它们会被自动初始化</li><li>常量存储区：仅存放常量，不允许修改</li><li>代码区：存放函数体的二进制代码</li></ul></li></ul><ol start="7"><li><strong>C++ 堆栈的区别</strong></li></ol><ul><li>申请方式不同<ul><li>栈是由系统自动分配的</li><li>堆是由自己申请与释放的</li></ul></li><li>申请的大小限制<ul><li>栈顶与栈底是预设好的，栈是向栈底扩展，大小固定</li><li>堆向高地址扩展，是不连续的内存区域</li></ul></li><li>申请效率不同<ul><li>栈由系统分配，速度快，不会在碎片</li><li>堆是由程序员分配，速度会比较慢，且会有内存碎片</li></ul></li><li>各自大小<ul><li>栈默认4M</li><li>堆区一般为1G-4G</li></ul></li></ul><ol start="8"><li><strong>C++ 程序编译过程</strong></li></ol><ul><li>具体为两步：编译、链接</li><li>编译可以细分为三个阶段<ul><li>预编译处理</li><li>编译优化</li><li>转换成汇编</li></ul></li><li>链接<ul><li>需要链接原因：某个文件调用了另一个文件的函数或常量,或者是调用了某库函数</li><li>主要工作就是将有关目标文件连接起来</li></ul></li></ul><ol start="9"><li><strong>深拷贝与浅拷贝的区别</strong></li></ol><ul><li>浅拷贝<ul><li>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针与原来的指针指向同一块地址，如果原来的指针所指向的资源被释放了，那么再释放浅拷贝指针的资源就会出现错误。</li></ul></li><li>深拷贝<ul><li>深拷贝不仅影响值，还为其开辟一个新的空间来存放这个值。即使原先的对象被析构且内存被释放掉了，这也不会对深拷贝的值有所影响。在自己实现拷贝赋值时，如果有指针变量的话需要自己实现深拷贝的。</li></ul></li></ul><ol start="10"><li><strong>C++ 新特性有了解过哪些</strong></li></ol><ul><li>nullptr替代了NULL</li><li>引入了auto与decltype这两个关键字，实现了类型推导</li><li>基于范围的for循环 <code>for(auto& i : res) &#123;&#125;</code></li><li>类与结构体中初始化列表</li><li>Lambda表达式(匿名函数)</li><li>std::forward_list(单向链表)</li><li>右值引用与move语义</li><li>…..</li></ul><ol start="11"><li><strong>了解C++四种强制转换</strong></li></ol><ul><li>reinterpret_cast<ul><li>reinterpret_cast(expression)</li><li>type_id必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间的强制转换</li></ul></li><li>const_cast<ul><li>const_cast<type_id>(expression)</type_id></li><li>该运算符用来修改类型const与volatile属性。除了const与volatile修饰之外,type_id与expression的类型一致。用法如下：<ul><li>常量指针被转化为非常量的指针，并且仍然指向原来的对象</li><li>常量引用被转化为非常量的引用，并且仍然指向原来的对象</li><li>const_cast一般用于修改底层指针，如const char *p形式</li></ul></li></ul></li><li>static_cast<ul><li>static_cast<type_id>(expression)</type_id></li><li>该运算符把expression转换为type_id类型，但没有运行时类型检查来保证转换的安全性，主要有如下几种用法<ul><li>用于类层次结构中基类与派生类之间指针或引用的转换<ul><li>进行上行转换(把派生类指针或引用转换为基类表示)是安全的</li><li>进行下行转换(把基类的指针或引用转换为派生类表示)时，由于没有动态类型检查，所以是不安全的。</li></ul></li></ul></li><li>用于基本数据类型之间的转换,如int转换为char，int转换为enum。这种类型的转换的安全性需由开发者来保证</li><li>把空指针转换为目标类型的空指针</li><li>把任何类型的表达式转换为void类型</li><li><font color="red">static_cast 不能转换expression的const、volatile、_unaligned属性</font></li></ul></li><li>dynamic_cast<ul><li>dynamic_cast(expression)</li><li>在类型检查，基类向派生类转换是安全的，但是派生类向基类转换就有一些不安全</li><li>该运算符把expression转换为type_id类型。type_id必须是类指针、类的引用或void *</li><li>如果type_id 是指针类型，那么expression也必须是一个指针，如果type_id是一个引用，那么expression也必须是一个引用</li><li>这个转换是可以在执行期间决定真正的类型，因此expression必须是多态。</li><li>在类之间进行转换，dynamic_cast与static_cast的效果一样</li><li>在进行上下转换时，dynamic_cast具有类型检查功能,比static_cast功能</li></ul></li></ul><ol start="12"><li><strong>C++ define 与typedef</strong></li></ol><ul><li>宏主要用于定义常量及书写复杂的内容；typedef 主要用于定义类型别名</li><li>宏替换发生在编译阶段，属于文本插入替换；typedef是编译的一部分</li><li>宏不检查类型；typedef会检查数据类型</li><li>宏不是语句，不用在最后添加分号；typedef 是语句，要加分号标识</li><li>注意对指针的操作，typedef char * p_char与#define p_char char * 区别巨大</li></ul><ol start="12"><li><strong>C++ 内存泄漏原因</strong></li></ol><ul><li>定义<ul><li>内存泄漏是指<strong>堆内存的泄漏</strong>。堆内存是指程序从堆中分配的大小任意的内存块。如果通过new/malloc申请意资源后，没有使用delete/free来释放，那么这个内存块将不可被再次使用，这就是内存泄漏。</li></ul></li><li>泄漏的几种情况<ul><li>基类的析构函数没有申明为虚函数</li><li>对象数组没有使用delete[]来释放</li><li>new/delete,malloc/free 必须成对出现</li></ul></li></ul><ol start="13"><li><strong>C++ move语义</strong></li></ol><ul><li>作用<ul><li>独享指针所有权的转移</li><li>左值到右值属性的转移</li></ul></li></ul><h2 id="C-STL-1"><a href="#C-STL-1" class="headerlink" title="C++ STL"></a>C++ STL</h2><ol><li>使用过哪些容器</li></ol><ul><li>vector</li><li>map</li><li>set</li><li>…</li></ul><ol start="2"><li>vector容器的底层实现</li></ol><ul><li>vector 是一个类似于array的序列容器。但是array维护的是静态空间，而vector则使用灵活的动态空间配置,维护一块连续的线性空间。在空间不足时，可以自动扩充空间容纳新元素。扩充时也需经历的有：重新配置空间、移动数据、释放原空间行操作</li><li>vector 扩充规则<ul><li>以原大小的两倍配置另外一块较大空间(或者 旧长度+新增元素个数)(Win+Vs下扩展1.5倍，Linux+GCC扩展是两倍)</li></ul></li></ul><ol start="3"><li>迭代器使用</li></ol><ul><li>迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器的情况下遍历容器。除此之外，它还是作为容器与STL算法的重要粘合剂。</li><li>迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此容器内部必须保存一个与容器相关联的指针</li><li>常用的五种迭代器： value type、different type、pointer、reference、iterator catagoly;</li></ul><h2 id="操作系统-1"><a href="#操作系统-1" class="headerlink" title="操作系统"></a>操作系统</h2><ol><li>进程间的通信方式(Linux)</li></ol><ul><li>管道<ul><li>无名管道(内存文件): 管道是一种半双工的通信方式，数据只能单向的流通，而且只能在具有亲缘关系的进程之间使用。(进程的亲缘关系：父子进程关系)</li><li>有名管道(FIFO文件，借助文件系统): 有名管道是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式</li></ul></li><li>共享内存：映射一段能被其它进程所访问的内存，这段共享内存是由一个进程创建，可由多个进程访问。共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而设计的。它往往与信号量配合使用来实现进程间的同步与通信</li><li>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>套接字： 适用于不同的机器间进程通信，在本地也可作为两个进程通信的方式</li><li>信号：用于通知接收进程某个事件已经发生，比如按下<code>Ctrl+c</code>就是信号。</li><li>信号量：这是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问</li></ul><ol start="2"><li>进程与线程</li></ol><ul><li>定义<ul><li>进程是资源分配与拥有的基本单位；线程是程序执行的基本单位</li></ul></li><li>切换过程<ul><li>进程是：用户态-&gt;内核态-&gt;用户态;线程是与其一致</li></ul></li><li>拥有的资源<ul><li>进程拥有CPU资源、内存资源、文件资源与句柄；线程拥有程序计数器、寄存器、栈与状态字。</li></ul></li><li>并发性<ul><li>不同的进程之间acrq实现并发，各自占有CPU实现并行;一个进程内部的多个线程并执行。</li></ul></li><li>通信方面<ul><li>进程间通信需要借助操作系统；线程间可以直接读写进程数据段。</li></ul></li></ul><h2 id="计算机网络-1"><a href="#计算机网络-1" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol><li>TCP/IP的三次握手<br>刚开始客户端处于Closed的状态，服务端处于Listen状态，进行三次握手</li></ol><ul><li>第一次握手：客户端给服务端发一个SYN报文，并指明客户端的初始化序列号ISN(c)。此时客户端处于<code>SYN_SEND</code>状态<ul><li>首部的同步位SYN=1,初始化seq=x,SYN=1的报文段不能携带数据，但要消耗一个序列号</li></ul></li><li>第二次握手：服务器收到客户端SYN报文之后，会以自己的SYN报文作为应答，并且也是指定了自己的初始化ISN(s)。同时会把客户端的ISN+1作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器牌SYN_RCVD的状态<ul><li>在确认报文段中SYN=1,ACK=1,确认号ack=x+1,初始序号seq = y.</li></ul></li><li>第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，当然，也是一样把报务器的ISN＋1作为ACK的值，表示已经收到了服务端的SYN报文，此时客户端牌ESTABLISHED状态。服务器收到ACK报文之后，也处于ESTABLISHED状态，此时，双方已经建立起了连接<ul><li>确认报文段ACK＝1，确认号ack=y+1,序号seq=x+1(初始为seq=x,第二个报文段所以要＋1),ACK报文段可以携带数据，不携带数据则不消耗序号。</li></ul></li></ul><p>&emsp;&emsp;发送第一个SYN的一端执行主动打开(avtive open),接收这个SYN并发回下一个SYN的另一端执行被动打开(passive open)。在socket编程中，客户端执行connect()时，将触发三次握手。</p><ol start="2"><li>TCP/IP是否可以为两次，为什么</li></ol><ul><li>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能否使用再次握手达到目的。<ul><li>第一次握手：客户端发送网络包，服务端到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力正常。</li><li>第二次握手：服务端发包，客户端到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li><li>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li></ul></li><li>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</li><li>如果使用两次握手，则会出现以下这种情况<ul><li>客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。</li><li>后来收到确认，建立连接。数据传输完毕后，就释放连接，客户端共发出两个连接请求报文段，其中第一个丢失，第二个到达了服务端。</li><li>但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端。</li><li>此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立，不采用三次握手，只要服务端发出确认，就建立新的连接了。</li><li>此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</li></ul></li></ul><ol start="3"><li>TCP/IP最后一个确认包server端一直接收不到，client应如何操作</li></ol><ul><li>SYN-ACK重传次数的问题：服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。(<font color="red">每次重传等待的时间不一定趋同，一般会是指数增长，例如间隔时间为1s,2s,4s,8s…</font>)</li></ul><ol start="4"><li>TCP/IP 四次挥手<br>刚开始双方都处于ESTABLISHED状态,假如是客户端先发起关闭请求。四次挥手的过程如下:</li></ol><ul><li>第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端牌FIN_WATI1状态。即发出<strong>连接释放报文段</strong>(FIN=1,seq=u),并停止再发送数据，主动关闭TCP连接，进入FIN_WATI1状态(终止等待1)状态，等待服务端的确认。</li><li>第二次挥手：服务器收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于<code>CLOSE_WAIT</code>(关闭等待)状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进行FIN_WATI2(终止等待2)状态，等待服务端发出的连接释放报文段。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给FIN报文，且指定一个序列号。此时服务端处于<code>LAST_ACK</code>状态。即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文</strong>(FIN=1,ACK=1,seq=w,ack=u+1),服务端进入LAST_ACK(最后确认)状态，等待客户端的确认。</li><li>第四次挥手：客户端收到FIN之后，一样发送一个ACK报文作为应答，且把服务器端的序列号值+1作为自己ACK报文的序列号值，此时客户端处于<code>TIME_WAIT</code>， 。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。<br>&emsp;&emsp;收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。在socket编程中，任何一方执行close()操作即可产生挥手操作。</li></ul><ol start="5"><li>何时会进入TIME_WAIT等待状态，多长时间，为什么是那么长时间</li></ol><ul><li>当收到一个FIN只意味着这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT。</li><li>2msl，理论上，四个报文者发送完毕，就可以直接进入CLOSED状态了，但是可能网络是不可靠的，在可能最后一个ACK丢失。所以TIME_WAIT状态就是用来生性可能丢失的ACK报文。</li></ul><ol start="6"><li>server是否也会进入TIME_WAIT状态，什么情况会导致server进行这个状态</li></ol><ul><li>会的，出现在高并发短连接的TCP服务器上</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/interview/" rel="tag"># interview</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/C-templates-2nd/" rel="prev" title="C++ templates 2nd"><i class="fa fa-chevron-left"></i> C++ templates 2nd</a></div><div class="post-nav-item"><a href="/2021/NRV%E4%BC%98%E5%8C%96/" rel="next" title="NRV优化">NRV优化 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="nav-text">面试问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-text">算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%9F%BA%E7%A1%80"><span class="nav-text">C++ 基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-STL"><span class="nav-text">C++ STL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-text">计算机网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E5%8F%8D%E9%97%AE"><span class="nav-text">结束反问</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E7%AD%94%E6%A1%88%E6%80%BB%E7%BB%93"><span class="nav-text">面试问题答案总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F-1"><span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95-1"><span class="nav-text">算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%9F%BA%E7%A1%80-1"><span class="nav-text">C++ 基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-STL-1"><span class="nav-text">C++ STL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1"><span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1"><span class="nav-text">计算机网络</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Rabbet" src="/images/header.jpg"><p class="site-author-name" itemprop="name">Rabbet</p><div class="site-description" itemprop="description">个人Blog网站</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="/1508498108@qq.com" title="E-Mail → 1508498108@qq.com"><i class="fa fa-fw fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Rabbet</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">114k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">1:44</span></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/01/2019 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="本站已安全运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备19033310</a></div></div></footer></div><script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/utils.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/motion.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/schemes/pisces.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/local-search.js"></script><script>document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,e=>{document.querySelectorAll('script[type^="math/tex"]').forEach(t=>{const a=!!t.type.match(/; *mode=display/),n=new e.options.MathItem(t.textContent,e.inputJax[0],a),d=document.createTextNode("");t.parentNode.replaceChild(d,t),n.start={node:d,delim:"",n:0},n.end={node:d,delim:"",n:0},e.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script>window.addEventListener("load",()=>{quicklink({timeout:3e3,priority:!0,ignores:[i=>i.includes("#"),i=>"https://qfxul.cn/2021/interview_first/"===i]})})</script></body></html>