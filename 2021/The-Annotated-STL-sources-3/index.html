<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"qfxul.cn",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="STL源码剖析读书笔记-序列式容器"><meta property="og:type" content="article"><meta property="og:title" content="The Annotated STL Sources-3"><meta property="og:url" content="https://qfxul.cn/2021/The-Annotated-STL-sources-3/index.html"><meta property="og:site_name" content="Rabbet"><meta property="og:description" content="STL源码剖析读书笔记-序列式容器"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://7894651.xyz/STL4/vector/pic6.png"><meta property="og:image" content="https://7894651.xyz/STL4/vector/pic.png"><meta property="og:image" content="https://7894651.xyz/STL4/vector/pic1.png"><meta property="og:image" content="https://7894651.xyz/STL4/vector/pic2.png"><meta property="og:image" content="https://7894651.xyz/STL4/vector/pic3.png"><meta property="og:image" content="https://7894651.xyz/STL4/vector/pic4.png"><meta property="og:image" content="https://7894651.xyz/STL4/vector/pic5.png"><meta property="og:image" content="https://7894651.xyz/STL4/list/pic.png"><meta property="og:image" content="https://7894651.xyz/STL4/list/pic1.png"><meta property="og:image" content="https://7894651.xyz/STL4/list/pic2.png"><meta property="og:image" content="https://7894651.xyz/STL4/list/pic3.png"><meta property="og:image" content="https://7894651.xyz/STL4/list/pic4.png"><meta property="og:image" content="https://7894651.xyz/STL4/list/pic6.png"><meta property="og:image" content="https://7894651.xyz/STL4/list/pic8.png"><meta property="og:image" content="https://7894651.xyz/STL4/deque/pic.png"><meta property="og:image" content="https://7894651.xyz/STL4/deque/pic1.png"><meta property="og:image" content="https://7894651.xyz/STL4/deque/pic2.png"><meta property="og:image" content="https://7894651.xyz/STL4/deque/pic3.png"><meta property="og:image" content="https://7894651.xyz/STL4/StackAndQueue/pic.png"><meta property="og:image" content="https://7894651.xyz/STL4/StackAndQueue/pic1.png"><meta property="article:published_time" content="2021-04-12T02:01:00.000Z"><meta property="article:modified_time" content="2021-06-08T02:17:41.622Z"><meta property="article:author" content="Rabbet"><meta property="article:tag" content="theory"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://7894651.xyz/STL4/vector/pic6.png"><link rel="canonical" href="https://qfxul.cn/2021/The-Annotated-STL-sources-3/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>The Annotated STL Sources-3 | Rabbet</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a target="_blank" rel="noopener" href="https://github.com/WDXC" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Rabbet</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">悦已者</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">8</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">20</span></a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qfxul.cn/2021/The-Annotated-STL-sources-3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/header.jpg"><meta itemprop="name" content="Rabbet"><meta itemprop="description" content="个人Blog网站"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Rabbet"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">The Annotated STL Sources-3</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-04-12 10:01:00" itemprop="dateCreated datePublished" datetime="2021-04-12T10:01:00+08:00">2021-04-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-06-08 10:17:41" itemprop="dateModified" datetime="2021-06-08T10:17:41+08:00">2021-06-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Read-Notes/" itemprop="url" rel="index"><span itemprop="name">Read Notes</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>23k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>21 分钟</span></span><div class="post-description">STL源码剖析读书笔记-序列式容器</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常的开发生活中，经常会使用一些STL容器。譬如最常使用的<code>vector</code>容器，在使用时可能仅仅是去调用它拥有的元素操作函数。对于它们背后的数据的扩展、数据的遍历的底层实现操作几乎很少有关心。了解它们底层实现，可以有效的帮助你提升代码的执行效率与编译速度。<br>在STL中，容器被分为两个部分：序列式容器、关联式窗口。序列式容器也是相对来说可能是最常使用的几个STL容器了，它包含的内容见下图：<br><img data-src="https://7894651.xyz/STL4/vector/pic6.png" alt="avatar"></p><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>vector的数据安排以及操作方式与array都十分相似，它们的主要区别就在于空间运用的灵活性。array是静态空间，一旦配置后就无法改变了。vecotr是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新的元素。vector的实现技术，关键在于对空间大小控制与重新配置时数据的移动效率。</p><h2 id="vector-基本数据结构"><a href="#vector-基本数据结构" class="headerlink" title="vector 基本数据结构"></a>vector 基本数据结构</h2><p>基本上，STL里的所有容器源码都至少包含了三部分：</p><ul><li>迭代器：遍历窗口的元素，控制容器空间的边界与元素的移动</li><li>构造函数： 满足容器的各种初始化；</li><li>属性的获取：比如begin(),end()等；</li></ul><p>这些内容也可从vector的源码中探寻到:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// vecotr嵌套类型定义</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// vecotr 迭代器定义</span></span><br><span class="line">	<span class="comment">// vector 的迭代器是普通指针</span></span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// simple_alloc是SGI STL的空间配置器</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">	iterator start;	<span class="comment">// 表示目前使用空间的头</span></span><br><span class="line">	iterator finish; <span class="comment">// 表示目前使用空间的尾</span></span><br><span class="line">	iterator end_of_storage; <span class="comment">// 表示目前可用空间的尾</span></span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector-构造与内存管理"><a href="#vector-构造与内存管理" class="headerlink" title="vector 构造与内存管理"></a>vector 构造与内存管理</h2><p>vector为了应对不同的初始化，设有了多个构造函数。有的专门用于初始化头尾与可用空间的尾，有的允许我们指定空间的大小与初值。它们的源码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>() : <span class="built_in">start</span>(<span class="number">0</span>), <span class="built_in">finish</span>(<span class="number">0</span>), <span class="built_in">end_of_storage</span>(<span class="number">0</span>) &#123;&#125;  <span class="comment">// 默认初始化</span></span><br><span class="line">	<span class="built_in">vector</span>(size_type n,<span class="keyword">const</span> T&amp; value) &#123;<span class="built_in">fill_initialize</span>(n,value);&#125;  </span><br><span class="line">	<span class="built_in">vector</span>(<span class="keyword">int</span> n,<span class="keyword">const</span> T&amp; value) &#123;<span class="built_in">fill_initialize</span>(n,value);&#125;</span><br><span class="line">	<span class="built_in">vector</span>(<span class="keyword">long</span> n,<span class="keyword">const</span> T&amp; value) &#123;<span class="built_in">fill_initialize</span>(n,value);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123;<span class="built_in">fill_initialize</span>(n,<span class="built_in">T</span>());&#125;  <span class="comment">// 必须显式的调用构造函数，接受一个值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~<span class="built_in">vector</span>() &#123;</span><br><span class="line">		<span class="built_in">destory</span>(start,finish);</span><br><span class="line">		<span class="built_in">deallocate</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector构造函数中，缺省使用的是alloc空间配置器，并据此定义了一个data_allocator为了更方便的以元素大小为配置单元。以此为前提，再结合下例中的源码分析。从而探究vector的构造函数的参数初始化与空间分配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受一个大小与初始化值</span></span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123;<span class="built_in">fill_initialize</span>(n,value);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充并初始化</span></span><br><span class="line"><span class="function">vector <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	start = <span class="built_in">allocate_and_fill</span>(n,value);</span><br><span class="line">	finish = start+n;</span><br><span class="line">	end_of_storage = finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置而后填充</span></span><br><span class="line"><span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n,<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">	iterator result = data_allocator::<span class="built_in">allocate</span>(n);</span><br><span class="line">	<span class="built_in">uninitialized_fill_n</span>(result, n, x);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start) &#123;]</span><br><span class="line">		data_allocator::<span class="built_in">deallocate</span>(start,end_of_storage-start);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<code>uninitialized_fill_n</code>全局函数，它将通过对第一参数的类型是否为POD的判断，从而避免了POD类型对程序性能的拖累。如果是非POD，将在异常处理正确的情况下构造变量。vector的析构是通过直接调用deallocate空间配置器，将区间内对象全部析构且将内存还给空间配置器。</p><h2 id="vector-属性获取"><a href="#vector-属性获取" class="headerlink" title="vector 属性获取"></a>vector 属性获取</h2><p>vector的数据结构非常的简单，通过<code>start、finish、end_of_storage</code>就轻松解决了头尾标示、大小、容量以及[]运算符等机能的实现。具体到源码中，基本就是对三个迭代器进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 标识头尾</span></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> finish;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 标识长度</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">size_type</span> (<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">	<span class="comment">// 标识容量</span></span><br><span class="line">	<span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_type</span> (end_of_storage - <span class="built_in">begin</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 空容器判断</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123;<span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>();&#125;</span><br><span class="line">	<span class="comment">// []运算子</span></span><br><span class="line">	reference <span class="keyword">operator</span>[] (size_type n) &#123;<span class="keyword">return</span> *(<span class="built_in">begin</span>() + n);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最前端元素</span></span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *<span class="built_in">begin</span>();&#125;</span><br><span class="line">	<span class="comment">// 最后端元素</span></span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>);&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果对源码的表示不存在困惑，可通过下图的案例进行综合的理解<br><img data-src="https://7894651.xyz/STL4/vector/pic.png" alt="avatar"></p><h2 id="vector-push与pop"><a href="#vector-push与pop" class="headerlink" title="vector push与pop"></a>vector push与pop</h2><p>vector中<code>push_back()</code>的作用就是将新元素插入vector尾端。不过对于插入，我们需要面对空间配置的问题:<br>&emsp;&emsp;1. 若备用空间充足，则在备用空间上直接构造元素,并调整迭代器finish<br>&emsp;&emsp;2. 如果不够，就扩充空间(重新配置、移动数据、释放空间)<br>push_back在源码中的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (finish != end_of_storage) &#123; <span class="comment">// 仍有备用空间</span></span><br><span class="line">		<span class="built_in">construct</span>(finish, x);</span><br><span class="line">		++finish;					<span class="comment">// 使用后，调整水位高度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);		<span class="comment">// 没有备用空间了，使用insert_aux进行分情况处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在insert_aux()中，它又对是否仍有备用空间进行了一次判断。这样的做法是否合理呢？合理的，因为对于insert_aux，不仅只有push_back会调用它，还有其它的函数会调用它。具体到源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">	<span class="keyword">if</span> (finish != end_of_storage) &#123;		<span class="comment">// 仍有备用空间</span></span><br><span class="line">		<span class="comment">// 在备用空间起始处构造一个元素,并以vector最后一个元素值为其初值</span></span><br><span class="line">		<span class="built_in">construct</span>(finish, *(finish<span class="number">-1</span>));</span><br><span class="line">		<span class="comment">// 调整水位</span></span><br><span class="line">		++finish;</span><br><span class="line">		T x_copy =x;</span><br><span class="line">		<span class="built_in">copy_backward</span>(position, finish<span class="number">-2</span>,finish<span class="number">-1</span>);</span><br><span class="line">		*position = x_copy;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当真的等到备用空间不足时，我们需要根据配置原则合理分配空间: 如果原大小为0，则配置1(个元素大小);如果原大小不为0，则配置原大小的两倍;前半段用来放置原数据，后半段准备用来放置新数据;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">else</span> &#123;		</span><br><span class="line">		<span class="comment">// 已无备用空间</span></span><br><span class="line">		<span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 以上配置原则：如果原大小0，则配置1(个元素大小)</span></span><br><span class="line">		<span class="comment">// 如果原大小不为0，则配置原大小的两倍</span></span><br><span class="line">		<span class="comment">// 前半段用来放置原数据，后半段准备用来放置新数据</span></span><br><span class="line"></span><br><span class="line">		iterator new_start = data_allocator::<span class="built_in">allocate</span>(len); </span><br><span class="line">		iterator new_finish = new_start;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 将原vector的内容拷贝到新vector</span></span><br><span class="line">			new_finish = <span class="built_in">uninitialized_copy</span>(start,position,new_start);</span><br><span class="line">			<span class="comment">// 为新元素设定实值x</span></span><br><span class="line">			<span class="built_in">construct</span>(new_finish, x);</span><br><span class="line">			<span class="comment">// 调整水位</span></span><br><span class="line">			++new_finish;</span><br><span class="line">			<span class="comment">// 将安插点的原内容也拷贝过来(提示：本函数也可能被insert(p,x)调用)</span></span><br><span class="line">			new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">			<span class="built_in">destroy</span> (new_start, new_finish);</span><br><span class="line">			data_allocator::<span class="built_in">deallocate</span>(new_start,len);</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 析构并释放原vector</span></span><br><span class="line">		<span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">deallocate</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调整迭代器，指向新的vector</span></span><br><span class="line">		start = new_start;</span><br><span class="line">		finish = new_finish;</span><br><span class="line">		end_of_storage = new_start + len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://7894651.xyz/STL4/vector/pic1.png" alt="avatar"></p><p>pop_back的作用就是将尾端元素析构掉，并适当的调整大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	--finish;</span><br><span class="line">	<span class="built_in">destroy</span>(finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector-元素删除erase"><a href="#vector-元素删除erase" class="headerlink" title="vector 元素删除erase()"></a>vector 元素删除erase()</h2><p>在vector中提供了两个版本的erase(),一个用于清除[first,last)中的所有元素，一个用于清除某个位置上的元素。earse()就是将要删除的元素后面的内容复制到前面，然后再删除要删除的元素，并调整迭代器finish。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除[first,last)中的所有元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator first,iterator last)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 将[last,finish)内容复制到区间[first,first+(last-finish))	</span></span><br><span class="line">	iterator i = <span class="built_in">copy</span>(last, finish, first);</span><br><span class="line">	<span class="built_in">destroy</span>(i,finish);  <span class="comment">// 释放[i,finish)区间内存</span></span><br><span class="line">	finish = finish - (last - finish); <span class="comment">// 调整迭代器finish位置</span></span><br><span class="line">	<span class="keyword">return</span> first; <span class="comment">// 迭代器并没有改变，改变的是内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除某个位置上的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (position + <span class="number">1</span> != <span class="built_in">end</span>()) &#123;</span><br><span class="line">		<span class="comment">// 将[position+1,finish)内容复制到区间[position,position+(position+1-finish))</span></span><br><span class="line">		<span class="built_in">copy</span>(position+<span class="number">1</span>, finish,position);</span><br><span class="line">	&#125;</span><br><span class="line">	--finish;</span><br><span class="line">	<span class="built_in">destroy</span>(finish);</span><br><span class="line">	<span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>STL中的clear就是通过调用<code>erase(begin(),end());</code>实现的，earse(first,end);操作过程如下图所示：</p><p><img data-src="https://7894651.xyz/STL4/vector/pic2.png" alt="avatar"></p><h2 id="vector-元素插入insert"><a href="#vector-元素插入insert" class="headerlink" title="vector 元素插入insert()"></a>vector 元素插入insert()</h2><p>vector元素插入就涉及到了内存空间的配置，我们将它们的情况分成了三种进行分析：<br>&emsp;&emsp; 1. 插入点之后的现有元素个数 &gt; 新增元素个数<br><img data-src="https://7894651.xyz/STL4/vector/pic3.png" alt="avatar"></p><p>&emsp;&emsp; 2. 插入点之后的现有元素个数 &lt;= 新增元素个数<br><img data-src="https://7894651.xyz/STL4/vector/pic4.png" alt="avatar"></p><p>&emsp;&emsp; 3. 如果备用空间不足时<br><img data-src="https://7894651.xyz/STL4/vector/pic5.png" alt="avatar"></p><h2 id="vector-迭代器失效"><a href="#vector-迭代器失效" class="headerlink" title="vector 迭代器失效"></a>vector 迭代器失效</h2><p>由于迭代器是连续动态内存的封装，对于vector迭代器来说仅仅是一个普通的原生指针。对于以下两种操作都会导致迭代器失效：<br>&emsp;&emsp; 1. 元素删除： vector为了保证元素的连续排列，需要将vector的删除元素之后的元素向前移动。<br>&emsp;&emsp; 2. 元素插入： 当vector的备用空间不足时，它将重新申请更大的内存，之后将对应的元素拷贝过去。<br>这样的操作之后就会导致一个问题：指针将所指向的内存将不再存储对应的vector元素。</p><h2 id="vector-优缺点总结"><a href="#vector-优缺点总结" class="headerlink" title="vector 优缺点总结"></a>vector 优缺点总结</h2><p>最后还需要提醒的一点是：vector的成员函数是都不会去做边界检查(at会抛出异常)，在编写程序时应保证迭代器与索引值的合法性。<br>我们一起来总结一下vector的的优缺点:<br><font color="red">优点</font><br>&emsp;&emsp;1. 在内存中是一块连续内存的内存空间进行存储，可以像数组一样的操作，并且支持动态扩容。<br>&emsp;&emsp;2. 因此元素的随机的访问方便，支持下标访问与vector.at()操作。<br>&emsp;&emsp;3. 节省空间<br><font color="blue">缺点</font><br>&emsp;&emsp;1. 由于vector的顺序存储的结构特性，vector的插入与删除的时间复杂复为O(n)<br>&emsp;&emsp;2. vector的pop与push仅可在末端进行<br>&emsp;&emsp;3. 当插入长度过大时，需要重新的分配、拷贝与释放</p><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>相对于vecotr的连续线性空间，作为SGI STL中的双向链表list就显得复杂许多。但是复杂的list对于空间的配置堪称绝妙，每插入一个元素或删除一个元素就对应的配置或释放一个元素空间。因而list对于数据的插入与删除的时间复杂度永远都是O(1)。相对于vector，它更适合大量数据的插入与删除的环境中使用。</p><h2 id="list-数据结构——节点"><a href="#list-数据结构——节点" class="headerlink" title="list 数据结构——节点"></a>list 数据结构——节点</h2><p>一个list通常采用的都是分开设计，对于使用或设计过list的同学这几乎算是一个通识了。但是为何需要分开设计呢？其实节点指针只是为迭代器提供便利，在使用迭代器遍历时根本无需使用到list的数据成员。它的节点大致如下图所示：</p><p><img data-src="https://7894651.xyz/STL4/list/pic.png" alt="avatar"></p><p>它的源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">  void_pointer next;</span><br><span class="line">  void_pointer prev;</span><br><span class="line">  T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="list-数据结构－迭代器"><a href="#list-数据结构－迭代器" class="headerlink" title="list 数据结构－迭代器"></a>list 数据结构－迭代器</h2><p>相对于vector线性存储是使用的内存中一块连续区域，list则无法保证节点在内存中的连续。因此，对于list的迭代器的就必须要正确的指向每一个节点。并且可以保证正确的递增、递减、取值与成员操作等。list本身还是一个双向链表，因而它还必须具备前移、后移的能力。<br>所以list节点与迭代器结合就形成了list的主体，它的样子大致如下：</p><p><img data-src="https://7894651.xyz/STL4/list/pic1.png" alt="avatar"></p><h3 id="迭代器——基本类型"><a href="#迭代器——基本类型" class="headerlink" title="迭代器——基本类型"></a>迭代器——基本类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt;           self;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// list的迭代器类型是bidirectional iterator</span></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器——构造函数"><a href="#迭代器——构造函数" class="headerlink" title="迭代器——构造函数"></a>迭代器——构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span> <span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 定义节点指针</span></span><br><span class="line">  	<span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">  	link_type node;</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">  	__list_iterator(link_type x) : <span class="built_in">node</span>(x) &#123;&#125;</span><br><span class="line">  	__list_iterator() &#123;&#125;</span><br><span class="line">  	__list_iterator(<span class="keyword">const</span> iterator&amp; x) : <span class="built_in">node</span>(x.node) &#123;&#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代器——重载"><a href="#迭代器——重载" class="headerlink" title="迭代器——重载"></a>迭代器——重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span> <span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 重载</span></span><br><span class="line">  	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">  	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line">    <span class="comment">// 对*和-&gt;操作符进行重载</span></span><br><span class="line">  	reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  	pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++和--是直接操作的指针指向next还是prev, 因为list是一个双向链表</span></span><br><span class="line">  	self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">	    node = (link_type)((*node).next);</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	    ++*<span class="keyword">this</span>;</span><br><span class="line">	    <span class="keyword">return</span> tmp;</span><br><span class="line">  	&#125;</span><br><span class="line">  	self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">    &#123;</span><br><span class="line">	    node = (link_type)((*node).prev);</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	self <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    	--*<span class="keyword">this</span>;</span><br><span class="line">    	<span class="keyword">return</span> tmp;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="list-基本数据结构"><a href="#list-基本数据结构" class="headerlink" title="list 基本数据结构"></a>list 基本数据结构</h2><p>list 自己定义了嵌套类型满足traits编程，list的迭代器类型是bidirectional_iterator_tag类型，并不是一个普通的指针。它的主体结构如下图所示：<br><img data-src="https://7894651.xyz/STL4/list/pic2.png" alt="avatar"></p><h2 id="list-构造与析构"><a href="#list-构造与析构" class="headerlink" title="list 构造与析构"></a>list 构造与析构</h2><p>list提供了多个构造函数，其中主要的两类就是：配置n个节点空间、空链表。它们的构造过程如下图所示：<br><img data-src="https://7894651.xyz/STL4/list/pic3.png" alt="avatar"></p><h2 id="list-基本元素获取"><a href="#list-基本元素获取" class="headerlink" title="list 基本元素获取"></a>list 基本元素获取</h2><p>在了解了对象构造与析构的基础上，我们再继续深入list的基本元素操作有获取头尾、判断链表为空等元素操作。它所包括的基本操作如下所示：<br><img data-src="https://7894651.xyz/STL4/list/pic4.png" alt="avatar"></p><h2 id="list-元素操作"><a href="#list-元素操作" class="headerlink" title="list 元素操作"></a>list 元素操作</h2><p>list所提供的元素操作很多，无法在有限的篇幅中详细讲解。在这里将着重讲解以下几个元素操作：push_front、push_back、pop_front、pop_back。这此包括了元素的插入与删除的基本操作，其它的操作可自行阅读源码进行深入理解。</p><h3 id="list-元素操作——插入"><a href="#list-元素操作——插入" class="headerlink" title="list 元素操作——插入"></a>list 元素操作——插入</h3><p>在list中，经常使用push_back()与push_front()实现头部插入与尾部插入,其实现大多是通过调用insert()函数来实现这一功能的。在此，仅介绍一种insert的简单形式，通过它来一窥双链表中的头插与尾插。<br><img data-src="https://7894651.xyz/STL4/list/pic6.png" alt="avatar"></p><h3 id="list-元素操作——删除"><a href="#list-元素操作——删除" class="headerlink" title="list 元素操作——删除"></a>list 元素操作——删除</h3><p>对应push_back()与push_front()，它们的删除操作是由pop_back()与pop_front()来管理的。其实实现就是通过对prev、next移动来实现。<br><img data-src="https://7894651.xyz/STL4/list/pic8.png" alt="avatar"></p><h2 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h2><p>在list迭代器中，插入与接合操作均不会造成原有的list迭代器失效。当然，如果earse()会导致迭代器失效，不过仅限于当前这个节点,其余的迭代器均不受影响。</p><h2 id="list-优缺点总结"><a href="#list-优缺点总结" class="headerlink" title="list 优缺点总结"></a>list 优缺点总结</h2><p>list是一个双向链表,因为其具有链表的特性，在仅需一些指针操作时，应尽可能的使用list成员函数<br><strong>优点</strong><br>&emsp;&emsp; * 插入删除元素效率很高<br>&emsp;&emsp; * 可在两端进行数据进行操作</p><p><strong>缺点</strong><br>&emsp;&emsp; * 不支持随机访问<br>&emsp;&emsp; * 相对于vector占用内存过多</p><h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p>vector 是单向开口的连续线性空间,对应的deque则是一个双向开口的线性空间。双向开口的意思是deque的两端皆可以做插入与删除操作，deque大致描述图：<br><img data-src="https://7894651.xyz/STL4/deque/pic.png" alt="avatar"><br>deque相对于vector不同点还在于，它并没有所谓的容量的一个概念,原因是它是动态的以分段连续空间组合而成的。deque也提供随机访问迭代器，不过它的设计不同于vector以普通指针的迭代器。它的迭代器也直接影响了deque算法的效率，因此非必要则最好使用vector代替deque。具体个中的奥妙，静看源码剖析。</p><h2 id="deque中控器"><a href="#deque中控器" class="headerlink" title="deque中控器"></a>deque中控器</h2><p>deque是连续空间(至少逻辑上来看是这样的),内部也是由一段一段的连续空间构成，一旦有必要在deuqe前端或尾端增加新空间，便配置一段宣连续空间，串接在整个deque的头端或尾端。对于这一段一段的空间，如何使它成为一段连续的空间。维护整体空间连续的假象，同时还要避免与vector(重新配置、移动数据、释放空间)的复杂操作呢？这里STL提供是办法是设计一个复杂的迭代器。<br>作为算法与容器的粘合剂，为了更好的实现效果，deque 数据结构的设计和迭代器前进或后退等操作都非常复杂。deque采用一块所谓的map(非stlmap容器),其实就是就是一块小的连续空间，其中的每个元素都是指针，指向另外一段较大的连续线性空间，称之为<strong>缓冲区</strong>。在之后的内容中，你就可以了解到缓冲区才是deque的依存空间主体。SGI STL允许我们指定缓冲区大小，默认值为0表示将使用512bytes缓冲区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> pointer** map_pointer;</span><br><span class="line">  map_pointer map;<span class="comment">//指向 map，map 是连续空间，其内的每个元素都是一个指针。</span></span><br><span class="line">  size_type map_size;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>deque的结构设计示例图，map 与node-buffer的关系：<br><img data-src="https://7894651.xyz/STL4/deque/pic1.png" alt="avatar"></p><h2 id="deque-迭代器"><a href="#deque-迭代器" class="headerlink" title="deque 迭代器"></a>deque 迭代器</h2><p>deque 是分段连续空间，维持其”整体连续”假象的任务，就靠它的迭代器来实现，也就是operator++与operator–两个运算子上面。在解析源码之前，可以思考一下，你所认为的deque的结构该是什么样子的？<br>首先，对于分段连续，迭代器就应该指出它的这个空间在什么位置。其次，由于缓冲区是存在边界的，迭代器还应该判断，当前是否处于所在缓冲区的边缘，如果是，下面一步的前进或是后退就必须跳转到下一个或上一个缓冲区。最后还有一个关键点：对应前面两种情况，迭代器必须随时都可以掌控中控器。基于这些分析，再来看源码，就相对轻松一些。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(T)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// deque是random_access_tag类型 </span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="comment">// 基本类型定义，满足traits编程</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 三个迭代器类型</span></span><br><span class="line">  T* cur;  <span class="comment">// 迭代器所指缓冲区中的当前(current)元素</span></span><br><span class="line">  T* first; <span class="comment">// 此迭代器所指的缓冲区的头</span></span><br><span class="line">  T* last; <span class="comment">// 此迭代器所指的缓冲区的尾(含有备用空间)</span></span><br><span class="line">  map_pointer node;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>deque的中控器、缓冲区、迭代器的相互关系如下图所示：<br><img data-src="https://7894651.xyz/STL4/deque/pic2.png" alt="avatar"></p><p>每一段都指向一个缓冲区buffer，而缓冲区是需要知道每个元素的位置的，所以需要这些迭代器去访问。这样就十分方便管理，需要注意的是deque的空间是由map管理的，它是一个指向指针的指针，所以三个参数都是指向当前的数组。但是这样的数组可能有多个，只是每个数组都管理这三个变量。<br>之前在deque实现的差不多了，我们还有一个问题存在——缓冲区的大小由谁来决定？在SGI STL提供了一个全局函数来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz): <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果 n 不为0，则返回 n，表示缓冲区大小由用户自定义</span></span><br><span class="line"><span class="comment">//如果 n == 0，表示 缓冲区大小默认值</span></span><br><span class="line"><span class="comment">//如果 sz = (元素大小 sizeof(value_type)) 小于 512 则返回 521/sz</span></span><br><span class="line"><span class="comment">//如果 sz 不小于 512 则返回 1</span></span><br></pre></td></tr></table></figure><p>如果对这个全局函数存在困惑，可通过下面这个例子与图进行一个较为深入的理解。<br>假设我们产生一个元素类型为int，缓冲区大小为8(个)元素大小的deque(总大小为32)。经过一番操作后，deque现在在20个元素，那么成员函数begin()与end()返回的两个迭代器应该是怎样的？<br>如下图所示：<br><img data-src="https://7894651.xyz/STL4/deque/pic3.png" alt="avatar"></p><p>20个元素需要20/(sizeof(int)) = 3 个缓冲区。<br>所以map运用了三个节点，迭代器start内的cur指针指向缓冲区的第一个元素，迭代器finish内的指针指向缓冲区的最后一个元素(的下一个位置)。<br><font color="red">注意：如果最后一个缓冲区尚有备用空间，那么之后若仍有新元素插入，则直接插入到备用空间之中。</font></p><h2 id="deque-迭代器操作"><a href="#deque-迭代器操作" class="headerlink" title="deque 迭代器操作"></a>deque 迭代器操作</h2><p>主要操作：前进与后退<br>operator++操作代表需要切换到下一个元素，这里需要先切换再判断是否已经到达缓冲区的末尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">  ++cur;      <span class="comment">//切换至下一个元素</span></span><br><span class="line">  <span class="keyword">if</span> (cur == last) &#123;   <span class="comment">//如果已经到达所在缓冲区的末尾</span></span><br><span class="line">     <span class="built_in">set_node</span>(node+<span class="number">1</span>);  <span class="comment">//切换下一个节点</span></span><br><span class="line">     cur = first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>operator– 操作代表需要切换到上一个元素所在的位置，需要先判断是否到达缓冲区的头部，再后退。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">  <span class="keyword">if</span> (cur == first) &#123;    <span class="comment">//如果已经到达所在缓冲区的头部</span></span><br><span class="line">     <span class="built_in">set_node</span>(node - <span class="number">1</span>); <span class="comment">//切换前一个节点的最后一个元素</span></span><br><span class="line">     cur = last;</span><br><span class="line">  &#125;</span><br><span class="line">  --cur;       <span class="comment">//切换前一个元素</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;  <span class="comment">//结合前面的分段连续空间，你在想一想这样的设计是不是合理呢？</span></span><br></pre></td></tr></table></figure><h2 id="deque-构造与析构函数"><a href="#deque-构造与析构函数" class="headerlink" title="deque 构造与析构函数"></a>deque 构造与析构函数</h2><p>deque的构造函数有多个重载函数，接受大部分不同的参数类型，基本上每一个构造函数都会调用create_map_and_nodes,这就是构造函数的核心，之后会对这个函数进行一个具体的分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic types</span></span><br><span class="line">  <span class="built_in">deque</span>() : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;  <span class="comment">// 默认构造函数</span></span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">const</span> deque&amp; x) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(x.<span class="built_in">size</span>());</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">uninitialized_copy</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), start);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_map_and_nodes</span>());</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 接受 n:初始化大小, value:初始化的值</span></span><br><span class="line">  <span class="built_in">deque</span>(size_type n, <span class="keyword">const</span> value_type&amp; value) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> value_type&amp; value) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> value_type&amp; value) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>在剖析完deque的构造函数后，再来了解一下deque都会调用的中控器(create_map_and_nodes)的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> deque&lt;T,Alloc,BufSize&gt;::<span class="built_in">create_map_and_nodes</span>(size_type_num_elements) &#123;</span><br><span class="line">  <span class="comment">//需要节点数= (每个元素/每个缓冲区可容纳的元素个数+1)</span></span><br><span class="line">  <span class="comment">//如果刚好整除，多配一个节点</span></span><br><span class="line">  size_type num_nodes = num_elements / <span class="built_in">buffer_size</span>() + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//一个 map 要管理几个节点，最少 8 个，最多是需要节点数+2</span></span><br><span class="line">  map_size = <span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(), num_nodes + <span class="number">2</span>);</span><br><span class="line">  map = map_allocator::<span class="built_in">allocate</span>(map_size);</span><br><span class="line"> <span class="comment">// 计算出数组的头前面留出来的位置保存并在nstart.</span></span><br><span class="line">  map_pointer nstart = map + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">  map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line">  map_pointer cur;<span class="comment">//指向所拥有的节点的最中央位置</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码之下，了无秘密。通过构造函数，我们可以得知<strong>deque的begin与end不是一开始就指向map中控器的开头与结尾，而是指向所拥有的节点的最中央的位置。</strong></p><p>这样所带来的好处就是可以使得头尾两边扩充可能性和一样大，因为deque头插与尾插都是O(1)，所以deque在头与尾都留有空间方便头尾插入。</p><p>那么map中控器本身何时需要重新调整大小呢？触发条件在于reserve_map_at_back与reserve_map_at_front这两个函数来判断，实现操作由reallocate_map来执行。<br>map调整的实现如下面两个函数所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 map 尾端的节点备用空间不足，符合条件就配置一个新的map(配置更大的，拷贝原来的，释放原来的)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - map))</span><br><span class="line">    <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 map 前端的节点备用空间不足，符合条件就配置一个新的map(配置更大的，拷贝原来的，释放原来的)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nodes_to_add &gt; start.node - map)</span><br><span class="line">    <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deque-插入与删除"><a href="#deque-插入与删除" class="headerlink" title="deque 插入与删除"></a>deque 插入与删除</h2><p>因为deque是双向的操作，所以push与pop操作都类似于list可以直接有对应的操作。不过需要注意的是list链表，并不会涉及到边界的判，而deque是由数组来存储的，就需要随时对界线进行判断。</p><h3 id="push与pop实现"><a href="#push与pop实现" class="headerlink" title="push与pop实现"></a>push与pop实现</h3><p>push 实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// push_* and pop_*</span></span><br><span class="line">    <span class="comment">// 对尾进行插入</span></span><br><span class="line">    <span class="comment">// 判断函数是否达到了数组尾部. 没有达到就直接进行插入</span></span><br><span class="line">  <span class="keyword">void</span> <span class="built_in">push_back</span>(<span class="keyword">const</span> value_type&amp; t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(finish.cur, t);</span><br><span class="line">      ++finish.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">push_back_aux</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 对头进行插入</span></span><br><span class="line">    <span class="comment">// 判断函数是否达到了数组头部. 没有达到就直接进行插入</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.first) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(start.cur - <span class="number">1</span>, t);</span><br><span class="line">      --start.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">push_front_aux</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pop实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// 对尾部进行操作</span></span><br><span class="line">    <span class="comment">// 判断是否达到数组的头部. 没有到达就直接释放</span></span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">pop_back</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.first) &#123;</span><br><span class="line">      --finish.cur;</span><br><span class="line">      <span class="built_in">destroy</span>(finish.cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">pop_back_aux</span>();</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 对头部进行操作</span></span><br><span class="line">    <span class="comment">// 判断是否达到数组的尾部. 没有到达就直接释放</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">destroy</span>(start.cur);</span><br><span class="line">      ++start.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">pop_front_aux</span>();</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pop与push都先调用了reserve_map_at_XX函数，这些函数主要是为了判断前后空间是否足够。</p><h3 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h3><p>回想deque的构造函数，我们使用调用了中控器(create_map_and_nodes)函数。这样保证了前后都留有空间，所以push与pop皆可以在前面的数组中进行操作。<br>现在对于删除操作erase,因为deque是由数组构成，所以地址空间是连续，删除因此也需要像vector一样移到所有元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// erase</span></span><br><span class="line">  iterator <span class="built_in">erase</span>(iterator pos) &#123;</span><br><span class="line">    iterator next = pos;</span><br><span class="line">    ++next;</span><br><span class="line">    difference_type index = pos - start;</span><br><span class="line">      <span class="comment">// 删除的地方是中间偏前, 移动前面的元素</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="built_in">copy_backward</span>(start, pos, next);</span><br><span class="line">      <span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 删除的地方是中间偏后, 移动后面的元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">copy</span>(next, finish, pos);</span><br><span class="line">      <span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + index;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 范围删除, 实际也是调用上面的erase函数.</span></span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>对于insert函数的解析：deque的insert函数都调用了insert_auto判断插入的位置离头还是离尾近。<br>如果离头近：则先将头向前移动，调整将要移动的距离，用copy进行调整。<br>如果离尾近:则将尾往前移动，调整将要移动的距离，用copy进行一个调整。<br>注意：push_back是先执行构造再移动node，而push_front是先移动node在进行构造，实现的差异主要是finish是指向最后一个元素的后一个地址而first指向的就只有第一个元素的地址，对于pop也是同理。</p><h3 id="其余元素操作"><a href="#其余元素操作" class="headerlink" title="其余元素操作"></a>其余元素操作</h3><p>reallocate_map：判断中控器的容量是否够用，如果不够用，申请更大的空间，拷贝元素过去，修改 map 和 start，finish 的指向。</p><p>fill_initialize 函数：申请空间，对每个空间进行初始化，最后一个数组单独处理。毕竟最后一个数组一般不是会全部填充满。</p><p>clear 函数：删除所有元素，分两步执行：</p><p>首先从第二个数组开始到倒数第二个数组一次性全部删除，这样做是考虑到中间的数组肯定都是满的，前后两个数组就不一定是填充满的，最后删除前后两个数组的元素。</p><p>deque 的 swap 操作：只是交换了 start, finish, map，并没有交换所有的元素。</p><p>resize 函数： 重新将 deque 进行调整, 实现与 list一样的。</p><p>析构函数： 分步释放内存。</p><h2 id="deque-迭代器失效"><a href="#deque-迭代器失效" class="headerlink" title="deque 迭代器失效"></a>deque 迭代器失效</h2><p>除了首尾的插入与删除操作不会对deque迭代器造成影响。因为这些操作都不会对现有的元素进行移动，如果一个分段数组满了。仅需创建亲的分段数组，并把对应的分段数组加入索引数组中就可以了。删除其实也是大致的意思，均不会对现有元素作移到操作。<br>但是除了这些操作，其它的插入与删除均会导致deque元素的任何pointers、reference、iterators失效。不过，效率相对于vector会好一些，毕竟不需要复制所有的元素。</p><h2 id="deque-总结"><a href="#deque-总结" class="headerlink" title="deque 总结"></a>deque 总结</h2><p>deque 其实就是在功能上合并了vector与list</p><p>优点：<br>&emsp;&emsp;1. 随机访问方便，即支持[]操作符与vector.at();<br>&emsp;&emsp;2. 在内部方便的进行插入与删除操作<br>&emsp;&emsp;3. 可在两端进行push、pop</p><p>缺点：因为设计比较复杂，采用分段连续空间，所以相对的占用空间会更多。</p><h2 id="使用区别"><a href="#使用区别" class="headerlink" title="使用区别"></a>使用区别</h2><ol><li>如果你需要高效的随机存取，而不在乎插入与删除的效率，使用vector</li><li>如果你需要大量的插入与删除，并不关心随机存取，则应该使用list</li><li>如果你随机存取，而且关心两端数据的插入与删除，则应该使用deque</li></ol><h1 id="stack-And-queue"><a href="#stack-And-queue" class="headerlink" title="stack And queue"></a>stack And queue</h1><p><strong>以deque为底部容器的适配器</strong><br>最后的要介绍的这三种容器，准确来说其实是一种适配器(就是通过将不适用的序列式容器变得适用)<br><strong>栈——stack</strong>: 先入后出，只允许在栈顶添加与删除元素，称为出栈与入栈。<br><img data-src="https://7894651.xyz/STL4/StackAndQueue/pic.png" alt="avatar"><br><strong>队列——queue</strong>: 先入先出，在队首取元素，在队尾添加元素，称为出队与入队。<br><img data-src="https://7894651.xyz/STL4/StackAndQueue/pic1.png" alt="avatar"><br><strong>优先队列</strong>: 带权值的队列。</p><p>常见的队列的应用场景包括计算机系统中的各种资源管理，消息缓冲队列的管理与广度优先遍历BFS等。在stack与queue的底层其实都是使用deque容器作为它们的底层数据结构。</p><p>信赖于deque的stack与queue的实现，就变得十分容易，具体到源码可见：</p><h2 id="stack-源码"><a href="#stack-源码" class="headerlink" title="stack 源码"></a>stack 源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> deque&lt;T&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;</span><br></pre></td></tr></table></figure><h2 id="queue源码"><a href="#queue源码" class="headerlink" title="queue源码"></a>queue源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> deque&lt;T&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;</span><br></pre></td></tr></table></figure><h1 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h1><p>heap 并不归属于STL容器组件之中，它的没有一个实现自己的迭代器，同时也没有遍历操作。准确来说，它只算是一种算法。</p><h2 id="push-heap插入元素"><a href="#push-heap插入元素" class="headerlink" title="push_heap插入元素"></a>push_heap插入元素</h2><p>插入函数是push_heap,heap仅接受RandomAccessIterator类型的迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  __push_heap_aux(first, last, <span class="built_in">distance_type</span>(first), <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Distance*, T*) &#123;</span><br><span class="line">    <span class="comment">// 这里传入的是两个迭代器的长度, 0, 还有最后一个数据</span></span><br><span class="line">  __push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>),  <span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pop-heap-删除元素"><a href="#pop-heap-删除元素" class="headerlink" title="pop_heap 删除元素"></a>pop_heap 删除元素</h2><p>pop操作其实并没有真正意义去凹陷数据，而是将数据放在最后，只是没有指向最后的元素而已，这里使用array也可以，毕竟没有对数据的大小进行调整。<br>pop的实现有两种，这里都罗列了出来，另一个传入的是cmp仿函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Compare comp)</span> </span>&#123;</span><br><span class="line">    __pop_heap_aux(first, last, <span class="built_in">value_type</span>(first), comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap_aux(RandomAccessIterator first,</span><br><span class="line">                           RandomAccessIterator last, T*, Compare comp) &#123;</span><br><span class="line">  __pop_heap(first, last - <span class="number">1</span>, last - <span class="number">1</span>, <span class="built_in">T</span>(*(last - <span class="number">1</span>)), comp,</span><br><span class="line">             <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">                       RandomAccessIterator result, T value, Compare comp,</span><br><span class="line">                       Distance*) &#123;</span><br><span class="line">  *result = *first;</span><br><span class="line">  __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value, comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">                       RandomAccessIterator result, T value, Distance*) &#123;</span><br><span class="line">  *result = *first; <span class="comment">// 因为这里是大根堆, 所以first的值就是最大值, 先将最大值保存.</span></span><br><span class="line">  __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h2><p>将数组变成堆存放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  __make_heap(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,</span><br><span class="line">                 Distance*) &#123;</span><br><span class="line">  <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 计算长度, 并找出中间的根值</span></span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance parent = (len - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 一个个进行调整, 放到后面</span></span><br><span class="line">    __adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent)));</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    parent--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h2><p>堆排序：其实就是每次将第一位数据弹出从而实现排序功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>) <span class="built_in">pop_heap</span>(first, last--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">               Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>) <span class="built_in">pop_heap</span>(first, last--, comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>最后我们来看一下priority_queue<br>上一节分析heap，其实就是为priority_queue做准备，priority_queue是一个优先级队列。是带权值的，支持插入与删除操作，其只能从尾部插入，头部删除，并且它的顺序也并非是根据加入的顺序排列的。<br>priority_queue 因为也是队列的一种体现，所以也就跟队列一样不能直接的遍历数组，也就没有迭代器。<br>priority_queue 本身也不算是一个容器，它是<strong>以vector为容器以heap为数据操作的配置器。</strong></p><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> vector&lt;T&gt;, </span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">priority_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// 符合traits编程规范</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c; <span class="comment">// 定义vector容器的对象</span></span><br><span class="line">  Compare comp; <span class="comment">// 定义比较函数(伪函数)</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h2><p>priority_queue 只有简单的3个属性获取的函数，其本身的操作也很简单，只是实现依赖了vector与heap就变得比较复杂。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">priority_queue</span> &#123;</span></span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="push与pop实现-1"><a href="#push与pop实现-1" class="headerlink" title="push与pop实现"></a>push与pop实现</h2><p>push与pop本身实现是很复杂的，但是将其剖析开，就是vector与heap的组合。将vector作为容器，heap作为算法来操作的配置器。这样同样的显示出了STL的灵活性：通过各个容器与算法的结合就能实现另一种功能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在实际的使用中，为了避免拷贝的开销。还是还要直接把大的对象直接往里存放，而是使用指针来替代。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/theory/" rel="tag"># theory</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/The_Annotated_STL_Sources/" rel="prev" title="The Annotated STL Sources-1"><i class="fa fa-chevron-left"></i> The Annotated STL Sources-1</a></div><div class="post-nav-item"><a href="/2021/Travel-1/" rel="next" title="宝华山之旅">宝华山之旅 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vector"><span class="nav-text">vector</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">vector 基本数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">vector 构造与内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-%E5%B1%9E%E6%80%A7%E8%8E%B7%E5%8F%96"><span class="nav-text">vector 属性获取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-push%E4%B8%8Epop"><span class="nav-text">vector push与pop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4erase"><span class="nav-text">vector 元素删除erase()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5insert"><span class="nav-text">vector 元素插入insert()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="nav-text">vector 迭代器失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-%E4%BC%98%E7%BC%BA%E7%82%B9%E6%80%BB%E7%BB%93"><span class="nav-text">vector 优缺点总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#list"><span class="nav-text">list</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#list-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%8A%82%E7%82%B9"><span class="nav-text">list 数据结构——节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8D%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">list 数据结构－迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-text">迭代器——基本类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E2%80%94%E2%80%94%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">迭代器——构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E2%80%94%E2%80%94%E9%87%8D%E8%BD%BD"><span class="nav-text">迭代器——重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">list 基本数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="nav-text">list 构造与析构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list-%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96"><span class="nav-text">list 基本元素获取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list-%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="nav-text">list 元素操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#list-%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5"><span class="nav-text">list 元素操作——插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list-%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4"><span class="nav-text">list 元素操作——删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="nav-text">迭代器失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list-%E4%BC%98%E7%BC%BA%E7%82%B9%E6%80%BB%E7%BB%93"><span class="nav-text">list 优缺点总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#deque"><span class="nav-text">deque</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#deque%E4%B8%AD%E6%8E%A7%E5%99%A8"><span class="nav-text">deque中控器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">deque 迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="nav-text">deque 迭代器操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">deque 构造与析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="nav-text">deque 插入与删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#push%E4%B8%8Epop%E5%AE%9E%E7%8E%B0"><span class="nav-text">push与pop实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4"><span class="nav-text">元素删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-text">插入操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BD%99%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="nav-text">其余元素操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="nav-text">deque 迭代器失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque-%E6%80%BB%E7%BB%93"><span class="nav-text">deque 总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB"><span class="nav-text">使用区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stack-And-queue"><span class="nav-text">stack And queue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stack-%E6%BA%90%E7%A0%81"><span class="nav-text">stack 源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#queue%E6%BA%90%E7%A0%81"><span class="nav-text">queue源码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#heap"><span class="nav-text">heap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#push-heap%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="nav-text">push_heap插入元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pop-heap-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">pop_heap 删除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#make-heap"><span class="nav-text">make_heap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sort-heap"><span class="nav-text">sort_heap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#priority-queue"><span class="nav-text">priority_queue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">类型定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%8E%B7%E5%8F%96"><span class="nav-text">属性获取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#push%E4%B8%8Epop%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">push与pop实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Rabbet" src="/images/header.jpg"><p class="site-author-name" itemprop="name">Rabbet</p><div class="site-description" itemprop="description">个人Blog网站</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">20</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="/1508498108@qq.com" title="E-Mail → 1508498108@qq.com"><i class="fa fa-fw fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Rabbet</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">124k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">1:53</span></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/01/2019 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="本站已安全运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备19033310</a></div></div></footer></div><script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/utils.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/motion.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/schemes/pisces.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/local-search.js"></script><script>document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script>window.addEventListener("load",()=>{quicklink({timeout:3e3,priority:!0,ignores:[e=>e.includes("#"),e=>"https://qfxul.cn/2021/The-Annotated-STL-sources-3/"===e]})})</script></body></html>