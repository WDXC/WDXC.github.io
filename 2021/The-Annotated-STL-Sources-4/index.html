<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"qfxul.cn",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="STL源码剖析读书笔记-关联式容器"><meta property="og:type" content="article"><meta property="og:title" content="The Annotated STL Sources-4"><meta property="og:url" content="https://qfxul.cn/2021/The-Annotated-STL-Sources-4/index.html"><meta property="og:site_name" content="Rabbet"><meta property="og:description" content="STL源码剖析读书笔记-关联式容器"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://7894651.xyz/RBTree/pic.png"><meta property="og:image" content="https://7894651.xyz/RBTree/pic1.png"><meta property="og:image" content="https://7894651.xyz/RBTree/pic2.png"><meta property="og:image" content="https://7894651.xyz/RBTree/pic3.png"><meta property="og:image" content="https://7894651.xyz/RBTree/pic4.png"><meta property="og:image" content="https://7894651.xyz/RBTree/pic5.png"><meta property="og:image" content="https://7894651.xyz/RBTree/pic6.png"><meta property="og:image" content="https://7894651.xyz/RBTree/pic7.png"><meta property="og:image" content="https://7894651.xyz/RBTree/pic8.png"><meta property="og:image" content="https://7894651.xyz/RBTree/pic3.gif"><meta property="article:published_time" content="2021-05-01T02:01:00.000Z"><meta property="article:modified_time" content="2021-06-08T02:17:41.674Z"><meta property="article:author" content="Rabbet"><meta property="article:tag" content="theory"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://7894651.xyz/RBTree/pic.png"><link rel="canonical" href="https://qfxul.cn/2021/The-Annotated-STL-Sources-4/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>The Annotated STL Sources-4 | Rabbet</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a target="_blank" rel="noopener" href="https://github.com/WDXC" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Rabbet</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">悦已者</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">7</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qfxul.cn/2021/The-Annotated-STL-Sources-4/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/header.jpg"><meta itemprop="name" content="Rabbet"><meta itemprop="description" content="个人Blog网站"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Rabbet"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">The Annotated STL Sources-4</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-05-01 10:01:00" itemprop="dateCreated datePublished" datetime="2021-05-01T10:01:00+08:00">2021-05-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-06-08 10:17:41" itemprop="dateModified" datetime="2021-06-08T10:17:41+08:00">2021-06-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Read-Notes/" itemprop="url" rel="index"><span itemprop="name">Read Notes</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>14k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>12 分钟</span></span><div class="post-description">STL源码剖析读书笔记-关联式容器</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>标准的STL关联式容器set(集合)和map(映射表)两大类，在观念上它们类似于数据库(实际则还要简单):每笔数据(每个元素)都有一个键值(key)和一个实值(value)。当元素插入到关联式容器时，就会以某种特定规则将这个元素放在适当的位置。因此关联式容器没有所谓的头尾的说法，所以就没有一些push_back()、push_font()等等这样的操作。<br>关联式容器所包含的容器<br><img data-src="https://7894651.xyz/RBTree/pic.png" alt="avatar"></p><p>一般而论，关联式容器的内部结构都是一个balanced binary tree(平衡二叉树)，用以寻求最高的搜索效率。当然，对于平衡二叉树来说，它也是存在许多的分支。但是其中广泛运用于STL关联式容器的底层结构的主要是RB-Tree，作为关联式容器的核心，我们很是有必要来深入探索一下它。</p><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>在了解红黑树之前，大概还需要一些基本的知识准备。树作为一种十分基础的数据结构，几乎所有的操作系统都将文件存放在树状结构。树这种数据结构也具有许多的分支，如文件压缩所采用的哈夫曼树，数据库中使用的B-Tree等。对于RB-Tree来说，它就是属于二叉搜索树中的一种。<br>所谓二叉树搜索树,是指一颗空树或是具有以下性质的二叉树：<br>&emsp;&emsp;1. 若任意节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值<br>&emsp;&emsp;2. 若任意节点的右子树不为空，则右子树上所有节点的值均大于它的根节点的值<br>&emsp;&emsp;3. 任意节点的左、右子树也分别是二叉搜索树<br>对于二叉树，还可以细分为平衡二叉树(Balanced binary search tree)与自平衡二叉搜索树(AVL tree)。它们都很相似，却又是十分的不同。</p><h2 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h2><p>它是一种结构平衡的二叉树,其每个节点的左右两个高度差不超过一个二叉树。可以在O(logn)时间内完成插入、删除操作。<br>其结构如下图所示：<br><img data-src="https://7894651.xyz/RBTree/pic1.png" alt="avatar"></p><h2 id="自平衡二叉搜索树"><a href="#自平衡二叉搜索树" class="headerlink" title="自平衡二叉搜索树"></a>自平衡二叉搜索树</h2><p>AVL树是最早发明的自平衡二叉搜索树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。<br>AVL树插入节点时，存在四种平衡破坏的情况，这里假设最深节点为X，那么对应的情况就是：<br>&emsp;&emsp;1. 插入点位于X的左子节点的左子树——左左<br>&emsp;&emsp;2. 插入点位于X的左子节点的右子树——左右<br>&emsp;&emsp;3. 插入点位于X的右子节点的左子树——右左<br>&emsp;&emsp;4. 插入点位于X的右子树的左子树——右右</p><p>那么对应这四种情况，我们也提供了两种解决方法来修复这些插入而导致的不平衡。<br>首先是单旋转，它主要用于对左左与右右这两种情况的处理。<br><img data-src="https://7894651.xyz/RBTree/pic2.png" alt="avatar"><br>其次就是双旋转，它也就是利用两次单旋转来实现的，它主要用于对左右与右左这两种情况进行处理。<br><img data-src="https://7894651.xyz/RBTree/pic3.png" alt="avatar"></p><p>RB-Tree是另一个被广泛使用的平衡二叉搜索树,它的平衡条件虽然不同于AVL-Tree,但是也同样使用了单旋转与双旋转修正操作，这些在RB-Tree的解析中也详细解析。</p><h1 id="RB-Tree"><a href="#RB-Tree" class="headerlink" title="RB-Tree"></a>RB-Tree</h1><p>RB-Tree不仅是一个二叉搜索树，它还必须满足以下的规则：<br>&emsp;&emsp;1. 每个节点的颜色非黑即红<br>&emsp;&emsp;2. 根节点颜色必须是黑色<br>&emsp;&emsp;3. 每个叶子节点(NULL)是黑色<br>&emsp;&emsp;4. 如果一个节点是红色，则它的子节点必须是黑色<br>&emsp;&emsp;5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点数</p><p>如下就是一个标准的红黑树：<br><img data-src="https://7894651.xyz/RBTree/pic4.png" alt="avatar"></p><h2 id="节点设计"><a href="#节点设计" class="headerlink" title="节点设计"></a>节点设计</h2><p>RB-Tree有红黑两种颜色，并且具有左右子节点，我们可以很容易的设计出其结构风貌。具体STL中源码中如下：<br><font color="red"><strong>__rb_tree_node_base</strong></font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;	</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;	</span><br><span class="line"></span><br><span class="line">  color_type color; 	<span class="comment">// 定义节点颜色</span></span><br><span class="line">  base_ptr parent;		<span class="comment">// 定义父节点,由于许多操作皆需要父节点才可以完成</span></span><br><span class="line">  base_ptr left;		<span class="comment">// 定义左孩子</span></span><br><span class="line">  base_ptr right;		<span class="comment">// 定义右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最大节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><font color="red"><strong>__rb_tree_node</strong></font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node</span> :</span> <span class="keyword">public</span> __rb_tree_node_base	<span class="comment">// 继承__rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  Value value_field;	<span class="comment">// 定义节点数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>红黑树的节点设计很是巧妙，将节点与数据分开定义。这种手法与list结构很是类似，__rb_tree_node_base定义了指针，__rb_tree_node定义了继承了前者，并增加了数据，这样就形成了一个完整的节点。<br>节点样式如下：<br><img data-src="https://7894651.xyz/RBTree/pic5.png" alt="avatar"></p><h2 id="迭代器设计"><a href="#迭代器设计" class="headerlink" title="迭代器设计"></a>迭代器设计</h2><p>迭代器中<code>increment</code>与<code>decrement</code>函数主要实现的就是++与–，即迭代器中的前进与后退操作。<br><font color="red"><strong>__rb_tree_base_iterator</strong></font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_base_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;	<span class="comment">// bidirectional_iterator_tag类型的迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  base_ptr node;	<span class="comment">// 指针节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++核心函数</span></span><br><span class="line">    <span class="comment">// 节点是从node节点出发, 一直寻找右节点的左孩子, 每次找到比上次大的元素</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 有右节点, 就往右节点走</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right != <span class="number">0</span>) &#123;</span><br><span class="line">      node = node-&gt;right;</span><br><span class="line">        <span class="comment">// 一直往左节点走, 直到走到头</span></span><br><span class="line">      <span class="keyword">while</span> (node-&gt;left != <span class="number">0</span>)</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 没有右节点, 就寻找父节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      base_ptr y = node-&gt;parent;</span><br><span class="line">        <span class="comment">// 如果该节点是父节点的右孩子就继续往上找, 直到y节点不是父节点的右孩子</span></span><br><span class="line">      <span class="keyword">while</span> (node == y-&gt;right) &#123;</span><br><span class="line">        node = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;right != y)</span><br><span class="line">        node = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --核心代码</span></span><br><span class="line">    <span class="comment">// 节点是从node节点出发, 一直寻找左节点的右孩子, 每次找到比上次小的元素</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 只有根节点, 每次--都是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;color == __rb_tree_red &amp;&amp; node-&gt;parent-&gt;parent == node)</span><br><span class="line">      node = node-&gt;right;</span><br><span class="line">      <span class="comment">// 有左节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;left != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 往左节点走</span></span><br><span class="line">      base_ptr y = node-&gt;left;</span><br><span class="line">        <span class="comment">// 只要有右节点就一直往右节点走</span></span><br><span class="line">      <span class="keyword">while</span> (y-&gt;right != <span class="number">0</span>)</span><br><span class="line">        y = y-&gt;right;</span><br><span class="line">      node = y;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 没有左节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找父节点</span></span><br><span class="line">      base_ptr y = node-&gt;parent;</span><br><span class="line">        <span class="comment">// 如果当前节点是父节点的左孩子就继续寻找父节点直到不再是左孩子</span></span><br><span class="line">      <span class="keyword">while</span> (node == y-&gt;left) &#123;</span><br><span class="line">        node = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line">      node = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>红黑树的迭代器，通过继承 __rb_tree_base_iterator重载++与–操作(通过调用 increment()与decrement())</p><h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><p>在深入到构造之前，还需要先了解一下基本类型定义。对于红黑树来说，它也有自己的空间配置器，其中也囊括了各种类型定义，维护整棵红黑树的三笔数据node_count 记录树的大小、header这是头节点，非根节点，但是头节点指向根节点以及key_compare这个仿函数。其类型定义源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;	<span class="comment">// 定义节点指针</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;	<span class="comment">// 定义节点</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;	<span class="comment">// 定义空间配置器</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 满足traits编程</span></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  size_type node_count; <span class="comment">// keeps track of size of tree</span></span><br><span class="line">  link_type header;  	<span class="comment">// 头节点, 不是根节点, 头节点是指向根节点</span></span><br><span class="line">  Compare key_compare;	<span class="comment">// 伪函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 定义迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, reference, pointer&gt; iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, const_reference, const_pointer&gt;</span><br><span class="line">          const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;iterator, value_type, reference,</span><br><span class="line">                                         difference_type&gt;</span><br><span class="line">          reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;const_iterator, value_type,</span><br><span class="line">                                         const_reference, difference_type&gt;</span><br><span class="line">          const_reverse_iterator;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于红黑树来说，它的构造存在两种方式：一种是以现有的RB-Tree复制一个新的RB-Tree，另一个就是产生一棵空树，如下图所示：<br><img data-src="https://7894651.xyz/RBTree/pic6.png" alt="avatar"></p><h2 id="元素插入与删除"><a href="#元素插入与删除" class="headerlink" title="元素插入与删除"></a>元素插入与删除</h2><p>在红黑树中，元素的插入与删除就要涉及到红黑树的调整了。不过对于红黑树而言，调整也就不过两种方式：左旋、右旋。那么为什么需要这些操作呢？这是由于在元素的插入与删除过程中，可能会违背红黑树的性质，因而需要它们来修复平衡。其实，如果理解左旋，右旋也就没有什么问题了，毕竟左右树是对称的。</p><h3 id="左旋操作"><a href="#左旋操作" class="headerlink" title="左旋操作"></a>左旋操作</h3><p>对于左旋操作大致需要六个步骤，这里需要设有一个前提：这里假设x的右孩子为y，这样就可以开始了：<br>&emsp;&emsp;Step1: 将”y的左孩子”设为”x的右孩子”,即B为x的右孩子<br>&emsp;&emsp;Step2: 将”x”设为“左孩子的父亲”,即将B的父亲设为x<br>&emsp;&emsp;Step3: 将 “x的父亲” 设为 “y的父亲”<br>&emsp;&emsp;Step4: 这里需要讨论父节点的三种情况：<br>&emsp;&emsp;&emsp;&emsp;Case1: 如果”x的父亲”为空节点，则将y设为根节点<br>&emsp;&emsp;&emsp;&emsp;Case2: 如果x是它的父节点的左孩子，则将y设为父节点的左孩子<br>&emsp;&emsp;&emsp;&emsp;Case3: 如果x是父节点的右孩子，则将y设为”x的父节点的右孩子”<br>&emsp;&emsp;Step5: 将x设为y的左孩子<br>&emsp;&emsp;Step6: 将x的父节点设为y<br>如下图所示：<br><img data-src="https://7894651.xyz/RBTree/pic7.png" alt="avatar"></p><h3 id="右旋操作"><a href="#右旋操作" class="headerlink" title="右旋操作"></a>右旋操作</h3><p>对于右旋操作大致操作也是一样的，这里也需要设有一个前提:这里假设y的左孩子为x这样就可以开始了：<br>&emsp;&emsp;Step1: 将 “x的右孩子” 设为 “y的左孩子”，即 将B设为y的左孩子<br>&emsp;&emsp;Step2: 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y<br>&emsp;&emsp;Step3: 将 “y的父亲” 设为 “x的父亲”<br>&emsp;&emsp;Step4: 这里需要讨论父节点的三种情况：<br>&emsp;&emsp;&emsp;&emsp;Case1: 如果”x的父亲”为空节点，则将y设为根节点<br>&emsp;&emsp;&emsp;&emsp;Case2: 如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”<br>&emsp;&emsp;&emsp;&emsp;Case3: (y是它父节点的左孩子) 将x设为“y的父节点的左孩子”<br>&emsp;&emsp;Step5: 将 “y” 设为 “x的右孩子”<br>&emsp;&emsp;Step6: 将 “y的父节点” 设为 “x”<br>如下图所示：<br><img data-src="https://7894651.xyz/RBTree/pic8.png" alt="avatar"></p><h3 id="元素插入"><a href="#元素插入" class="headerlink" title="元素插入"></a>元素插入</h3><p>一般而言，RB-Tree可以分为三个步骤：<br>&emsp;&emsp;Step1: 将红黑树当作二叉查找树，将节点插入<br>&emsp;&emsp;Step2: 将插入节点着色为红色<br>&emsp;&emsp;Step3: 通过一系列的旋转或着色操作，将其变成一棵红黑树</p><p>但是，正如之前所说，插入会导致红黑树的性质被破坏。所以对应的我们除了使用左旋或右旋外，我们还应对不符合性质的节点进行染色。<br>插入一个新的节点，颜色默认都是红色，这样就不会破坏性质5。当插入的新节点非红黑树的根节点，且其父节点颜色为红色，这样就会破坏性质4。这是一个基本前提，之后就是需要通过旋转与染色来修正平衡。其实这里主要就是对节点x的父节点为x祖父节点的左右子树进行一个讨论。由于树是对称的，在这里我只对当x的父节点为x祖父节点的左子树进行一个展开讨论。</p><p>&emsp;&emsp;前提：节点x的父节点x-&gt;parent是其祖父节点x-&gt;parent-&gt;parent的左孩子<br>&emsp;&emsp;情况1：若其叔叔节点y存在,且为红色<br>&emsp;&emsp;&emsp;&emsp;将其父节点x-&gt;parent改变成黑色<br>&emsp;&emsp;&emsp;&emsp;将其叔叔节点y改变成黑色<br>&emsp;&emsp;&emsp;&emsp;将其祖父节点变成红色<br>&emsp;&emsp;&emsp;&emsp;把祖父节点作为当前节点,一直上溯,继续判断是否破坏RB-Tree性质.<br>&emsp;&emsp;情况2：x的叔叔节点y是黑色且x是一个右孩子<br>&emsp;&emsp;&emsp;&emsp;则以其父节点作为旋转节点,进行一次左旋<br>&emsp;&emsp;&emsp;&emsp;旋转之后,节点x变成其父节点的左孩子<br>&emsp;&emsp;情况3：x的叔叔节点y是黑色且x是一个左孩子<br>&emsp;&emsp;&emsp;&emsp;情况2，通过变换也进入了情况3<br>&emsp;&emsp;&emsp;&emsp;改变其父节点x-&gt;parent颜色<br>&emsp;&emsp;&emsp;&emsp;改变其祖父节点x-&gt;parent-&gt;parent颜色<br>&emsp;&emsp;&emsp;&emsp;对其祖父节点进行一次右旋转<br>具体操作，可以见如下动图：<br><img data-src="https://7894651.xyz/RBTree/pic3.gif" alt="avatar"></p><h2 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h2><p>在这里，仅对元素的插入与搜索进行一个深入讨论。</p><h3 id="基本元素操作"><a href="#基本元素操作" class="headerlink" title="基本元素操作"></a>基本元素操作</h3><p>红黑树中，它所需的基本元素有很多。其中就包括：左节点、右节点、父节点、实值、键值、颜色等，具体到源码，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;parent; &#125;		<span class="comment">// 获取根节点</span></span><br><span class="line">  <span class="function">link_type&amp; <span class="title">leftmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;left; &#125;		<span class="comment">// 最小节点</span></span><br><span class="line">  <span class="function">link_type&amp; <span class="title">rightmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;right; &#125;	<span class="comment">// 最大节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前节点的左节点</span></span><br><span class="line">	<span class="comment">// 当前节点的右节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> x-&gt;value_field; &#125;	<span class="comment">// 当前节点的数据</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(x-&gt;color); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> ((link_type)x)-&gt;value_field; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(<span class="built_in">link_type</span>(x)));&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(<span class="built_in">link_type</span>(x)-&gt;color); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最小节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (link_type)  __rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  	<span class="comment">// 最大节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">                                <span class="comment">// accessors:</span></span><br><span class="line">  <span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> key_compare; &#125;</span><br><span class="line">  <span class="comment">// begin() 获取的是最小节点</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leftmost</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leftmost</span>(); &#125;</span><br><span class="line">  <span class="comment">// end() 头节点</span></span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">begin</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node_count == <span class="number">0</span>; &#125;		<span class="comment">// 树为空</span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node_count; &#125;			<span class="comment">// 节点计数</span></span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="元素插入-1"><a href="#元素插入-1" class="headerlink" title="元素插入"></a>元素插入</h3><p>红黑树提供了两种插入方式：insert_unique() 与 insert_equal()。前者表示被插入的键值在整棵树中必须唯一，后者则表示被插入节点的键值可以在整棵树中可以重复。具体源码解析如下：<br>具体源码解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::</span><br><span class="line">__insert(base_ptr x_, base_ptr y_, <span class="keyword">const</span> Value&amp; v) &#123;</span><br><span class="line">	<span class="comment">//参数x_为新值插入点，参数y_为插入点之父节点，参数v 为新值</span></span><br><span class="line">  link_type x = (link_type) x_;</span><br><span class="line">  link_type y = (link_type) y_;</span><br><span class="line">  link_type z;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (y == header || x != <span class="number">0</span> || <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(y))) &#123;</span><br><span class="line">    z = <span class="built_in">create_node</span>(v);	<span class="comment">//创建值为v的节点z</span></span><br><span class="line">    <span class="built_in">left</span>(y) = z;                <span class="comment">// also makes leftmost() = z when y == header</span></span><br><span class="line">    <span class="keyword">if</span> (y == header) &#123;</span><br><span class="line">      <span class="built_in">root</span>() = z;</span><br><span class="line">      <span class="built_in">rightmost</span>() = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="built_in">leftmost</span>())<span class="comment">//若y为最左节点</span></span><br><span class="line">      <span class="built_in">leftmost</span>() = z;           <span class="comment">// maintain leftmost() pointing to min node</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    z = <span class="built_in">create_node</span>(v);</span><br><span class="line">    <span class="built_in">right</span>(y) = z;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="built_in">rightmost</span>())</span><br><span class="line">      <span class="built_in">rightmost</span>() = z;          <span class="comment">// maintain rightmost() pointing to max node</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">parent</span>(z) = y;<span class="comment">//设定新节点的父节点</span></span><br><span class="line">  <span class="built_in">left</span>(z) = <span class="number">0</span>;<span class="comment">//设定新节点的左孩子</span></span><br><span class="line">  <span class="built_in">right</span>(z) = <span class="number">0</span>;<span class="comment">//设定新节点的右孩子</span></span><br><span class="line">  __rb_tree_rebalance(z, header-&gt;parent);<span class="comment">//调整RB-Tree使其满足性质</span></span><br><span class="line">  ++node_count;<span class="comment">//节点数增加1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">iterator</span>(z);<span class="comment">//返回新节点迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_equal</span>(<span class="keyword">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  link_type y = header;</span><br><span class="line">  link_type x = <span class="built_in">root</span>();<span class="comment">//从根节点开始</span></span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;<span class="comment">//从根节点开始,往下寻找合适插入点</span></span><br><span class="line">    y = x;</span><br><span class="line">	<span class="comment">//判断新插入节点值与当前节点x值的大小,以便判断往x的左边走还是往右边走</span></span><br><span class="line">    x = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)) ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __insert(x, y, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安插新值；节点键值不允许重复，若重复则安插无效。</span></span><br><span class="line"><span class="comment">// 注意，传回值是个pair，第一元素是个 RB-tree 迭代器，指向新增节点，</span></span><br><span class="line"><span class="comment">// 第二元素表示安插成功与否。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line">pair&lt;<span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator, <span class="keyword">bool</span>&gt;</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_unique</span>(<span class="keyword">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  link_type y = header;</span><br><span class="line">  link_type x = <span class="built_in">root</span>();<span class="comment">//从根节点开始</span></span><br><span class="line">  <span class="keyword">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;<span class="comment">//从根节点开始,往下寻找合适插入点</span></span><br><span class="line">    y = x;</span><br><span class="line">	<span class="comment">//判断新插入节点值与当前节点x值的大小,以便判断往x的左边走还是往右边走</span></span><br><span class="line">    comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x));</span><br><span class="line">    x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//离开while循环之后，y所指即为安插点的父节点，x必为叶子节点</span></span><br><span class="line">  iterator j = <span class="built_in">iterator</span>(y);   <span class="comment">//令迭代器j指向插入节点之父节点y</span></span><br><span class="line">  <span class="keyword">if</span> (comp)</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="built_in">begin</span>()) <span class="comment">//若插入点之父节点为最左节点</span></span><br><span class="line">      <span class="keyword">return</span> pair&lt;iterator,<span class="keyword">bool</span>&gt;(__insert(x, y, v), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//否则(插入点之父节点不在最左节点)</span></span><br><span class="line">      --j;<span class="comment">//调整j</span></span><br><span class="line"> <span class="comment">// 小于新值（表示遇「小」，将安插于右侧）</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node), <span class="built_in">KeyOfValue</span>()(v)))</span><br><span class="line">    <span class="keyword">return</span> pair&lt;iterator,<span class="keyword">bool</span>&gt;(__insert(x, y, v), <span class="literal">true</span>);</span><br><span class="line"> <span class="comment">//若运行到这里，表示键值有重复，不应该插入</span></span><br><span class="line">  <span class="keyword">return</span> pair&lt;iterator,<span class="keyword">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元素搜索"><a href="#元素搜索" class="headerlink" title="元素搜索"></a>元素搜索</h3><p>作为二叉搜索树的红黑树，元素的搜索可是它的拿手好戏。以下是它的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找RB树中是否有键值为k的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Value</span>, <span class="keyword">class</span> _<span class="title">KeyOfValue</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">Compare</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::const_iterator</span><br><span class="line">_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::<span class="built_in">find</span>(<span class="keyword">const</span> _Key&amp; __k) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  _Link_type __y = _M_header; <span class="comment">/* Last node which is not less than __k. */</span></span><br><span class="line">  _Link_type __x = _M_root(); <span class="comment">/* Current node. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__x != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_M_key_compare(_S_key(__x), __k))<span class="comment">//若k比当前节点x键值小</span></span><br><span class="line">      __y = __x, __x = _S_left(__x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __x = _S_right(__x);</span><br><span class="line">  &#125;</span><br><span class="line">  const_iterator __j = <span class="built_in">const_iterator</span>(__y);</span><br><span class="line">  <span class="keyword">return</span> (__j == <span class="built_in">end</span>() || _M_key_compare(__k, _S_key(__j._M_node))) ?</span><br><span class="line">    <span class="built_in">end</span>() : __j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算RB树中键值为k的节点的个数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Value</span>, <span class="keyword">class</span> _<span class="title">KeyOfValue</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">Compare</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::size_type</span><br><span class="line">_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;</span><br><span class="line">  ::<span class="built_in">count</span>(<span class="keyword">const</span> _Key&amp; __k) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  pair&lt;const_iterator, const_iterator&gt; __p = <span class="built_in">equal_range</span>(__k);</span><br><span class="line">  size_type __n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(__p.first, __p.second, __n);</span><br><span class="line">  <span class="keyword">return</span> __n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树总结"><a href="#红黑树总结" class="headerlink" title="红黑树总结"></a>红黑树总结</h2><p>优点：<br>&emsp;&emsp;1. 红黑树是效率相对较高的当我们插入和删除数据相对频繁的时候<br>&emsp;&emsp;2. 红黑树是自我平衡的所有操作的复杂度最多是O(logn)<br>&emsp;&emsp;3. 不管怎么变化，只有红黑两个常数</p><p>缺点：<br>&emsp;&emsp;由于红黑树并不追求高度平衡，因此搜索效率并没有AVL高</p><p>总结：实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/theory/" rel="tag"># theory</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/Travel-1/" rel="prev" title="宝华山之旅"><i class="fa fa-chevron-left"></i> 宝华山之旅</a></div><div class="post-nav-item"><a href="/2021/Apr_Summary/" rel="next" title="四月总结">四月总结 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">平衡二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">自平衡二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RB-Tree"><span class="nav-text">RB-Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A1"><span class="nav-text">节点设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-text">迭代器设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="nav-text">构造与析构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="nav-text">元素插入与删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E6%97%8B%E6%93%8D%E4%BD%9C"><span class="nav-text">左旋操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%B3%E6%97%8B%E6%93%8D%E4%BD%9C"><span class="nav-text">右旋操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5"><span class="nav-text">元素插入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="nav-text">元素操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="nav-text">基本元素操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5-1"><span class="nav-text">元素插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E6%90%9C%E7%B4%A2"><span class="nav-text">元素搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93"><span class="nav-text">红黑树总结</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Rabbet" src="/images/header.jpg"><p class="site-author-name" itemprop="name">Rabbet</p><div class="site-description" itemprop="description">个人Blog网站</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="/1508498108@qq.com" title="E-Mail → 1508498108@qq.com"><i class="fa fa-fw fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Rabbet</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">119k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">1:48</span></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/01/2019 15:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="本站已安全运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备19033310</a></div></div></footer></div><script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/utils.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/motion.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/schemes/pisces.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/gh/wdxc/wdxc.github.io/js/local-search.js"></script><script>document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script>window.addEventListener("load",()=>{quicklink({timeout:3e3,priority:!0,ignores:[e=>e.includes("#"),e=>"https://qfxul.cn/2021/The-Annotated-STL-Sources-4/"===e]})})</script></body></html>